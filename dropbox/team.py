# -*- coding: utf-8 -*-
# Auto-generated by Stone, do not modify.
try:
    from . import stone_validators as bv
    from . import stone_base as bb
except (SystemError, ValueError):
    # Catch errors raised when importing a relative module when not in a package.
    # This makes testing this file directly (outside of a package) easier.
    import stone_validators as bv
    import stone_base as bb

try:
    from . import (
        async,
        common,
        properties,
        team_common,
        team_policies,
        users,
    )
except (SystemError, ValueError):
    import async
    import common
    import properties
    import team_common
    import team_policies
    import users

class DeviceSession(object):
    """
    :ivar session_id: The session id
    :ivar ip_address: The IP address of the last activity from this session
    :ivar country: The country from which the last activity from this session
        was made
    :ivar created: The time this session was created
    :ivar updated: The time of the last activity from this session
    """

    __slots__ = [
        '_session_id_value',
        '_session_id_present',
        '_ip_address_value',
        '_ip_address_present',
        '_country_value',
        '_country_present',
        '_created_value',
        '_created_present',
        '_updated_value',
        '_updated_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 ip_address=None,
                 country=None,
                 created=None,
                 updated=None):
        self._session_id_value = None
        self._session_id_present = False
        self._ip_address_value = None
        self._ip_address_present = False
        self._country_value = None
        self._country_present = False
        self._created_value = None
        self._created_present = False
        self._updated_value = None
        self._updated_present = False
        if session_id is not None:
            self.session_id = session_id
        if ip_address is not None:
            self.ip_address = ip_address
        if country is not None:
            self.country = country
        if created is not None:
            self.created = created
        if updated is not None:
            self.updated = updated

    @property
    def session_id(self):
        """
        The session id

        :rtype: str
        """
        if self._session_id_present:
            return self._session_id_value
        else:
            raise AttributeError("missing required field 'session_id'")

    @session_id.setter
    def session_id(self, val):
        val = self._session_id_validator.validate(val)
        self._session_id_value = val
        self._session_id_present = True

    @session_id.deleter
    def session_id(self):
        self._session_id_value = None
        self._session_id_present = False

    @property
    def ip_address(self):
        """
        The IP address of the last activity from this session

        :rtype: str
        """
        if self._ip_address_present:
            return self._ip_address_value
        else:
            return None

    @ip_address.setter
    def ip_address(self, val):
        if val is None:
            del self.ip_address
            return
        val = self._ip_address_validator.validate(val)
        self._ip_address_value = val
        self._ip_address_present = True

    @ip_address.deleter
    def ip_address(self):
        self._ip_address_value = None
        self._ip_address_present = False

    @property
    def country(self):
        """
        The country from which the last activity from this session was made

        :rtype: str
        """
        if self._country_present:
            return self._country_value
        else:
            return None

    @country.setter
    def country(self, val):
        if val is None:
            del self.country
            return
        val = self._country_validator.validate(val)
        self._country_value = val
        self._country_present = True

    @country.deleter
    def country(self):
        self._country_value = None
        self._country_present = False

    @property
    def created(self):
        """
        The time this session was created

        :rtype: datetime.datetime
        """
        if self._created_present:
            return self._created_value
        else:
            return None

    @created.setter
    def created(self, val):
        if val is None:
            del self.created
            return
        val = self._created_validator.validate(val)
        self._created_value = val
        self._created_present = True

    @created.deleter
    def created(self):
        self._created_value = None
        self._created_present = False

    @property
    def updated(self):
        """
        The time of the last activity from this session

        :rtype: datetime.datetime
        """
        if self._updated_present:
            return self._updated_value
        else:
            return None

    @updated.setter
    def updated(self, val):
        if val is None:
            del self.updated
            return
        val = self._updated_validator.validate(val)
        self._updated_value = val
        self._updated_present = True

    @updated.deleter
    def updated(self):
        self._updated_value = None
        self._updated_present = False

    def __repr__(self):
        return 'DeviceSession(session_id={!r}, ip_address={!r}, country={!r}, created={!r}, updated={!r})'.format(
            self._session_id_value,
            self._ip_address_value,
            self._country_value,
            self._created_value,
            self._updated_value,
        )

DeviceSession_validator = bv.Struct(DeviceSession)

class ActiveWebSession(DeviceSession):
    """
    Information on active web sessions

    :ivar user_agent: Information on the hosting device
    :ivar os: Information on the hosting operating system
    :ivar browser: Information on the browser used for this web session
    """

    __slots__ = [
        '_user_agent_value',
        '_user_agent_present',
        '_os_value',
        '_os_present',
        '_browser_value',
        '_browser_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 user_agent=None,
                 os=None,
                 browser=None,
                 ip_address=None,
                 country=None,
                 created=None,
                 updated=None):
        super(ActiveWebSession, self).__init__(session_id,
                                               ip_address,
                                               country,
                                               created,
                                               updated)
        self._user_agent_value = None
        self._user_agent_present = False
        self._os_value = None
        self._os_present = False
        self._browser_value = None
        self._browser_present = False
        if user_agent is not None:
            self.user_agent = user_agent
        if os is not None:
            self.os = os
        if browser is not None:
            self.browser = browser

    @property
    def user_agent(self):
        """
        Information on the hosting device

        :rtype: str
        """
        if self._user_agent_present:
            return self._user_agent_value
        else:
            raise AttributeError("missing required field 'user_agent'")

    @user_agent.setter
    def user_agent(self, val):
        val = self._user_agent_validator.validate(val)
        self._user_agent_value = val
        self._user_agent_present = True

    @user_agent.deleter
    def user_agent(self):
        self._user_agent_value = None
        self._user_agent_present = False

    @property
    def os(self):
        """
        Information on the hosting operating system

        :rtype: str
        """
        if self._os_present:
            return self._os_value
        else:
            raise AttributeError("missing required field 'os'")

    @os.setter
    def os(self, val):
        val = self._os_validator.validate(val)
        self._os_value = val
        self._os_present = True

    @os.deleter
    def os(self):
        self._os_value = None
        self._os_present = False

    @property
    def browser(self):
        """
        Information on the browser used for this web session

        :rtype: str
        """
        if self._browser_present:
            return self._browser_value
        else:
            raise AttributeError("missing required field 'browser'")

    @browser.setter
    def browser(self, val):
        val = self._browser_validator.validate(val)
        self._browser_value = val
        self._browser_present = True

    @browser.deleter
    def browser(self):
        self._browser_value = None
        self._browser_present = False

    def __repr__(self):
        return 'ActiveWebSession(session_id={!r}, user_agent={!r}, os={!r}, browser={!r}, ip_address={!r}, country={!r}, created={!r}, updated={!r})'.format(
            self._session_id_value,
            self._user_agent_value,
            self._os_value,
            self._browser_value,
            self._ip_address_value,
            self._country_value,
            self._created_value,
            self._updated_value,
        )

ActiveWebSession_validator = bv.Struct(ActiveWebSession)

class AddPropertyTemplateArg(properties.PropertyGroupTemplate):
    """
    Arguments for adding property templates.
    """

    __slots__ = [
    ]

    _has_required_fields = True

    def __init__(self,
                 name=None,
                 description=None,
                 fields=None):
        super(AddPropertyTemplateArg, self).__init__(name,
                                                     description,
                                                     fields)

    def __repr__(self):
        return 'AddPropertyTemplateArg(name={!r}, description={!r}, fields={!r})'.format(
            self._name_value,
            self._description_value,
            self._fields_value,
        )

AddPropertyTemplateArg_validator = bv.Struct(AddPropertyTemplateArg)

class AddPropertyTemplateResult(object):
    """
    :ivar template_id: An identifier for property template added by
        :meth:`dropbox.dropbox.Dropbox.team_properties_template_add`.
    """

    __slots__ = [
        '_template_id_value',
        '_template_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 template_id=None):
        self._template_id_value = None
        self._template_id_present = False
        if template_id is not None:
            self.template_id = template_id

    @property
    def template_id(self):
        """
        An identifier for property template added by
        :meth:`dropbox.dropbox.Dropbox.team_properties_template_add`.

        :rtype: str
        """
        if self._template_id_present:
            return self._template_id_value
        else:
            raise AttributeError("missing required field 'template_id'")

    @template_id.setter
    def template_id(self, val):
        val = self._template_id_validator.validate(val)
        self._template_id_value = val
        self._template_id_present = True

    @template_id.deleter
    def template_id(self):
        self._template_id_value = None
        self._template_id_present = False

    def __repr__(self):
        return 'AddPropertyTemplateResult(template_id={!r})'.format(
            self._template_id_value,
        )

AddPropertyTemplateResult_validator = bv.Struct(AddPropertyTemplateResult)

class AdminTier(bb.Union):
    """
    Describes which team-related admin permissions a user has.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar team_admin: User is an administrator of the team - has all
        permissions.
    :ivar user_management_admin: User can do most user provisioning,
        de-provisioning and management.
    :ivar support_admin: User can do a limited set of common support tasks for
        existing users.
    :ivar member_only: User is not an admin of the team.
    """

    _catch_all = None
    # Attribute is overwritten below the class definition
    team_admin = None
    # Attribute is overwritten below the class definition
    user_management_admin = None
    # Attribute is overwritten below the class definition
    support_admin = None
    # Attribute is overwritten below the class definition
    member_only = None

    def is_team_admin(self):
        """
        Check if the union tag is ``team_admin``.

        :rtype: bool
        """
        return self._tag == 'team_admin'

    def is_user_management_admin(self):
        """
        Check if the union tag is ``user_management_admin``.

        :rtype: bool
        """
        return self._tag == 'user_management_admin'

    def is_support_admin(self):
        """
        Check if the union tag is ``support_admin``.

        :rtype: bool
        """
        return self._tag == 'support_admin'

    def is_member_only(self):
        """
        Check if the union tag is ``member_only``.

        :rtype: bool
        """
        return self._tag == 'member_only'

    def __repr__(self):
        return 'AdminTier(%r, %r)' % (self._tag, self._value)

AdminTier_validator = bv.Union(AdminTier)

class ApiApp(object):
    """
    Information on linked third party applications

    :ivar app_id: The application unique id
    :ivar app_name: The application name
    :ivar publisher: The application publisher name
    :ivar publisher_url: The publisher's URL
    :ivar linked: The time this application was linked
    :ivar is_app_folder: Whether the linked application uses a dedicated folder
    """

    __slots__ = [
        '_app_id_value',
        '_app_id_present',
        '_app_name_value',
        '_app_name_present',
        '_publisher_value',
        '_publisher_present',
        '_publisher_url_value',
        '_publisher_url_present',
        '_linked_value',
        '_linked_present',
        '_is_app_folder_value',
        '_is_app_folder_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 app_id=None,
                 app_name=None,
                 is_app_folder=None,
                 publisher=None,
                 publisher_url=None,
                 linked=None):
        self._app_id_value = None
        self._app_id_present = False
        self._app_name_value = None
        self._app_name_present = False
        self._publisher_value = None
        self._publisher_present = False
        self._publisher_url_value = None
        self._publisher_url_present = False
        self._linked_value = None
        self._linked_present = False
        self._is_app_folder_value = None
        self._is_app_folder_present = False
        if app_id is not None:
            self.app_id = app_id
        if app_name is not None:
            self.app_name = app_name
        if publisher is not None:
            self.publisher = publisher
        if publisher_url is not None:
            self.publisher_url = publisher_url
        if linked is not None:
            self.linked = linked
        if is_app_folder is not None:
            self.is_app_folder = is_app_folder

    @property
    def app_id(self):
        """
        The application unique id

        :rtype: str
        """
        if self._app_id_present:
            return self._app_id_value
        else:
            raise AttributeError("missing required field 'app_id'")

    @app_id.setter
    def app_id(self, val):
        val = self._app_id_validator.validate(val)
        self._app_id_value = val
        self._app_id_present = True

    @app_id.deleter
    def app_id(self):
        self._app_id_value = None
        self._app_id_present = False

    @property
    def app_name(self):
        """
        The application name

        :rtype: str
        """
        if self._app_name_present:
            return self._app_name_value
        else:
            raise AttributeError("missing required field 'app_name'")

    @app_name.setter
    def app_name(self, val):
        val = self._app_name_validator.validate(val)
        self._app_name_value = val
        self._app_name_present = True

    @app_name.deleter
    def app_name(self):
        self._app_name_value = None
        self._app_name_present = False

    @property
    def publisher(self):
        """
        The application publisher name

        :rtype: str
        """
        if self._publisher_present:
            return self._publisher_value
        else:
            return None

    @publisher.setter
    def publisher(self, val):
        if val is None:
            del self.publisher
            return
        val = self._publisher_validator.validate(val)
        self._publisher_value = val
        self._publisher_present = True

    @publisher.deleter
    def publisher(self):
        self._publisher_value = None
        self._publisher_present = False

    @property
    def publisher_url(self):
        """
        The publisher's URL

        :rtype: str
        """
        if self._publisher_url_present:
            return self._publisher_url_value
        else:
            return None

    @publisher_url.setter
    def publisher_url(self, val):
        if val is None:
            del self.publisher_url
            return
        val = self._publisher_url_validator.validate(val)
        self._publisher_url_value = val
        self._publisher_url_present = True

    @publisher_url.deleter
    def publisher_url(self):
        self._publisher_url_value = None
        self._publisher_url_present = False

    @property
    def linked(self):
        """
        The time this application was linked

        :rtype: datetime.datetime
        """
        if self._linked_present:
            return self._linked_value
        else:
            return None

    @linked.setter
    def linked(self, val):
        if val is None:
            del self.linked
            return
        val = self._linked_validator.validate(val)
        self._linked_value = val
        self._linked_present = True

    @linked.deleter
    def linked(self):
        self._linked_value = None
        self._linked_present = False

    @property
    def is_app_folder(self):
        """
        Whether the linked application uses a dedicated folder

        :rtype: bool
        """
        if self._is_app_folder_present:
            return self._is_app_folder_value
        else:
            raise AttributeError("missing required field 'is_app_folder'")

    @is_app_folder.setter
    def is_app_folder(self, val):
        val = self._is_app_folder_validator.validate(val)
        self._is_app_folder_value = val
        self._is_app_folder_present = True

    @is_app_folder.deleter
    def is_app_folder(self):
        self._is_app_folder_value = None
        self._is_app_folder_present = False

    def __repr__(self):
        return 'ApiApp(app_id={!r}, app_name={!r}, is_app_folder={!r}, publisher={!r}, publisher_url={!r}, linked={!r})'.format(
            self._app_id_value,
            self._app_name_value,
            self._is_app_folder_value,
            self._publisher_value,
            self._publisher_url_value,
            self._linked_value,
        )

ApiApp_validator = bv.Struct(ApiApp)

class BaseDfbReport(object):
    """
    Base report structure.

    :ivar start_date: First date present in the results as 'YYYY-MM-DD' or None.
    """

    __slots__ = [
        '_start_date_value',
        '_start_date_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 start_date=None):
        self._start_date_value = None
        self._start_date_present = False
        if start_date is not None:
            self.start_date = start_date

    @property
    def start_date(self):
        """
        First date present in the results as 'YYYY-MM-DD' or None.

        :rtype: str
        """
        if self._start_date_present:
            return self._start_date_value
        else:
            raise AttributeError("missing required field 'start_date'")

    @start_date.setter
    def start_date(self, val):
        val = self._start_date_validator.validate(val)
        self._start_date_value = val
        self._start_date_present = True

    @start_date.deleter
    def start_date(self):
        self._start_date_value = None
        self._start_date_present = False

    def __repr__(self):
        return 'BaseDfbReport(start_date={!r})'.format(
            self._start_date_value,
        )

BaseDfbReport_validator = bv.Struct(BaseDfbReport)

class BaseTeamFolderError(bb.Union):
    """
    Base error that all errors for existing team folders should extend.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    @classmethod
    def access_error(cls, val):
        """
        Create an instance of this class set to the ``access_error`` tag with
        value ``val``.

        :param TeamFolderAccessError val:
        :rtype: BaseTeamFolderError
        """
        return cls('access_error', val)

    @classmethod
    def status_error(cls, val):
        """
        Create an instance of this class set to the ``status_error`` tag with
        value ``val``.

        :param TeamFolderInvalidStatusError val:
        :rtype: BaseTeamFolderError
        """
        return cls('status_error', val)

    def is_access_error(self):
        """
        Check if the union tag is ``access_error``.

        :rtype: bool
        """
        return self._tag == 'access_error'

    def is_status_error(self):
        """
        Check if the union tag is ``status_error``.

        :rtype: bool
        """
        return self._tag == 'status_error'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def get_access_error(self):
        """
        Only call this if :meth:`is_access_error` is true.

        :rtype: TeamFolderAccessError
        """
        if not self.is_access_error():
            raise AttributeError("tag 'access_error' not set")
        return self._value

    def get_status_error(self):
        """
        Only call this if :meth:`is_status_error` is true.

        :rtype: TeamFolderInvalidStatusError
        """
        if not self.is_status_error():
            raise AttributeError("tag 'status_error' not set")
        return self._value

    def __repr__(self):
        return 'BaseTeamFolderError(%r, %r)' % (self._tag, self._value)

BaseTeamFolderError_validator = bv.Union(BaseTeamFolderError)

class DateRange(object):
    """
    Input arguments that can be provided for most reports.

    :ivar start_date: Optional starting date (inclusive)
    :ivar end_date: Optional ending date (exclusive)
    """

    __slots__ = [
        '_start_date_value',
        '_start_date_present',
        '_end_date_value',
        '_end_date_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 start_date=None,
                 end_date=None):
        self._start_date_value = None
        self._start_date_present = False
        self._end_date_value = None
        self._end_date_present = False
        if start_date is not None:
            self.start_date = start_date
        if end_date is not None:
            self.end_date = end_date

    @property
    def start_date(self):
        """
        Optional starting date (inclusive)

        :rtype: datetime.datetime
        """
        if self._start_date_present:
            return self._start_date_value
        else:
            return None

    @start_date.setter
    def start_date(self, val):
        if val is None:
            del self.start_date
            return
        val = self._start_date_validator.validate(val)
        self._start_date_value = val
        self._start_date_present = True

    @start_date.deleter
    def start_date(self):
        self._start_date_value = None
        self._start_date_present = False

    @property
    def end_date(self):
        """
        Optional ending date (exclusive)

        :rtype: datetime.datetime
        """
        if self._end_date_present:
            return self._end_date_value
        else:
            return None

    @end_date.setter
    def end_date(self, val):
        if val is None:
            del self.end_date
            return
        val = self._end_date_validator.validate(val)
        self._end_date_value = val
        self._end_date_present = True

    @end_date.deleter
    def end_date(self):
        self._end_date_value = None
        self._end_date_present = False

    def __repr__(self):
        return 'DateRange(start_date={!r}, end_date={!r})'.format(
            self._start_date_value,
            self._end_date_value,
        )

DateRange_validator = bv.Struct(DateRange)

class DateRangeError(bb.Union):
    """
    Errors that can originate from problems in input arguments to reports.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'DateRangeError(%r, %r)' % (self._tag, self._value)

DateRangeError_validator = bv.Union(DateRangeError)

class DesktopClientSession(DeviceSession):
    """
    Information about linked Dropbox desktop client sessions

    :ivar host_name: Name of the hosting desktop
    :ivar client_type: The Dropbox desktop client type
    :ivar client_version: The Dropbox client version
    :ivar platform: Information on the hosting platform
    :ivar is_delete_on_unlink_supported: Whether it's possible to delete all of
        the account files upon unlinking
    """

    __slots__ = [
        '_host_name_value',
        '_host_name_present',
        '_client_type_value',
        '_client_type_present',
        '_client_version_value',
        '_client_version_present',
        '_platform_value',
        '_platform_present',
        '_is_delete_on_unlink_supported_value',
        '_is_delete_on_unlink_supported_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 host_name=None,
                 client_type=None,
                 client_version=None,
                 platform=None,
                 is_delete_on_unlink_supported=None,
                 ip_address=None,
                 country=None,
                 created=None,
                 updated=None):
        super(DesktopClientSession, self).__init__(session_id,
                                                   ip_address,
                                                   country,
                                                   created,
                                                   updated)
        self._host_name_value = None
        self._host_name_present = False
        self._client_type_value = None
        self._client_type_present = False
        self._client_version_value = None
        self._client_version_present = False
        self._platform_value = None
        self._platform_present = False
        self._is_delete_on_unlink_supported_value = None
        self._is_delete_on_unlink_supported_present = False
        if host_name is not None:
            self.host_name = host_name
        if client_type is not None:
            self.client_type = client_type
        if client_version is not None:
            self.client_version = client_version
        if platform is not None:
            self.platform = platform
        if is_delete_on_unlink_supported is not None:
            self.is_delete_on_unlink_supported = is_delete_on_unlink_supported

    @property
    def host_name(self):
        """
        Name of the hosting desktop

        :rtype: str
        """
        if self._host_name_present:
            return self._host_name_value
        else:
            raise AttributeError("missing required field 'host_name'")

    @host_name.setter
    def host_name(self, val):
        val = self._host_name_validator.validate(val)
        self._host_name_value = val
        self._host_name_present = True

    @host_name.deleter
    def host_name(self):
        self._host_name_value = None
        self._host_name_present = False

    @property
    def client_type(self):
        """
        The Dropbox desktop client type

        :rtype: DesktopPlatform
        """
        if self._client_type_present:
            return self._client_type_value
        else:
            raise AttributeError("missing required field 'client_type'")

    @client_type.setter
    def client_type(self, val):
        self._client_type_validator.validate_type_only(val)
        self._client_type_value = val
        self._client_type_present = True

    @client_type.deleter
    def client_type(self):
        self._client_type_value = None
        self._client_type_present = False

    @property
    def client_version(self):
        """
        The Dropbox client version

        :rtype: str
        """
        if self._client_version_present:
            return self._client_version_value
        else:
            raise AttributeError("missing required field 'client_version'")

    @client_version.setter
    def client_version(self, val):
        val = self._client_version_validator.validate(val)
        self._client_version_value = val
        self._client_version_present = True

    @client_version.deleter
    def client_version(self):
        self._client_version_value = None
        self._client_version_present = False

    @property
    def platform(self):
        """
        Information on the hosting platform

        :rtype: str
        """
        if self._platform_present:
            return self._platform_value
        else:
            raise AttributeError("missing required field 'platform'")

    @platform.setter
    def platform(self, val):
        val = self._platform_validator.validate(val)
        self._platform_value = val
        self._platform_present = True

    @platform.deleter
    def platform(self):
        self._platform_value = None
        self._platform_present = False

    @property
    def is_delete_on_unlink_supported(self):
        """
        Whether it's possible to delete all of the account files upon unlinking

        :rtype: bool
        """
        if self._is_delete_on_unlink_supported_present:
            return self._is_delete_on_unlink_supported_value
        else:
            raise AttributeError("missing required field 'is_delete_on_unlink_supported'")

    @is_delete_on_unlink_supported.setter
    def is_delete_on_unlink_supported(self, val):
        val = self._is_delete_on_unlink_supported_validator.validate(val)
        self._is_delete_on_unlink_supported_value = val
        self._is_delete_on_unlink_supported_present = True

    @is_delete_on_unlink_supported.deleter
    def is_delete_on_unlink_supported(self):
        self._is_delete_on_unlink_supported_value = None
        self._is_delete_on_unlink_supported_present = False

    def __repr__(self):
        return 'DesktopClientSession(session_id={!r}, host_name={!r}, client_type={!r}, client_version={!r}, platform={!r}, is_delete_on_unlink_supported={!r}, ip_address={!r}, country={!r}, created={!r}, updated={!r})'.format(
            self._session_id_value,
            self._host_name_value,
            self._client_type_value,
            self._client_version_value,
            self._platform_value,
            self._is_delete_on_unlink_supported_value,
            self._ip_address_value,
            self._country_value,
            self._created_value,
            self._updated_value,
        )

DesktopClientSession_validator = bv.Struct(DesktopClientSession)

class DesktopPlatform(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar windows: Official Windows Dropbox desktop client
    :ivar mac: Official Mac Dropbox desktop client
    :ivar linux: Official Linux Dropbox desktop client
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    windows = None
    # Attribute is overwritten below the class definition
    mac = None
    # Attribute is overwritten below the class definition
    linux = None
    # Attribute is overwritten below the class definition
    other = None

    def is_windows(self):
        """
        Check if the union tag is ``windows``.

        :rtype: bool
        """
        return self._tag == 'windows'

    def is_mac(self):
        """
        Check if the union tag is ``mac``.

        :rtype: bool
        """
        return self._tag == 'mac'

    def is_linux(self):
        """
        Check if the union tag is ``linux``.

        :rtype: bool
        """
        return self._tag == 'linux'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'DesktopPlatform(%r, %r)' % (self._tag, self._value)

DesktopPlatform_validator = bv.Union(DesktopPlatform)

class DeviceSessionArg(object):
    """
    :ivar session_id: The session id
    :ivar team_member_id: The unique id of the member owning the device
    """

    __slots__ = [
        '_session_id_value',
        '_session_id_present',
        '_team_member_id_value',
        '_team_member_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 team_member_id=None):
        self._session_id_value = None
        self._session_id_present = False
        self._team_member_id_value = None
        self._team_member_id_present = False
        if session_id is not None:
            self.session_id = session_id
        if team_member_id is not None:
            self.team_member_id = team_member_id

    @property
    def session_id(self):
        """
        The session id

        :rtype: str
        """
        if self._session_id_present:
            return self._session_id_value
        else:
            raise AttributeError("missing required field 'session_id'")

    @session_id.setter
    def session_id(self, val):
        val = self._session_id_validator.validate(val)
        self._session_id_value = val
        self._session_id_present = True

    @session_id.deleter
    def session_id(self):
        self._session_id_value = None
        self._session_id_present = False

    @property
    def team_member_id(self):
        """
        The unique id of the member owning the device

        :rtype: str
        """
        if self._team_member_id_present:
            return self._team_member_id_value
        else:
            raise AttributeError("missing required field 'team_member_id'")

    @team_member_id.setter
    def team_member_id(self, val):
        val = self._team_member_id_validator.validate(val)
        self._team_member_id_value = val
        self._team_member_id_present = True

    @team_member_id.deleter
    def team_member_id(self):
        self._team_member_id_value = None
        self._team_member_id_present = False

    def __repr__(self):
        return 'DeviceSessionArg(session_id={!r}, team_member_id={!r})'.format(
            self._session_id_value,
            self._team_member_id_value,
        )

DeviceSessionArg_validator = bv.Struct(DeviceSessionArg)

class DevicesActive(object):
    """
    Each of the items is an array of values, one value per day. The value is the
    number of devices active within a time window, ending with that day. If
    there is no data for a day, then the value will be None.

    :ivar windows: Array of number of linked windows (desktop) clients with
        activity.
    :ivar macos: Array of number of linked mac (desktop) clients with activity.
    :ivar linux: Array of number of linked linus (desktop) clients with
        activity.
    :ivar ios: Array of number of linked ios devices with activity.
    :ivar android: Array of number of linked android devices with activity.
    :ivar other: Array of number of other linked devices (blackberry, windows
        phone, etc)  with activity.
    :ivar total: Array of total number of linked clients with activity.
    """

    __slots__ = [
        '_windows_value',
        '_windows_present',
        '_macos_value',
        '_macos_present',
        '_linux_value',
        '_linux_present',
        '_ios_value',
        '_ios_present',
        '_android_value',
        '_android_present',
        '_other_value',
        '_other_present',
        '_total_value',
        '_total_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 windows=None,
                 macos=None,
                 linux=None,
                 ios=None,
                 android=None,
                 other=None,
                 total=None):
        self._windows_value = None
        self._windows_present = False
        self._macos_value = None
        self._macos_present = False
        self._linux_value = None
        self._linux_present = False
        self._ios_value = None
        self._ios_present = False
        self._android_value = None
        self._android_present = False
        self._other_value = None
        self._other_present = False
        self._total_value = None
        self._total_present = False
        if windows is not None:
            self.windows = windows
        if macos is not None:
            self.macos = macos
        if linux is not None:
            self.linux = linux
        if ios is not None:
            self.ios = ios
        if android is not None:
            self.android = android
        if other is not None:
            self.other = other
        if total is not None:
            self.total = total

    @property
    def windows(self):
        """
        Array of number of linked windows (desktop) clients with activity.

        :rtype: list of [Optional[long]]
        """
        if self._windows_present:
            return self._windows_value
        else:
            raise AttributeError("missing required field 'windows'")

    @windows.setter
    def windows(self, val):
        val = self._windows_validator.validate(val)
        self._windows_value = val
        self._windows_present = True

    @windows.deleter
    def windows(self):
        self._windows_value = None
        self._windows_present = False

    @property
    def macos(self):
        """
        Array of number of linked mac (desktop) clients with activity.

        :rtype: list of [Optional[long]]
        """
        if self._macos_present:
            return self._macos_value
        else:
            raise AttributeError("missing required field 'macos'")

    @macos.setter
    def macos(self, val):
        val = self._macos_validator.validate(val)
        self._macos_value = val
        self._macos_present = True

    @macos.deleter
    def macos(self):
        self._macos_value = None
        self._macos_present = False

    @property
    def linux(self):
        """
        Array of number of linked linus (desktop) clients with activity.

        :rtype: list of [Optional[long]]
        """
        if self._linux_present:
            return self._linux_value
        else:
            raise AttributeError("missing required field 'linux'")

    @linux.setter
    def linux(self, val):
        val = self._linux_validator.validate(val)
        self._linux_value = val
        self._linux_present = True

    @linux.deleter
    def linux(self):
        self._linux_value = None
        self._linux_present = False

    @property
    def ios(self):
        """
        Array of number of linked ios devices with activity.

        :rtype: list of [Optional[long]]
        """
        if self._ios_present:
            return self._ios_value
        else:
            raise AttributeError("missing required field 'ios'")

    @ios.setter
    def ios(self, val):
        val = self._ios_validator.validate(val)
        self._ios_value = val
        self._ios_present = True

    @ios.deleter
    def ios(self):
        self._ios_value = None
        self._ios_present = False

    @property
    def android(self):
        """
        Array of number of linked android devices with activity.

        :rtype: list of [Optional[long]]
        """
        if self._android_present:
            return self._android_value
        else:
            raise AttributeError("missing required field 'android'")

    @android.setter
    def android(self, val):
        val = self._android_validator.validate(val)
        self._android_value = val
        self._android_present = True

    @android.deleter
    def android(self):
        self._android_value = None
        self._android_present = False

    @property
    def other(self):
        """
        Array of number of other linked devices (blackberry, windows phone, etc)
        with activity.

        :rtype: list of [Optional[long]]
        """
        if self._other_present:
            return self._other_value
        else:
            raise AttributeError("missing required field 'other'")

    @other.setter
    def other(self, val):
        val = self._other_validator.validate(val)
        self._other_value = val
        self._other_present = True

    @other.deleter
    def other(self):
        self._other_value = None
        self._other_present = False

    @property
    def total(self):
        """
        Array of total number of linked clients with activity.

        :rtype: list of [Optional[long]]
        """
        if self._total_present:
            return self._total_value
        else:
            raise AttributeError("missing required field 'total'")

    @total.setter
    def total(self, val):
        val = self._total_validator.validate(val)
        self._total_value = val
        self._total_present = True

    @total.deleter
    def total(self):
        self._total_value = None
        self._total_present = False

    def __repr__(self):
        return 'DevicesActive(windows={!r}, macos={!r}, linux={!r}, ios={!r}, android={!r}, other={!r}, total={!r})'.format(
            self._windows_value,
            self._macos_value,
            self._linux_value,
            self._ios_value,
            self._android_value,
            self._other_value,
            self._total_value,
        )

DevicesActive_validator = bv.Struct(DevicesActive)

class GetActivityReport(BaseDfbReport):
    """
    Activity Report Result. Each of the items in the storage report is an array
    of values, one value per day. If there is no data for a day, then the value
    will be None.

    :ivar adds: Array of total number of adds by team members.
    :ivar edits: Array of number of edits by team members. If the same user
        edits the same file multiple times this is counted as a single edit.
    :ivar deletes: Array of total number of deletes by team members.
    :ivar active_users_28_day: Array of the number of users who have been active
        in the last 28 days.
    :ivar active_users_7_day: Array of the number of users who have been active
        in the last week.
    :ivar active_users_1_day: Array of the number of users who have been active
        in the last day.
    :ivar active_shared_folders_28_day: Array of the number of shared folders
        with some activity in the last 28 days.
    :ivar active_shared_folders_7_day: Array of the number of shared folders
        with some activity in the last week.
    :ivar active_shared_folders_1_day: Array of the number of shared folders
        with some activity in the last day.
    :ivar shared_links_created: Array of the number of shared links created.
    :ivar shared_links_viewed_by_team: Array of the number of views by team
        users to shared links created by the team.
    :ivar shared_links_viewed_by_outside_user: Array of the number of views by
        users outside of the team to shared links created by the team.
    :ivar shared_links_viewed_by_not_logged_in: Array of the number of views by
        non-logged-in users to shared links created by the team.
    :ivar shared_links_viewed_total: Array of the total number of views to
        shared links created by the team.
    """

    __slots__ = [
        '_adds_value',
        '_adds_present',
        '_edits_value',
        '_edits_present',
        '_deletes_value',
        '_deletes_present',
        '_active_users_28_day_value',
        '_active_users_28_day_present',
        '_active_users_7_day_value',
        '_active_users_7_day_present',
        '_active_users_1_day_value',
        '_active_users_1_day_present',
        '_active_shared_folders_28_day_value',
        '_active_shared_folders_28_day_present',
        '_active_shared_folders_7_day_value',
        '_active_shared_folders_7_day_present',
        '_active_shared_folders_1_day_value',
        '_active_shared_folders_1_day_present',
        '_shared_links_created_value',
        '_shared_links_created_present',
        '_shared_links_viewed_by_team_value',
        '_shared_links_viewed_by_team_present',
        '_shared_links_viewed_by_outside_user_value',
        '_shared_links_viewed_by_outside_user_present',
        '_shared_links_viewed_by_not_logged_in_value',
        '_shared_links_viewed_by_not_logged_in_present',
        '_shared_links_viewed_total_value',
        '_shared_links_viewed_total_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 start_date=None,
                 adds=None,
                 edits=None,
                 deletes=None,
                 active_users_28_day=None,
                 active_users_7_day=None,
                 active_users_1_day=None,
                 active_shared_folders_28_day=None,
                 active_shared_folders_7_day=None,
                 active_shared_folders_1_day=None,
                 shared_links_created=None,
                 shared_links_viewed_by_team=None,
                 shared_links_viewed_by_outside_user=None,
                 shared_links_viewed_by_not_logged_in=None,
                 shared_links_viewed_total=None):
        super(GetActivityReport, self).__init__(start_date)
        self._adds_value = None
        self._adds_present = False
        self._edits_value = None
        self._edits_present = False
        self._deletes_value = None
        self._deletes_present = False
        self._active_users_28_day_value = None
        self._active_users_28_day_present = False
        self._active_users_7_day_value = None
        self._active_users_7_day_present = False
        self._active_users_1_day_value = None
        self._active_users_1_day_present = False
        self._active_shared_folders_28_day_value = None
        self._active_shared_folders_28_day_present = False
        self._active_shared_folders_7_day_value = None
        self._active_shared_folders_7_day_present = False
        self._active_shared_folders_1_day_value = None
        self._active_shared_folders_1_day_present = False
        self._shared_links_created_value = None
        self._shared_links_created_present = False
        self._shared_links_viewed_by_team_value = None
        self._shared_links_viewed_by_team_present = False
        self._shared_links_viewed_by_outside_user_value = None
        self._shared_links_viewed_by_outside_user_present = False
        self._shared_links_viewed_by_not_logged_in_value = None
        self._shared_links_viewed_by_not_logged_in_present = False
        self._shared_links_viewed_total_value = None
        self._shared_links_viewed_total_present = False
        if adds is not None:
            self.adds = adds
        if edits is not None:
            self.edits = edits
        if deletes is not None:
            self.deletes = deletes
        if active_users_28_day is not None:
            self.active_users_28_day = active_users_28_day
        if active_users_7_day is not None:
            self.active_users_7_day = active_users_7_day
        if active_users_1_day is not None:
            self.active_users_1_day = active_users_1_day
        if active_shared_folders_28_day is not None:
            self.active_shared_folders_28_day = active_shared_folders_28_day
        if active_shared_folders_7_day is not None:
            self.active_shared_folders_7_day = active_shared_folders_7_day
        if active_shared_folders_1_day is not None:
            self.active_shared_folders_1_day = active_shared_folders_1_day
        if shared_links_created is not None:
            self.shared_links_created = shared_links_created
        if shared_links_viewed_by_team is not None:
            self.shared_links_viewed_by_team = shared_links_viewed_by_team
        if shared_links_viewed_by_outside_user is not None:
            self.shared_links_viewed_by_outside_user = shared_links_viewed_by_outside_user
        if shared_links_viewed_by_not_logged_in is not None:
            self.shared_links_viewed_by_not_logged_in = shared_links_viewed_by_not_logged_in
        if shared_links_viewed_total is not None:
            self.shared_links_viewed_total = shared_links_viewed_total

    @property
    def adds(self):
        """
        Array of total number of adds by team members.

        :rtype: list of [Optional[long]]
        """
        if self._adds_present:
            return self._adds_value
        else:
            raise AttributeError("missing required field 'adds'")

    @adds.setter
    def adds(self, val):
        val = self._adds_validator.validate(val)
        self._adds_value = val
        self._adds_present = True

    @adds.deleter
    def adds(self):
        self._adds_value = None
        self._adds_present = False

    @property
    def edits(self):
        """
        Array of number of edits by team members. If the same user edits the
        same file multiple times this is counted as a single edit.

        :rtype: list of [Optional[long]]
        """
        if self._edits_present:
            return self._edits_value
        else:
            raise AttributeError("missing required field 'edits'")

    @edits.setter
    def edits(self, val):
        val = self._edits_validator.validate(val)
        self._edits_value = val
        self._edits_present = True

    @edits.deleter
    def edits(self):
        self._edits_value = None
        self._edits_present = False

    @property
    def deletes(self):
        """
        Array of total number of deletes by team members.

        :rtype: list of [Optional[long]]
        """
        if self._deletes_present:
            return self._deletes_value
        else:
            raise AttributeError("missing required field 'deletes'")

    @deletes.setter
    def deletes(self, val):
        val = self._deletes_validator.validate(val)
        self._deletes_value = val
        self._deletes_present = True

    @deletes.deleter
    def deletes(self):
        self._deletes_value = None
        self._deletes_present = False

    @property
    def active_users_28_day(self):
        """
        Array of the number of users who have been active in the last 28 days.

        :rtype: list of [Optional[long]]
        """
        if self._active_users_28_day_present:
            return self._active_users_28_day_value
        else:
            raise AttributeError("missing required field 'active_users_28_day'")

    @active_users_28_day.setter
    def active_users_28_day(self, val):
        val = self._active_users_28_day_validator.validate(val)
        self._active_users_28_day_value = val
        self._active_users_28_day_present = True

    @active_users_28_day.deleter
    def active_users_28_day(self):
        self._active_users_28_day_value = None
        self._active_users_28_day_present = False

    @property
    def active_users_7_day(self):
        """
        Array of the number of users who have been active in the last week.

        :rtype: list of [Optional[long]]
        """
        if self._active_users_7_day_present:
            return self._active_users_7_day_value
        else:
            raise AttributeError("missing required field 'active_users_7_day'")

    @active_users_7_day.setter
    def active_users_7_day(self, val):
        val = self._active_users_7_day_validator.validate(val)
        self._active_users_7_day_value = val
        self._active_users_7_day_present = True

    @active_users_7_day.deleter
    def active_users_7_day(self):
        self._active_users_7_day_value = None
        self._active_users_7_day_present = False

    @property
    def active_users_1_day(self):
        """
        Array of the number of users who have been active in the last day.

        :rtype: list of [Optional[long]]
        """
        if self._active_users_1_day_present:
            return self._active_users_1_day_value
        else:
            raise AttributeError("missing required field 'active_users_1_day'")

    @active_users_1_day.setter
    def active_users_1_day(self, val):
        val = self._active_users_1_day_validator.validate(val)
        self._active_users_1_day_value = val
        self._active_users_1_day_present = True

    @active_users_1_day.deleter
    def active_users_1_day(self):
        self._active_users_1_day_value = None
        self._active_users_1_day_present = False

    @property
    def active_shared_folders_28_day(self):
        """
        Array of the number of shared folders with some activity in the last 28
        days.

        :rtype: list of [Optional[long]]
        """
        if self._active_shared_folders_28_day_present:
            return self._active_shared_folders_28_day_value
        else:
            raise AttributeError("missing required field 'active_shared_folders_28_day'")

    @active_shared_folders_28_day.setter
    def active_shared_folders_28_day(self, val):
        val = self._active_shared_folders_28_day_validator.validate(val)
        self._active_shared_folders_28_day_value = val
        self._active_shared_folders_28_day_present = True

    @active_shared_folders_28_day.deleter
    def active_shared_folders_28_day(self):
        self._active_shared_folders_28_day_value = None
        self._active_shared_folders_28_day_present = False

    @property
    def active_shared_folders_7_day(self):
        """
        Array of the number of shared folders with some activity in the last
        week.

        :rtype: list of [Optional[long]]
        """
        if self._active_shared_folders_7_day_present:
            return self._active_shared_folders_7_day_value
        else:
            raise AttributeError("missing required field 'active_shared_folders_7_day'")

    @active_shared_folders_7_day.setter
    def active_shared_folders_7_day(self, val):
        val = self._active_shared_folders_7_day_validator.validate(val)
        self._active_shared_folders_7_day_value = val
        self._active_shared_folders_7_day_present = True

    @active_shared_folders_7_day.deleter
    def active_shared_folders_7_day(self):
        self._active_shared_folders_7_day_value = None
        self._active_shared_folders_7_day_present = False

    @property
    def active_shared_folders_1_day(self):
        """
        Array of the number of shared folders with some activity in the last
        day.

        :rtype: list of [Optional[long]]
        """
        if self._active_shared_folders_1_day_present:
            return self._active_shared_folders_1_day_value
        else:
            raise AttributeError("missing required field 'active_shared_folders_1_day'")

    @active_shared_folders_1_day.setter
    def active_shared_folders_1_day(self, val):
        val = self._active_shared_folders_1_day_validator.validate(val)
        self._active_shared_folders_1_day_value = val
        self._active_shared_folders_1_day_present = True

    @active_shared_folders_1_day.deleter
    def active_shared_folders_1_day(self):
        self._active_shared_folders_1_day_value = None
        self._active_shared_folders_1_day_present = False

    @property
    def shared_links_created(self):
        """
        Array of the number of shared links created.

        :rtype: list of [Optional[long]]
        """
        if self._shared_links_created_present:
            return self._shared_links_created_value
        else:
            raise AttributeError("missing required field 'shared_links_created'")

    @shared_links_created.setter
    def shared_links_created(self, val):
        val = self._shared_links_created_validator.validate(val)
        self._shared_links_created_value = val
        self._shared_links_created_present = True

    @shared_links_created.deleter
    def shared_links_created(self):
        self._shared_links_created_value = None
        self._shared_links_created_present = False

    @property
    def shared_links_viewed_by_team(self):
        """
        Array of the number of views by team users to shared links created by
        the team.

        :rtype: list of [Optional[long]]
        """
        if self._shared_links_viewed_by_team_present:
            return self._shared_links_viewed_by_team_value
        else:
            raise AttributeError("missing required field 'shared_links_viewed_by_team'")

    @shared_links_viewed_by_team.setter
    def shared_links_viewed_by_team(self, val):
        val = self._shared_links_viewed_by_team_validator.validate(val)
        self._shared_links_viewed_by_team_value = val
        self._shared_links_viewed_by_team_present = True

    @shared_links_viewed_by_team.deleter
    def shared_links_viewed_by_team(self):
        self._shared_links_viewed_by_team_value = None
        self._shared_links_viewed_by_team_present = False

    @property
    def shared_links_viewed_by_outside_user(self):
        """
        Array of the number of views by users outside of the team to shared
        links created by the team.

        :rtype: list of [Optional[long]]
        """
        if self._shared_links_viewed_by_outside_user_present:
            return self._shared_links_viewed_by_outside_user_value
        else:
            raise AttributeError("missing required field 'shared_links_viewed_by_outside_user'")

    @shared_links_viewed_by_outside_user.setter
    def shared_links_viewed_by_outside_user(self, val):
        val = self._shared_links_viewed_by_outside_user_validator.validate(val)
        self._shared_links_viewed_by_outside_user_value = val
        self._shared_links_viewed_by_outside_user_present = True

    @shared_links_viewed_by_outside_user.deleter
    def shared_links_viewed_by_outside_user(self):
        self._shared_links_viewed_by_outside_user_value = None
        self._shared_links_viewed_by_outside_user_present = False

    @property
    def shared_links_viewed_by_not_logged_in(self):
        """
        Array of the number of views by non-logged-in users to shared links
        created by the team.

        :rtype: list of [Optional[long]]
        """
        if self._shared_links_viewed_by_not_logged_in_present:
            return self._shared_links_viewed_by_not_logged_in_value
        else:
            raise AttributeError("missing required field 'shared_links_viewed_by_not_logged_in'")

    @shared_links_viewed_by_not_logged_in.setter
    def shared_links_viewed_by_not_logged_in(self, val):
        val = self._shared_links_viewed_by_not_logged_in_validator.validate(val)
        self._shared_links_viewed_by_not_logged_in_value = val
        self._shared_links_viewed_by_not_logged_in_present = True

    @shared_links_viewed_by_not_logged_in.deleter
    def shared_links_viewed_by_not_logged_in(self):
        self._shared_links_viewed_by_not_logged_in_value = None
        self._shared_links_viewed_by_not_logged_in_present = False

    @property
    def shared_links_viewed_total(self):
        """
        Array of the total number of views to shared links created by the team.

        :rtype: list of [Optional[long]]
        """
        if self._shared_links_viewed_total_present:
            return self._shared_links_viewed_total_value
        else:
            raise AttributeError("missing required field 'shared_links_viewed_total'")

    @shared_links_viewed_total.setter
    def shared_links_viewed_total(self, val):
        val = self._shared_links_viewed_total_validator.validate(val)
        self._shared_links_viewed_total_value = val
        self._shared_links_viewed_total_present = True

    @shared_links_viewed_total.deleter
    def shared_links_viewed_total(self):
        self._shared_links_viewed_total_value = None
        self._shared_links_viewed_total_present = False

    def __repr__(self):
        return 'GetActivityReport(start_date={!r}, adds={!r}, edits={!r}, deletes={!r}, active_users_28_day={!r}, active_users_7_day={!r}, active_users_1_day={!r}, active_shared_folders_28_day={!r}, active_shared_folders_7_day={!r}, active_shared_folders_1_day={!r}, shared_links_created={!r}, shared_links_viewed_by_team={!r}, shared_links_viewed_by_outside_user={!r}, shared_links_viewed_by_not_logged_in={!r}, shared_links_viewed_total={!r})'.format(
            self._start_date_value,
            self._adds_value,
            self._edits_value,
            self._deletes_value,
            self._active_users_28_day_value,
            self._active_users_7_day_value,
            self._active_users_1_day_value,
            self._active_shared_folders_28_day_value,
            self._active_shared_folders_7_day_value,
            self._active_shared_folders_1_day_value,
            self._shared_links_created_value,
            self._shared_links_viewed_by_team_value,
            self._shared_links_viewed_by_outside_user_value,
            self._shared_links_viewed_by_not_logged_in_value,
            self._shared_links_viewed_total_value,
        )

GetActivityReport_validator = bv.Struct(GetActivityReport)

class GetDevicesReport(BaseDfbReport):
    """
    Devices Report Result. Contains subsections for different time ranges of
    activity. Each of the items in each subsection of the storage report is an
    array of values, one value per day. If there is no data for a day, then the
    value will be None.

    :ivar active_1_day: Report of the number of devices active in the last day.
    :ivar active_7_day: Report of the number of devices active in the last 7
        days.
    :ivar active_28_day: Report of the number of devices active in the last 28
        days.
    """

    __slots__ = [
        '_active_1_day_value',
        '_active_1_day_present',
        '_active_7_day_value',
        '_active_7_day_present',
        '_active_28_day_value',
        '_active_28_day_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 start_date=None,
                 active_1_day=None,
                 active_7_day=None,
                 active_28_day=None):
        super(GetDevicesReport, self).__init__(start_date)
        self._active_1_day_value = None
        self._active_1_day_present = False
        self._active_7_day_value = None
        self._active_7_day_present = False
        self._active_28_day_value = None
        self._active_28_day_present = False
        if active_1_day is not None:
            self.active_1_day = active_1_day
        if active_7_day is not None:
            self.active_7_day = active_7_day
        if active_28_day is not None:
            self.active_28_day = active_28_day

    @property
    def active_1_day(self):
        """
        Report of the number of devices active in the last day.

        :rtype: DevicesActive
        """
        if self._active_1_day_present:
            return self._active_1_day_value
        else:
            raise AttributeError("missing required field 'active_1_day'")

    @active_1_day.setter
    def active_1_day(self, val):
        self._active_1_day_validator.validate_type_only(val)
        self._active_1_day_value = val
        self._active_1_day_present = True

    @active_1_day.deleter
    def active_1_day(self):
        self._active_1_day_value = None
        self._active_1_day_present = False

    @property
    def active_7_day(self):
        """
        Report of the number of devices active in the last 7 days.

        :rtype: DevicesActive
        """
        if self._active_7_day_present:
            return self._active_7_day_value
        else:
            raise AttributeError("missing required field 'active_7_day'")

    @active_7_day.setter
    def active_7_day(self, val):
        self._active_7_day_validator.validate_type_only(val)
        self._active_7_day_value = val
        self._active_7_day_present = True

    @active_7_day.deleter
    def active_7_day(self):
        self._active_7_day_value = None
        self._active_7_day_present = False

    @property
    def active_28_day(self):
        """
        Report of the number of devices active in the last 28 days.

        :rtype: DevicesActive
        """
        if self._active_28_day_present:
            return self._active_28_day_value
        else:
            raise AttributeError("missing required field 'active_28_day'")

    @active_28_day.setter
    def active_28_day(self, val):
        self._active_28_day_validator.validate_type_only(val)
        self._active_28_day_value = val
        self._active_28_day_present = True

    @active_28_day.deleter
    def active_28_day(self):
        self._active_28_day_value = None
        self._active_28_day_present = False

    def __repr__(self):
        return 'GetDevicesReport(start_date={!r}, active_1_day={!r}, active_7_day={!r}, active_28_day={!r})'.format(
            self._start_date_value,
            self._active_1_day_value,
            self._active_7_day_value,
            self._active_28_day_value,
        )

GetDevicesReport_validator = bv.Struct(GetDevicesReport)

class GetMembershipReport(BaseDfbReport):
    """
    Membership Report Result. Each of the items in the storage report is an
    array of values, one value per day. If there is no data for a day, then the
    value will be None.

    :ivar team_size: Team size, for each day.
    :ivar pending_invites: The number of pending invites to the team, for each
        day.
    :ivar members_joined: The number of members that joined the team, for each
        day.
    :ivar suspended_members: The number of suspended team members, for each day.
    :ivar licenses: The total number of licenses the team has, for each day.
    """

    __slots__ = [
        '_team_size_value',
        '_team_size_present',
        '_pending_invites_value',
        '_pending_invites_present',
        '_members_joined_value',
        '_members_joined_present',
        '_suspended_members_value',
        '_suspended_members_present',
        '_licenses_value',
        '_licenses_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 start_date=None,
                 team_size=None,
                 pending_invites=None,
                 members_joined=None,
                 suspended_members=None,
                 licenses=None):
        super(GetMembershipReport, self).__init__(start_date)
        self._team_size_value = None
        self._team_size_present = False
        self._pending_invites_value = None
        self._pending_invites_present = False
        self._members_joined_value = None
        self._members_joined_present = False
        self._suspended_members_value = None
        self._suspended_members_present = False
        self._licenses_value = None
        self._licenses_present = False
        if team_size is not None:
            self.team_size = team_size
        if pending_invites is not None:
            self.pending_invites = pending_invites
        if members_joined is not None:
            self.members_joined = members_joined
        if suspended_members is not None:
            self.suspended_members = suspended_members
        if licenses is not None:
            self.licenses = licenses

    @property
    def team_size(self):
        """
        Team size, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._team_size_present:
            return self._team_size_value
        else:
            raise AttributeError("missing required field 'team_size'")

    @team_size.setter
    def team_size(self, val):
        val = self._team_size_validator.validate(val)
        self._team_size_value = val
        self._team_size_present = True

    @team_size.deleter
    def team_size(self):
        self._team_size_value = None
        self._team_size_present = False

    @property
    def pending_invites(self):
        """
        The number of pending invites to the team, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._pending_invites_present:
            return self._pending_invites_value
        else:
            raise AttributeError("missing required field 'pending_invites'")

    @pending_invites.setter
    def pending_invites(self, val):
        val = self._pending_invites_validator.validate(val)
        self._pending_invites_value = val
        self._pending_invites_present = True

    @pending_invites.deleter
    def pending_invites(self):
        self._pending_invites_value = None
        self._pending_invites_present = False

    @property
    def members_joined(self):
        """
        The number of members that joined the team, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._members_joined_present:
            return self._members_joined_value
        else:
            raise AttributeError("missing required field 'members_joined'")

    @members_joined.setter
    def members_joined(self, val):
        val = self._members_joined_validator.validate(val)
        self._members_joined_value = val
        self._members_joined_present = True

    @members_joined.deleter
    def members_joined(self):
        self._members_joined_value = None
        self._members_joined_present = False

    @property
    def suspended_members(self):
        """
        The number of suspended team members, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._suspended_members_present:
            return self._suspended_members_value
        else:
            raise AttributeError("missing required field 'suspended_members'")

    @suspended_members.setter
    def suspended_members(self, val):
        val = self._suspended_members_validator.validate(val)
        self._suspended_members_value = val
        self._suspended_members_present = True

    @suspended_members.deleter
    def suspended_members(self):
        self._suspended_members_value = None
        self._suspended_members_present = False

    @property
    def licenses(self):
        """
        The total number of licenses the team has, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._licenses_present:
            return self._licenses_value
        else:
            raise AttributeError("missing required field 'licenses'")

    @licenses.setter
    def licenses(self, val):
        val = self._licenses_validator.validate(val)
        self._licenses_value = val
        self._licenses_present = True

    @licenses.deleter
    def licenses(self):
        self._licenses_value = None
        self._licenses_present = False

    def __repr__(self):
        return 'GetMembershipReport(start_date={!r}, team_size={!r}, pending_invites={!r}, members_joined={!r}, suspended_members={!r}, licenses={!r})'.format(
            self._start_date_value,
            self._team_size_value,
            self._pending_invites_value,
            self._members_joined_value,
            self._suspended_members_value,
            self._licenses_value,
        )

GetMembershipReport_validator = bv.Struct(GetMembershipReport)

class GetStorageReport(BaseDfbReport):
    """
    Storage Report Result. Each of the items in the storage report is an array
    of values, one value per day. If there is no data for a day, then the value
    will be None.

    :ivar total_usage: Sum of the shared, unshared, and datastore usages, for
        each day.
    :ivar shared_usage: Array of the combined size (bytes) of team members'
        shared folders, for each day.
    :ivar unshared_usage: Array of the combined size (bytes) of team members'
        root namespaces, for each day.
    :ivar shared_folders: Array of the number of shared folders owned by team
        members, for each day.
    :ivar member_storage_map: Array of storage summaries of team members'
        account sizes. Each storage summary is an array of key, value pairs,
        where each pair describes a storage bucket. The key indicates the upper
        bound of the bucket and the value is the number of users in that bucket.
        There is one such summary per day. If there is no data for a day, the
        storage summary will be empty.
    """

    __slots__ = [
        '_total_usage_value',
        '_total_usage_present',
        '_shared_usage_value',
        '_shared_usage_present',
        '_unshared_usage_value',
        '_unshared_usage_present',
        '_shared_folders_value',
        '_shared_folders_present',
        '_member_storage_map_value',
        '_member_storage_map_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 start_date=None,
                 total_usage=None,
                 shared_usage=None,
                 unshared_usage=None,
                 shared_folders=None,
                 member_storage_map=None):
        super(GetStorageReport, self).__init__(start_date)
        self._total_usage_value = None
        self._total_usage_present = False
        self._shared_usage_value = None
        self._shared_usage_present = False
        self._unshared_usage_value = None
        self._unshared_usage_present = False
        self._shared_folders_value = None
        self._shared_folders_present = False
        self._member_storage_map_value = None
        self._member_storage_map_present = False
        if total_usage is not None:
            self.total_usage = total_usage
        if shared_usage is not None:
            self.shared_usage = shared_usage
        if unshared_usage is not None:
            self.unshared_usage = unshared_usage
        if shared_folders is not None:
            self.shared_folders = shared_folders
        if member_storage_map is not None:
            self.member_storage_map = member_storage_map

    @property
    def total_usage(self):
        """
        Sum of the shared, unshared, and datastore usages, for each day.

        :rtype: list of [Optional[long]]
        """
        if self._total_usage_present:
            return self._total_usage_value
        else:
            raise AttributeError("missing required field 'total_usage'")

    @total_usage.setter
    def total_usage(self, val):
        val = self._total_usage_validator.validate(val)
        self._total_usage_value = val
        self._total_usage_present = True

    @total_usage.deleter
    def total_usage(self):
        self._total_usage_value = None
        self._total_usage_present = False

    @property
    def shared_usage(self):
        """
        Array of the combined size (bytes) of team members' shared folders, for
        each day.

        :rtype: list of [Optional[long]]
        """
        if self._shared_usage_present:
            return self._shared_usage_value
        else:
            raise AttributeError("missing required field 'shared_usage'")

    @shared_usage.setter
    def shared_usage(self, val):
        val = self._shared_usage_validator.validate(val)
        self._shared_usage_value = val
        self._shared_usage_present = True

    @shared_usage.deleter
    def shared_usage(self):
        self._shared_usage_value = None
        self._shared_usage_present = False

    @property
    def unshared_usage(self):
        """
        Array of the combined size (bytes) of team members' root namespaces, for
        each day.

        :rtype: list of [Optional[long]]
        """
        if self._unshared_usage_present:
            return self._unshared_usage_value
        else:
            raise AttributeError("missing required field 'unshared_usage'")

    @unshared_usage.setter
    def unshared_usage(self, val):
        val = self._unshared_usage_validator.validate(val)
        self._unshared_usage_value = val
        self._unshared_usage_present = True

    @unshared_usage.deleter
    def unshared_usage(self):
        self._unshared_usage_value = None
        self._unshared_usage_present = False

    @property
    def shared_folders(self):
        """
        Array of the number of shared folders owned by team members, for each
        day.

        :rtype: list of [Optional[long]]
        """
        if self._shared_folders_present:
            return self._shared_folders_value
        else:
            raise AttributeError("missing required field 'shared_folders'")

    @shared_folders.setter
    def shared_folders(self, val):
        val = self._shared_folders_validator.validate(val)
        self._shared_folders_value = val
        self._shared_folders_present = True

    @shared_folders.deleter
    def shared_folders(self):
        self._shared_folders_value = None
        self._shared_folders_present = False

    @property
    def member_storage_map(self):
        """
        Array of storage summaries of team members' account sizes. Each storage
        summary is an array of key, value pairs, where each pair describes a
        storage bucket. The key indicates the upper bound of the bucket and the
        value is the number of users in that bucket. There is one such summary
        per day. If there is no data for a day, the storage summary will be
        empty.

        :rtype: list of [list of [StorageBucket]]
        """
        if self._member_storage_map_present:
            return self._member_storage_map_value
        else:
            raise AttributeError("missing required field 'member_storage_map'")

    @member_storage_map.setter
    def member_storage_map(self, val):
        val = self._member_storage_map_validator.validate(val)
        self._member_storage_map_value = val
        self._member_storage_map_present = True

    @member_storage_map.deleter
    def member_storage_map(self):
        self._member_storage_map_value = None
        self._member_storage_map_present = False

    def __repr__(self):
        return 'GetStorageReport(start_date={!r}, total_usage={!r}, shared_usage={!r}, unshared_usage={!r}, shared_folders={!r}, member_storage_map={!r})'.format(
            self._start_date_value,
            self._total_usage_value,
            self._shared_usage_value,
            self._unshared_usage_value,
            self._shared_folders_value,
            self._member_storage_map_value,
        )

GetStorageReport_validator = bv.Struct(GetStorageReport)

class GroupAccessType(bb.Union):
    """
    Role of a user in group.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar member: User is a member of the group, but has no special permissions.
    :ivar owner: User can rename the group, and add/remove members.
    """

    _catch_all = None
    # Attribute is overwritten below the class definition
    member = None
    # Attribute is overwritten below the class definition
    owner = None

    def is_member(self):
        """
        Check if the union tag is ``member``.

        :rtype: bool
        """
        return self._tag == 'member'

    def is_owner(self):
        """
        Check if the union tag is ``owner``.

        :rtype: bool
        """
        return self._tag == 'owner'

    def __repr__(self):
        return 'GroupAccessType(%r, %r)' % (self._tag, self._value)

GroupAccessType_validator = bv.Union(GroupAccessType)

class GroupCreateArg(object):
    """
    :ivar group_name: Group name.
    :ivar group_external_id: The creator of a team can associate an arbitrary
        external ID to the group.
    :ivar group_management_type: Whether the team can be managed by selected
        users, or only by team admins.
    """

    __slots__ = [
        '_group_name_value',
        '_group_name_present',
        '_group_external_id_value',
        '_group_external_id_present',
        '_group_management_type_value',
        '_group_management_type_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 group_name=None,
                 group_external_id=None,
                 group_management_type=None):
        self._group_name_value = None
        self._group_name_present = False
        self._group_external_id_value = None
        self._group_external_id_present = False
        self._group_management_type_value = None
        self._group_management_type_present = False
        if group_name is not None:
            self.group_name = group_name
        if group_external_id is not None:
            self.group_external_id = group_external_id
        if group_management_type is not None:
            self.group_management_type = group_management_type

    @property
    def group_name(self):
        """
        Group name.

        :rtype: str
        """
        if self._group_name_present:
            return self._group_name_value
        else:
            raise AttributeError("missing required field 'group_name'")

    @group_name.setter
    def group_name(self, val):
        val = self._group_name_validator.validate(val)
        self._group_name_value = val
        self._group_name_present = True

    @group_name.deleter
    def group_name(self):
        self._group_name_value = None
        self._group_name_present = False

    @property
    def group_external_id(self):
        """
        The creator of a team can associate an arbitrary external ID to the
        group.

        :rtype: str
        """
        if self._group_external_id_present:
            return self._group_external_id_value
        else:
            return None

    @group_external_id.setter
    def group_external_id(self, val):
        if val is None:
            del self.group_external_id
            return
        val = self._group_external_id_validator.validate(val)
        self._group_external_id_value = val
        self._group_external_id_present = True

    @group_external_id.deleter
    def group_external_id(self):
        self._group_external_id_value = None
        self._group_external_id_present = False

    @property
    def group_management_type(self):
        """
        Whether the team can be managed by selected users, or only by team
        admins.

        :rtype: team_common.GroupManagementType_validator
        """
        if self._group_management_type_present:
            return self._group_management_type_value
        else:
            return None

    @group_management_type.setter
    def group_management_type(self, val):
        if val is None:
            del self.group_management_type
            return
        self._group_management_type_validator.validate_type_only(val)
        self._group_management_type_value = val
        self._group_management_type_present = True

    @group_management_type.deleter
    def group_management_type(self):
        self._group_management_type_value = None
        self._group_management_type_present = False

    def __repr__(self):
        return 'GroupCreateArg(group_name={!r}, group_external_id={!r}, group_management_type={!r})'.format(
            self._group_name_value,
            self._group_external_id_value,
            self._group_management_type_value,
        )

GroupCreateArg_validator = bv.Struct(GroupCreateArg)

class GroupCreateError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar group_name_already_used: The requested group name is already being
        used by another group.
    :ivar group_name_invalid: Group name is empty or has invalid characters.
    :ivar external_id_already_in_use: The requested external ID is already being
        used by another group.
    :ivar system_managed_group_disallowed: System-managed group cannot be
        manually created.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    group_name_already_used = None
    # Attribute is overwritten below the class definition
    group_name_invalid = None
    # Attribute is overwritten below the class definition
    external_id_already_in_use = None
    # Attribute is overwritten below the class definition
    system_managed_group_disallowed = None
    # Attribute is overwritten below the class definition
    other = None

    def is_group_name_already_used(self):
        """
        Check if the union tag is ``group_name_already_used``.

        :rtype: bool
        """
        return self._tag == 'group_name_already_used'

    def is_group_name_invalid(self):
        """
        Check if the union tag is ``group_name_invalid``.

        :rtype: bool
        """
        return self._tag == 'group_name_invalid'

    def is_external_id_already_in_use(self):
        """
        Check if the union tag is ``external_id_already_in_use``.

        :rtype: bool
        """
        return self._tag == 'external_id_already_in_use'

    def is_system_managed_group_disallowed(self):
        """
        Check if the union tag is ``system_managed_group_disallowed``.

        :rtype: bool
        """
        return self._tag == 'system_managed_group_disallowed'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'GroupCreateError(%r, %r)' % (self._tag, self._value)

GroupCreateError_validator = bv.Union(GroupCreateError)

class GroupSelectorError(bb.Union):
    """
    Error that can be raised when :class:`GroupSelector` is used.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar group_not_found: No matching group found. No groups match the
        specified group ID.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    group_not_found = None
    # Attribute is overwritten below the class definition
    other = None

    def is_group_not_found(self):
        """
        Check if the union tag is ``group_not_found``.

        :rtype: bool
        """
        return self._tag == 'group_not_found'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'GroupSelectorError(%r, %r)' % (self._tag, self._value)

GroupSelectorError_validator = bv.Union(GroupSelectorError)

class GroupSelectorWithTeamGroupError(GroupSelectorError):
    """
    Error that can be raised when :class:`GroupSelector` is used and team groups
    are disallowed from being used.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar system_managed_group_disallowed: This operation is not supported on
        system-managed groups.
    """

    # Attribute is overwritten below the class definition
    system_managed_group_disallowed = None

    def is_system_managed_group_disallowed(self):
        """
        Check if the union tag is ``system_managed_group_disallowed``.

        :rtype: bool
        """
        return self._tag == 'system_managed_group_disallowed'

    def __repr__(self):
        return 'GroupSelectorWithTeamGroupError(%r, %r)' % (self._tag, self._value)

GroupSelectorWithTeamGroupError_validator = bv.Union(GroupSelectorWithTeamGroupError)

class GroupDeleteError(GroupSelectorWithTeamGroupError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar group_already_deleted: This group has already been deleted.
    """

    # Attribute is overwritten below the class definition
    group_already_deleted = None

    def is_group_already_deleted(self):
        """
        Check if the union tag is ``group_already_deleted``.

        :rtype: bool
        """
        return self._tag == 'group_already_deleted'

    def __repr__(self):
        return 'GroupDeleteError(%r, %r)' % (self._tag, self._value)

GroupDeleteError_validator = bv.Union(GroupDeleteError)

class GroupFullInfo(team_common.GroupSummary):
    """
    Full description of a group.

    :ivar members: List of group members.
    :ivar created: The group creation time as a UTC timestamp in milliseconds
        since the Unix epoch.
    """

    __slots__ = [
        '_members_value',
        '_members_present',
        '_created_value',
        '_created_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 group_name=None,
                 group_id=None,
                 group_management_type=None,
                 created=None,
                 group_external_id=None,
                 member_count=None,
                 members=None):
        super(GroupFullInfo, self).__init__(group_name,
                                            group_id,
                                            group_management_type,
                                            group_external_id,
                                            member_count)
        self._members_value = None
        self._members_present = False
        self._created_value = None
        self._created_present = False
        if members is not None:
            self.members = members
        if created is not None:
            self.created = created

    @property
    def members(self):
        """
        List of group members.

        :rtype: list of [GroupMemberInfo]
        """
        if self._members_present:
            return self._members_value
        else:
            return None

    @members.setter
    def members(self, val):
        if val is None:
            del self.members
            return
        val = self._members_validator.validate(val)
        self._members_value = val
        self._members_present = True

    @members.deleter
    def members(self):
        self._members_value = None
        self._members_present = False

    @property
    def created(self):
        """
        The group creation time as a UTC timestamp in milliseconds since the
        Unix epoch.

        :rtype: long
        """
        if self._created_present:
            return self._created_value
        else:
            raise AttributeError("missing required field 'created'")

    @created.setter
    def created(self, val):
        val = self._created_validator.validate(val)
        self._created_value = val
        self._created_present = True

    @created.deleter
    def created(self):
        self._created_value = None
        self._created_present = False

    def __repr__(self):
        return 'GroupFullInfo(group_name={!r}, group_id={!r}, group_management_type={!r}, created={!r}, group_external_id={!r}, member_count={!r}, members={!r})'.format(
            self._group_name_value,
            self._group_id_value,
            self._group_management_type_value,
            self._created_value,
            self._group_external_id_value,
            self._member_count_value,
            self._members_value,
        )

GroupFullInfo_validator = bv.Struct(GroupFullInfo)

class GroupMemberInfo(object):
    """
    Profile of group member, and role in group.

    :ivar profile: Profile of group member.
    :ivar access_type: The role that the user has in the group.
    """

    __slots__ = [
        '_profile_value',
        '_profile_present',
        '_access_type_value',
        '_access_type_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 profile=None,
                 access_type=None):
        self._profile_value = None
        self._profile_present = False
        self._access_type_value = None
        self._access_type_present = False
        if profile is not None:
            self.profile = profile
        if access_type is not None:
            self.access_type = access_type

    @property
    def profile(self):
        """
        Profile of group member.

        :rtype: MemberProfile
        """
        if self._profile_present:
            return self._profile_value
        else:
            raise AttributeError("missing required field 'profile'")

    @profile.setter
    def profile(self, val):
        self._profile_validator.validate_type_only(val)
        self._profile_value = val
        self._profile_present = True

    @profile.deleter
    def profile(self):
        self._profile_value = None
        self._profile_present = False

    @property
    def access_type(self):
        """
        The role that the user has in the group.

        :rtype: GroupAccessType
        """
        if self._access_type_present:
            return self._access_type_value
        else:
            raise AttributeError("missing required field 'access_type'")

    @access_type.setter
    def access_type(self, val):
        self._access_type_validator.validate_type_only(val)
        self._access_type_value = val
        self._access_type_present = True

    @access_type.deleter
    def access_type(self):
        self._access_type_value = None
        self._access_type_present = False

    def __repr__(self):
        return 'GroupMemberInfo(profile={!r}, access_type={!r})'.format(
            self._profile_value,
            self._access_type_value,
        )

GroupMemberInfo_validator = bv.Struct(GroupMemberInfo)

class GroupMemberSelector(object):
    """
    Argument for selecting a group and a single user.

    :ivar group: Specify a group.
    :ivar user: Identity of a user that is a member of ``group``.
    """

    __slots__ = [
        '_group_value',
        '_group_present',
        '_user_value',
        '_user_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 group=None,
                 user=None):
        self._group_value = None
        self._group_present = False
        self._user_value = None
        self._user_present = False
        if group is not None:
            self.group = group
        if user is not None:
            self.user = user

    @property
    def group(self):
        """
        Specify a group.

        :rtype: GroupSelector
        """
        if self._group_present:
            return self._group_value
        else:
            raise AttributeError("missing required field 'group'")

    @group.setter
    def group(self, val):
        self._group_validator.validate_type_only(val)
        self._group_value = val
        self._group_present = True

    @group.deleter
    def group(self):
        self._group_value = None
        self._group_present = False

    @property
    def user(self):
        """
        Identity of a user that is a member of ``group``.

        :rtype: UserSelectorArg
        """
        if self._user_present:
            return self._user_value
        else:
            raise AttributeError("missing required field 'user'")

    @user.setter
    def user(self, val):
        self._user_validator.validate_type_only(val)
        self._user_value = val
        self._user_present = True

    @user.deleter
    def user(self):
        self._user_value = None
        self._user_present = False

    def __repr__(self):
        return 'GroupMemberSelector(group={!r}, user={!r})'.format(
            self._group_value,
            self._user_value,
        )

GroupMemberSelector_validator = bv.Struct(GroupMemberSelector)

class GroupMemberSelectorError(GroupSelectorWithTeamGroupError):
    """
    Error that can be raised when :class:`GroupMemberSelector` is used, and the
    user is required to be a member of the specified group.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar member_not_in_group: The specified user is not a member of this group.
    """

    # Attribute is overwritten below the class definition
    member_not_in_group = None

    def is_member_not_in_group(self):
        """
        Check if the union tag is ``member_not_in_group``.

        :rtype: bool
        """
        return self._tag == 'member_not_in_group'

    def __repr__(self):
        return 'GroupMemberSelectorError(%r, %r)' % (self._tag, self._value)

GroupMemberSelectorError_validator = bv.Union(GroupMemberSelectorError)

class GroupMemberSetAccessTypeError(GroupMemberSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar user_cannot_be_manager_of_company_managed_group: A company managed
        group cannot be managed by a user.
    """

    # Attribute is overwritten below the class definition
    user_cannot_be_manager_of_company_managed_group = None

    def is_user_cannot_be_manager_of_company_managed_group(self):
        """
        Check if the union tag is ``user_cannot_be_manager_of_company_managed_group``.

        :rtype: bool
        """
        return self._tag == 'user_cannot_be_manager_of_company_managed_group'

    def __repr__(self):
        return 'GroupMemberSetAccessTypeError(%r, %r)' % (self._tag, self._value)

GroupMemberSetAccessTypeError_validator = bv.Union(GroupMemberSetAccessTypeError)

class IncludeMembersArg(object):
    """
    :ivar return_members: Whether to return the list of members in the group.
        Note that the default value will cause all the group members  to be
        returned in the response. This may take a long time for large groups.
    """

    __slots__ = [
        '_return_members_value',
        '_return_members_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 return_members=None):
        self._return_members_value = None
        self._return_members_present = False
        if return_members is not None:
            self.return_members = return_members

    @property
    def return_members(self):
        """
        Whether to return the list of members in the group.  Note that the
        default value will cause all the group members  to be returned in the
        response. This may take a long time for large groups.

        :rtype: bool
        """
        if self._return_members_present:
            return self._return_members_value
        else:
            return True

    @return_members.setter
    def return_members(self, val):
        val = self._return_members_validator.validate(val)
        self._return_members_value = val
        self._return_members_present = True

    @return_members.deleter
    def return_members(self):
        self._return_members_value = None
        self._return_members_present = False

    def __repr__(self):
        return 'IncludeMembersArg(return_members={!r})'.format(
            self._return_members_value,
        )

IncludeMembersArg_validator = bv.Struct(IncludeMembersArg)

class GroupMembersAddArg(IncludeMembersArg):
    """
    :ivar group: Group to which users will be added.
    :ivar members: List of users to be added to the group.
    """

    __slots__ = [
        '_group_value',
        '_group_present',
        '_members_value',
        '_members_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 group=None,
                 members=None,
                 return_members=None):
        super(GroupMembersAddArg, self).__init__(return_members)
        self._group_value = None
        self._group_present = False
        self._members_value = None
        self._members_present = False
        if group is not None:
            self.group = group
        if members is not None:
            self.members = members

    @property
    def group(self):
        """
        Group to which users will be added.

        :rtype: GroupSelector
        """
        if self._group_present:
            return self._group_value
        else:
            raise AttributeError("missing required field 'group'")

    @group.setter
    def group(self, val):
        self._group_validator.validate_type_only(val)
        self._group_value = val
        self._group_present = True

    @group.deleter
    def group(self):
        self._group_value = None
        self._group_present = False

    @property
    def members(self):
        """
        List of users to be added to the group.

        :rtype: list of [MemberAccess]
        """
        if self._members_present:
            return self._members_value
        else:
            raise AttributeError("missing required field 'members'")

    @members.setter
    def members(self, val):
        val = self._members_validator.validate(val)
        self._members_value = val
        self._members_present = True

    @members.deleter
    def members(self):
        self._members_value = None
        self._members_present = False

    def __repr__(self):
        return 'GroupMembersAddArg(group={!r}, members={!r}, return_members={!r})'.format(
            self._group_value,
            self._members_value,
            self._return_members_value,
        )

GroupMembersAddArg_validator = bv.Struct(GroupMembersAddArg)

class GroupMembersAddError(GroupSelectorWithTeamGroupError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar duplicate_user: You cannot add duplicate users. One or more of the
        members you are trying to add is already a member of the group.
    :ivar group_not_in_team: Group is not in this team. You cannot add members
        to a group that is outside of your team.
    :ivar list of [str] members_not_in_team: These members are not part of your
        team. Currently, you cannot add members to a group if they are not part
        of your team, though this may change in a subsequent version. To add new
        members to your Dropbox Business team, use the :route:`members/add`
        endpoint.
    :ivar list of [str] users_not_found: These users were not found in Dropbox.
    :ivar user_must_be_active_to_be_owner: A suspended user cannot be added to a
        group as ``GroupAccessType.owner``.
    :ivar list of [str] user_cannot_be_manager_of_company_managed_group: A
        company-managed group cannot be managed by a user.
    """

    # Attribute is overwritten below the class definition
    duplicate_user = None
    # Attribute is overwritten below the class definition
    group_not_in_team = None
    # Attribute is overwritten below the class definition
    user_must_be_active_to_be_owner = None

    @classmethod
    def members_not_in_team(cls, val):
        """
        Create an instance of this class set to the ``members_not_in_team`` tag
        with value ``val``.

        :param list of [str] val:
        :rtype: GroupMembersAddError
        """
        return cls('members_not_in_team', val)

    @classmethod
    def users_not_found(cls, val):
        """
        Create an instance of this class set to the ``users_not_found`` tag with
        value ``val``.

        :param list of [str] val:
        :rtype: GroupMembersAddError
        """
        return cls('users_not_found', val)

    @classmethod
    def user_cannot_be_manager_of_company_managed_group(cls, val):
        """
        Create an instance of this class set to the
        ``user_cannot_be_manager_of_company_managed_group`` tag with value
        ``val``.

        :param list of [str] val:
        :rtype: GroupMembersAddError
        """
        return cls('user_cannot_be_manager_of_company_managed_group', val)

    def is_duplicate_user(self):
        """
        Check if the union tag is ``duplicate_user``.

        :rtype: bool
        """
        return self._tag == 'duplicate_user'

    def is_group_not_in_team(self):
        """
        Check if the union tag is ``group_not_in_team``.

        :rtype: bool
        """
        return self._tag == 'group_not_in_team'

    def is_members_not_in_team(self):
        """
        Check if the union tag is ``members_not_in_team``.

        :rtype: bool
        """
        return self._tag == 'members_not_in_team'

    def is_users_not_found(self):
        """
        Check if the union tag is ``users_not_found``.

        :rtype: bool
        """
        return self._tag == 'users_not_found'

    def is_user_must_be_active_to_be_owner(self):
        """
        Check if the union tag is ``user_must_be_active_to_be_owner``.

        :rtype: bool
        """
        return self._tag == 'user_must_be_active_to_be_owner'

    def is_user_cannot_be_manager_of_company_managed_group(self):
        """
        Check if the union tag is ``user_cannot_be_manager_of_company_managed_group``.

        :rtype: bool
        """
        return self._tag == 'user_cannot_be_manager_of_company_managed_group'

    def get_members_not_in_team(self):
        """
        These members are not part of your team. Currently, you cannot add
        members to a group if they are not part of your team, though this may
        change in a subsequent version. To add new members to your Dropbox
        Business team, use the :meth:`dropbox.dropbox.Dropbox.team_members_add`
        endpoint.

        Only call this if :meth:`is_members_not_in_team` is true.

        :rtype: list of [str]
        """
        if not self.is_members_not_in_team():
            raise AttributeError("tag 'members_not_in_team' not set")
        return self._value

    def get_users_not_found(self):
        """
        These users were not found in Dropbox.

        Only call this if :meth:`is_users_not_found` is true.

        :rtype: list of [str]
        """
        if not self.is_users_not_found():
            raise AttributeError("tag 'users_not_found' not set")
        return self._value

    def get_user_cannot_be_manager_of_company_managed_group(self):
        """
        A company-managed group cannot be managed by a user.

        Only call this if :meth:`is_user_cannot_be_manager_of_company_managed_group` is true.

        :rtype: list of [str]
        """
        if not self.is_user_cannot_be_manager_of_company_managed_group():
            raise AttributeError("tag 'user_cannot_be_manager_of_company_managed_group' not set")
        return self._value

    def __repr__(self):
        return 'GroupMembersAddError(%r, %r)' % (self._tag, self._value)

GroupMembersAddError_validator = bv.Union(GroupMembersAddError)

class GroupMembersChangeResult(object):
    """
    Result returned by :meth:`dropbox.dropbox.Dropbox.team_groups_members_add`
    and :meth:`dropbox.dropbox.Dropbox.team_groups_members_remove`.

    :ivar group_info: The group info after member change operation has been
        performed.
    :ivar async_job_id: An ID that can be used to obtain the status of
        granting/revoking group-owned resources.
    """

    __slots__ = [
        '_group_info_value',
        '_group_info_present',
        '_async_job_id_value',
        '_async_job_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 group_info=None,
                 async_job_id=None):
        self._group_info_value = None
        self._group_info_present = False
        self._async_job_id_value = None
        self._async_job_id_present = False
        if group_info is not None:
            self.group_info = group_info
        if async_job_id is not None:
            self.async_job_id = async_job_id

    @property
    def group_info(self):
        """
        The group info after member change operation has been performed.

        :rtype: GroupFullInfo
        """
        if self._group_info_present:
            return self._group_info_value
        else:
            raise AttributeError("missing required field 'group_info'")

    @group_info.setter
    def group_info(self, val):
        self._group_info_validator.validate_type_only(val)
        self._group_info_value = val
        self._group_info_present = True

    @group_info.deleter
    def group_info(self):
        self._group_info_value = None
        self._group_info_present = False

    @property
    def async_job_id(self):
        """
        An ID that can be used to obtain the status of granting/revoking
        group-owned resources.

        :rtype: str
        """
        if self._async_job_id_present:
            return self._async_job_id_value
        else:
            raise AttributeError("missing required field 'async_job_id'")

    @async_job_id.setter
    def async_job_id(self, val):
        val = self._async_job_id_validator.validate(val)
        self._async_job_id_value = val
        self._async_job_id_present = True

    @async_job_id.deleter
    def async_job_id(self):
        self._async_job_id_value = None
        self._async_job_id_present = False

    def __repr__(self):
        return 'GroupMembersChangeResult(group_info={!r}, async_job_id={!r})'.format(
            self._group_info_value,
            self._async_job_id_value,
        )

GroupMembersChangeResult_validator = bv.Struct(GroupMembersChangeResult)

class GroupMembersRemoveArg(IncludeMembersArg):
    """
    :ivar group: Group from which users will be removed.
    :ivar users: List of users to be removed from the group.
    """

    __slots__ = [
        '_group_value',
        '_group_present',
        '_users_value',
        '_users_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 group=None,
                 users=None,
                 return_members=None):
        super(GroupMembersRemoveArg, self).__init__(return_members)
        self._group_value = None
        self._group_present = False
        self._users_value = None
        self._users_present = False
        if group is not None:
            self.group = group
        if users is not None:
            self.users = users

    @property
    def group(self):
        """
        Group from which users will be removed.

        :rtype: GroupSelector
        """
        if self._group_present:
            return self._group_value
        else:
            raise AttributeError("missing required field 'group'")

    @group.setter
    def group(self, val):
        self._group_validator.validate_type_only(val)
        self._group_value = val
        self._group_present = True

    @group.deleter
    def group(self):
        self._group_value = None
        self._group_present = False

    @property
    def users(self):
        """
        List of users to be removed from the group.

        :rtype: list of [UserSelectorArg]
        """
        if self._users_present:
            return self._users_value
        else:
            raise AttributeError("missing required field 'users'")

    @users.setter
    def users(self, val):
        val = self._users_validator.validate(val)
        self._users_value = val
        self._users_present = True

    @users.deleter
    def users(self):
        self._users_value = None
        self._users_present = False

    def __repr__(self):
        return 'GroupMembersRemoveArg(group={!r}, users={!r}, return_members={!r})'.format(
            self._group_value,
            self._users_value,
            self._return_members_value,
        )

GroupMembersRemoveArg_validator = bv.Struct(GroupMembersRemoveArg)

class GroupMembersSelectorError(GroupSelectorWithTeamGroupError):
    """
    Error that can be raised when :class:`GroupMembersSelector` is used, and the
    users are required to be members of the specified group.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar member_not_in_group: At least one of the specified users is not a
        member of the group.
    """

    # Attribute is overwritten below the class definition
    member_not_in_group = None

    def is_member_not_in_group(self):
        """
        Check if the union tag is ``member_not_in_group``.

        :rtype: bool
        """
        return self._tag == 'member_not_in_group'

    def __repr__(self):
        return 'GroupMembersSelectorError(%r, %r)' % (self._tag, self._value)

GroupMembersSelectorError_validator = bv.Union(GroupMembersSelectorError)

class GroupMembersRemoveError(GroupMembersSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar group_not_in_team: Group is not in this team. You cannot remove
        members from a group that is outside of your team.
    :ivar list of [str] members_not_in_team: These members are not part of your
        team.
    :ivar list of [str] users_not_found: These users were not found in Dropbox.
    """

    # Attribute is overwritten below the class definition
    group_not_in_team = None

    @classmethod
    def members_not_in_team(cls, val):
        """
        Create an instance of this class set to the ``members_not_in_team`` tag
        with value ``val``.

        :param list of [str] val:
        :rtype: GroupMembersRemoveError
        """
        return cls('members_not_in_team', val)

    @classmethod
    def users_not_found(cls, val):
        """
        Create an instance of this class set to the ``users_not_found`` tag with
        value ``val``.

        :param list of [str] val:
        :rtype: GroupMembersRemoveError
        """
        return cls('users_not_found', val)

    def is_group_not_in_team(self):
        """
        Check if the union tag is ``group_not_in_team``.

        :rtype: bool
        """
        return self._tag == 'group_not_in_team'

    def is_members_not_in_team(self):
        """
        Check if the union tag is ``members_not_in_team``.

        :rtype: bool
        """
        return self._tag == 'members_not_in_team'

    def is_users_not_found(self):
        """
        Check if the union tag is ``users_not_found``.

        :rtype: bool
        """
        return self._tag == 'users_not_found'

    def get_members_not_in_team(self):
        """
        These members are not part of your team.

        Only call this if :meth:`is_members_not_in_team` is true.

        :rtype: list of [str]
        """
        if not self.is_members_not_in_team():
            raise AttributeError("tag 'members_not_in_team' not set")
        return self._value

    def get_users_not_found(self):
        """
        These users were not found in Dropbox.

        Only call this if :meth:`is_users_not_found` is true.

        :rtype: list of [str]
        """
        if not self.is_users_not_found():
            raise AttributeError("tag 'users_not_found' not set")
        return self._value

    def __repr__(self):
        return 'GroupMembersRemoveError(%r, %r)' % (self._tag, self._value)

GroupMembersRemoveError_validator = bv.Union(GroupMembersRemoveError)

class GroupMembersSelector(object):
    """
    Argument for selecting a group and a list of users.

    :ivar group: Specify a group.
    :ivar users: A list of users that are members of ``group``.
    """

    __slots__ = [
        '_group_value',
        '_group_present',
        '_users_value',
        '_users_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 group=None,
                 users=None):
        self._group_value = None
        self._group_present = False
        self._users_value = None
        self._users_present = False
        if group is not None:
            self.group = group
        if users is not None:
            self.users = users

    @property
    def group(self):
        """
        Specify a group.

        :rtype: GroupSelector
        """
        if self._group_present:
            return self._group_value
        else:
            raise AttributeError("missing required field 'group'")

    @group.setter
    def group(self, val):
        self._group_validator.validate_type_only(val)
        self._group_value = val
        self._group_present = True

    @group.deleter
    def group(self):
        self._group_value = None
        self._group_present = False

    @property
    def users(self):
        """
        A list of users that are members of ``group``.

        :rtype: UsersSelectorArg
        """
        if self._users_present:
            return self._users_value
        else:
            raise AttributeError("missing required field 'users'")

    @users.setter
    def users(self, val):
        self._users_validator.validate_type_only(val)
        self._users_value = val
        self._users_present = True

    @users.deleter
    def users(self):
        self._users_value = None
        self._users_present = False

    def __repr__(self):
        return 'GroupMembersSelector(group={!r}, users={!r})'.format(
            self._group_value,
            self._users_value,
        )

GroupMembersSelector_validator = bv.Struct(GroupMembersSelector)

class GroupMembersSetAccessTypeArg(GroupMemberSelector):
    """
    :ivar access_type: New group access type the user will have.
    :ivar return_members: Whether to return the list of members in the group.
        Note that the default value will cause all the group members  to be
        returned in the response. This may take a long time for large groups.
    """

    __slots__ = [
        '_access_type_value',
        '_access_type_present',
        '_return_members_value',
        '_return_members_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 group=None,
                 user=None,
                 access_type=None,
                 return_members=None):
        super(GroupMembersSetAccessTypeArg, self).__init__(group,
                                                           user)
        self._access_type_value = None
        self._access_type_present = False
        self._return_members_value = None
        self._return_members_present = False
        if access_type is not None:
            self.access_type = access_type
        if return_members is not None:
            self.return_members = return_members

    @property
    def access_type(self):
        """
        New group access type the user will have.

        :rtype: GroupAccessType
        """
        if self._access_type_present:
            return self._access_type_value
        else:
            raise AttributeError("missing required field 'access_type'")

    @access_type.setter
    def access_type(self, val):
        self._access_type_validator.validate_type_only(val)
        self._access_type_value = val
        self._access_type_present = True

    @access_type.deleter
    def access_type(self):
        self._access_type_value = None
        self._access_type_present = False

    @property
    def return_members(self):
        """
        Whether to return the list of members in the group.  Note that the
        default value will cause all the group members  to be returned in the
        response. This may take a long time for large groups.

        :rtype: bool
        """
        if self._return_members_present:
            return self._return_members_value
        else:
            return True

    @return_members.setter
    def return_members(self, val):
        val = self._return_members_validator.validate(val)
        self._return_members_value = val
        self._return_members_present = True

    @return_members.deleter
    def return_members(self):
        self._return_members_value = None
        self._return_members_present = False

    def __repr__(self):
        return 'GroupMembersSetAccessTypeArg(group={!r}, user={!r}, access_type={!r}, return_members={!r})'.format(
            self._group_value,
            self._user_value,
            self._access_type_value,
            self._return_members_value,
        )

GroupMembersSetAccessTypeArg_validator = bv.Struct(GroupMembersSetAccessTypeArg)

class GroupSelector(bb.Union):
    """
    Argument for selecting a single group, either by group_id or by external
    group ID.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str group_id: Group ID.
    :ivar str group_external_id: External ID of the group.
    """

    _catch_all = None

    @classmethod
    def group_id(cls, val):
        """
        Create an instance of this class set to the ``group_id`` tag with value
        ``val``.

        :param str val:
        :rtype: GroupSelector
        """
        return cls('group_id', val)

    @classmethod
    def group_external_id(cls, val):
        """
        Create an instance of this class set to the ``group_external_id`` tag
        with value ``val``.

        :param str val:
        :rtype: GroupSelector
        """
        return cls('group_external_id', val)

    def is_group_id(self):
        """
        Check if the union tag is ``group_id``.

        :rtype: bool
        """
        return self._tag == 'group_id'

    def is_group_external_id(self):
        """
        Check if the union tag is ``group_external_id``.

        :rtype: bool
        """
        return self._tag == 'group_external_id'

    def get_group_id(self):
        """
        Group ID.

        Only call this if :meth:`is_group_id` is true.

        :rtype: str
        """
        if not self.is_group_id():
            raise AttributeError("tag 'group_id' not set")
        return self._value

    def get_group_external_id(self):
        """
        External ID of the group.

        Only call this if :meth:`is_group_external_id` is true.

        :rtype: str
        """
        if not self.is_group_external_id():
            raise AttributeError("tag 'group_external_id' not set")
        return self._value

    def __repr__(self):
        return 'GroupSelector(%r, %r)' % (self._tag, self._value)

GroupSelector_validator = bv.Union(GroupSelector)

class GroupUpdateArgs(IncludeMembersArg):
    """
    :ivar group: Specify a group.
    :ivar new_group_name: Optional argument. Set group name to this if provided.
    :ivar new_group_external_id: Optional argument. New group external ID. If
        the argument is None, the group's external_id won't be updated. If the
        argument is empty string, the group's external id will be cleared.
    :ivar new_group_management_type: Set new group management type, if provided.
    """

    __slots__ = [
        '_group_value',
        '_group_present',
        '_new_group_name_value',
        '_new_group_name_present',
        '_new_group_external_id_value',
        '_new_group_external_id_present',
        '_new_group_management_type_value',
        '_new_group_management_type_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 group=None,
                 return_members=None,
                 new_group_name=None,
                 new_group_external_id=None,
                 new_group_management_type=None):
        super(GroupUpdateArgs, self).__init__(return_members)
        self._group_value = None
        self._group_present = False
        self._new_group_name_value = None
        self._new_group_name_present = False
        self._new_group_external_id_value = None
        self._new_group_external_id_present = False
        self._new_group_management_type_value = None
        self._new_group_management_type_present = False
        if group is not None:
            self.group = group
        if new_group_name is not None:
            self.new_group_name = new_group_name
        if new_group_external_id is not None:
            self.new_group_external_id = new_group_external_id
        if new_group_management_type is not None:
            self.new_group_management_type = new_group_management_type

    @property
    def group(self):
        """
        Specify a group.

        :rtype: GroupSelector
        """
        if self._group_present:
            return self._group_value
        else:
            raise AttributeError("missing required field 'group'")

    @group.setter
    def group(self, val):
        self._group_validator.validate_type_only(val)
        self._group_value = val
        self._group_present = True

    @group.deleter
    def group(self):
        self._group_value = None
        self._group_present = False

    @property
    def new_group_name(self):
        """
        Optional argument. Set group name to this if provided.

        :rtype: str
        """
        if self._new_group_name_present:
            return self._new_group_name_value
        else:
            return None

    @new_group_name.setter
    def new_group_name(self, val):
        if val is None:
            del self.new_group_name
            return
        val = self._new_group_name_validator.validate(val)
        self._new_group_name_value = val
        self._new_group_name_present = True

    @new_group_name.deleter
    def new_group_name(self):
        self._new_group_name_value = None
        self._new_group_name_present = False

    @property
    def new_group_external_id(self):
        """
        Optional argument. New group external ID. If the argument is None, the
        group's external_id won't be updated. If the argument is empty string,
        the group's external id will be cleared.

        :rtype: str
        """
        if self._new_group_external_id_present:
            return self._new_group_external_id_value
        else:
            return None

    @new_group_external_id.setter
    def new_group_external_id(self, val):
        if val is None:
            del self.new_group_external_id
            return
        val = self._new_group_external_id_validator.validate(val)
        self._new_group_external_id_value = val
        self._new_group_external_id_present = True

    @new_group_external_id.deleter
    def new_group_external_id(self):
        self._new_group_external_id_value = None
        self._new_group_external_id_present = False

    @property
    def new_group_management_type(self):
        """
        Set new group management type, if provided.

        :rtype: team_common.GroupManagementType_validator
        """
        if self._new_group_management_type_present:
            return self._new_group_management_type_value
        else:
            return None

    @new_group_management_type.setter
    def new_group_management_type(self, val):
        if val is None:
            del self.new_group_management_type
            return
        self._new_group_management_type_validator.validate_type_only(val)
        self._new_group_management_type_value = val
        self._new_group_management_type_present = True

    @new_group_management_type.deleter
    def new_group_management_type(self):
        self._new_group_management_type_value = None
        self._new_group_management_type_present = False

    def __repr__(self):
        return 'GroupUpdateArgs(group={!r}, return_members={!r}, new_group_name={!r}, new_group_external_id={!r}, new_group_management_type={!r})'.format(
            self._group_value,
            self._return_members_value,
            self._new_group_name_value,
            self._new_group_external_id_value,
            self._new_group_management_type_value,
        )

GroupUpdateArgs_validator = bv.Struct(GroupUpdateArgs)

class GroupUpdateError(GroupSelectorWithTeamGroupError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar group_name_already_used: The requested group name is already being
        used by another group.
    :ivar group_name_invalid: Group name is empty or has invalid characters.
    :ivar external_id_already_in_use: The requested external ID is already being
        used by another group.
    """

    # Attribute is overwritten below the class definition
    group_name_already_used = None
    # Attribute is overwritten below the class definition
    group_name_invalid = None
    # Attribute is overwritten below the class definition
    external_id_already_in_use = None

    def is_group_name_already_used(self):
        """
        Check if the union tag is ``group_name_already_used``.

        :rtype: bool
        """
        return self._tag == 'group_name_already_used'

    def is_group_name_invalid(self):
        """
        Check if the union tag is ``group_name_invalid``.

        :rtype: bool
        """
        return self._tag == 'group_name_invalid'

    def is_external_id_already_in_use(self):
        """
        Check if the union tag is ``external_id_already_in_use``.

        :rtype: bool
        """
        return self._tag == 'external_id_already_in_use'

    def __repr__(self):
        return 'GroupUpdateError(%r, %r)' % (self._tag, self._value)

GroupUpdateError_validator = bv.Union(GroupUpdateError)

class GroupsGetInfoError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar group_not_on_team: The group is not on your team.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    group_not_on_team = None
    # Attribute is overwritten below the class definition
    other = None

    def is_group_not_on_team(self):
        """
        Check if the union tag is ``group_not_on_team``.

        :rtype: bool
        """
        return self._tag == 'group_not_on_team'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'GroupsGetInfoError(%r, %r)' % (self._tag, self._value)

GroupsGetInfoError_validator = bv.Union(GroupsGetInfoError)

class GroupsGetInfoItem(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str id_not_found: An ID that was provided as a parameter to
        :route:`groups/get_info`, and did not match a corresponding group. The
        ID can be a group ID, or an external ID, depending on how the method was
        called.
    :ivar GroupFullInfo group_info: Info about a group.
    """

    _catch_all = None

    @classmethod
    def id_not_found(cls, val):
        """
        Create an instance of this class set to the ``id_not_found`` tag with
        value ``val``.

        :param str val:
        :rtype: GroupsGetInfoItem
        """
        return cls('id_not_found', val)

    @classmethod
    def group_info(cls, val):
        """
        Create an instance of this class set to the ``group_info`` tag with
        value ``val``.

        :param GroupFullInfo val:
        :rtype: GroupsGetInfoItem
        """
        return cls('group_info', val)

    def is_id_not_found(self):
        """
        Check if the union tag is ``id_not_found``.

        :rtype: bool
        """
        return self._tag == 'id_not_found'

    def is_group_info(self):
        """
        Check if the union tag is ``group_info``.

        :rtype: bool
        """
        return self._tag == 'group_info'

    def get_id_not_found(self):
        """
        An ID that was provided as a parameter to
        :meth:`dropbox.dropbox.Dropbox.team_groups_get_info`, and did not match
        a corresponding group. The ID can be a group ID, or an external ID,
        depending on how the method was called.

        Only call this if :meth:`is_id_not_found` is true.

        :rtype: str
        """
        if not self.is_id_not_found():
            raise AttributeError("tag 'id_not_found' not set")
        return self._value

    def get_group_info(self):
        """
        Info about a group.

        Only call this if :meth:`is_group_info` is true.

        :rtype: GroupFullInfo
        """
        if not self.is_group_info():
            raise AttributeError("tag 'group_info' not set")
        return self._value

    def __repr__(self):
        return 'GroupsGetInfoItem(%r, %r)' % (self._tag, self._value)

GroupsGetInfoItem_validator = bv.Union(GroupsGetInfoItem)

class GroupsListArg(object):
    """
    :ivar limit: Number of results to return per call.
    """

    __slots__ = [
        '_limit_value',
        '_limit_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 limit=None):
        self._limit_value = None
        self._limit_present = False
        if limit is not None:
            self.limit = limit

    @property
    def limit(self):
        """
        Number of results to return per call.

        :rtype: long
        """
        if self._limit_present:
            return self._limit_value
        else:
            return 1000

    @limit.setter
    def limit(self, val):
        val = self._limit_validator.validate(val)
        self._limit_value = val
        self._limit_present = True

    @limit.deleter
    def limit(self):
        self._limit_value = None
        self._limit_present = False

    def __repr__(self):
        return 'GroupsListArg(limit={!r})'.format(
            self._limit_value,
        )

GroupsListArg_validator = bv.Struct(GroupsListArg)

class GroupsListContinueArg(object):
    """
    :ivar cursor: Indicates from what point to get the next set of groups.
    """

    __slots__ = [
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 cursor=None):
        self._cursor_value = None
        self._cursor_present = False
        if cursor is not None:
            self.cursor = cursor

    @property
    def cursor(self):
        """
        Indicates from what point to get the next set of groups.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            raise AttributeError("missing required field 'cursor'")

    @cursor.setter
    def cursor(self, val):
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'GroupsListContinueArg(cursor={!r})'.format(
            self._cursor_value,
        )

GroupsListContinueArg_validator = bv.Struct(GroupsListContinueArg)

class GroupsListContinueError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar invalid_cursor: The cursor is invalid.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    invalid_cursor = None
    # Attribute is overwritten below the class definition
    other = None

    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        return self._tag == 'invalid_cursor'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'GroupsListContinueError(%r, %r)' % (self._tag, self._value)

GroupsListContinueError_validator = bv.Union(GroupsListContinueError)

class GroupsListResult(object):
    """
    :ivar cursor: Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_groups_list_continue` to obtain the
        additional groups.
    :ivar has_more: Is true if there are additional groups that have not been
        returned yet. An additional call to
        :meth:`dropbox.dropbox.Dropbox.team_groups_list_continue` can retrieve
        them.
    """

    __slots__ = [
        '_groups_value',
        '_groups_present',
        '_cursor_value',
        '_cursor_present',
        '_has_more_value',
        '_has_more_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 groups=None,
                 cursor=None,
                 has_more=None):
        self._groups_value = None
        self._groups_present = False
        self._cursor_value = None
        self._cursor_present = False
        self._has_more_value = None
        self._has_more_present = False
        if groups is not None:
            self.groups = groups
        if cursor is not None:
            self.cursor = cursor
        if has_more is not None:
            self.has_more = has_more

    @property
    def groups(self):
        """
        :rtype: list of [team_common.GroupSummary_validator]
        """
        if self._groups_present:
            return self._groups_value
        else:
            raise AttributeError("missing required field 'groups'")

    @groups.setter
    def groups(self, val):
        val = self._groups_validator.validate(val)
        self._groups_value = val
        self._groups_present = True

    @groups.deleter
    def groups(self):
        self._groups_value = None
        self._groups_present = False

    @property
    def cursor(self):
        """
        Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_groups_list_continue` to obtain the
        additional groups.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            raise AttributeError("missing required field 'cursor'")

    @cursor.setter
    def cursor(self, val):
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    @property
    def has_more(self):
        """
        Is true if there are additional groups that have not been returned yet.
        An additional call to
        :meth:`dropbox.dropbox.Dropbox.team_groups_list_continue` can retrieve
        them.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    def __repr__(self):
        return 'GroupsListResult(groups={!r}, cursor={!r}, has_more={!r})'.format(
            self._groups_value,
            self._cursor_value,
            self._has_more_value,
        )

GroupsListResult_validator = bv.Struct(GroupsListResult)

class GroupsMembersListArg(object):
    """
    :ivar group: The group whose members are to be listed.
    :ivar limit: Number of results to return per call.
    """

    __slots__ = [
        '_group_value',
        '_group_present',
        '_limit_value',
        '_limit_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 group=None,
                 limit=None):
        self._group_value = None
        self._group_present = False
        self._limit_value = None
        self._limit_present = False
        if group is not None:
            self.group = group
        if limit is not None:
            self.limit = limit

    @property
    def group(self):
        """
        The group whose members are to be listed.

        :rtype: GroupSelector
        """
        if self._group_present:
            return self._group_value
        else:
            raise AttributeError("missing required field 'group'")

    @group.setter
    def group(self, val):
        self._group_validator.validate_type_only(val)
        self._group_value = val
        self._group_present = True

    @group.deleter
    def group(self):
        self._group_value = None
        self._group_present = False

    @property
    def limit(self):
        """
        Number of results to return per call.

        :rtype: long
        """
        if self._limit_present:
            return self._limit_value
        else:
            return 1000

    @limit.setter
    def limit(self, val):
        val = self._limit_validator.validate(val)
        self._limit_value = val
        self._limit_present = True

    @limit.deleter
    def limit(self):
        self._limit_value = None
        self._limit_present = False

    def __repr__(self):
        return 'GroupsMembersListArg(group={!r}, limit={!r})'.format(
            self._group_value,
            self._limit_value,
        )

GroupsMembersListArg_validator = bv.Struct(GroupsMembersListArg)

class GroupsMembersListContinueArg(object):
    """
    :ivar cursor: Indicates from what point to get the next set of groups.
    """

    __slots__ = [
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 cursor=None):
        self._cursor_value = None
        self._cursor_present = False
        if cursor is not None:
            self.cursor = cursor

    @property
    def cursor(self):
        """
        Indicates from what point to get the next set of groups.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            raise AttributeError("missing required field 'cursor'")

    @cursor.setter
    def cursor(self, val):
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'GroupsMembersListContinueArg(cursor={!r})'.format(
            self._cursor_value,
        )

GroupsMembersListContinueArg_validator = bv.Struct(GroupsMembersListContinueArg)

class GroupsMembersListContinueError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar invalid_cursor: The cursor is invalid.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    invalid_cursor = None
    # Attribute is overwritten below the class definition
    other = None

    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        return self._tag == 'invalid_cursor'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'GroupsMembersListContinueError(%r, %r)' % (self._tag, self._value)

GroupsMembersListContinueError_validator = bv.Union(GroupsMembersListContinueError)

class GroupsMembersListResult(object):
    """
    :ivar cursor: Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_groups_members_list_continue` to
        obtain additional group members.
    :ivar has_more: Is true if there are additional group members that have not
        been returned yet. An additional call to
        :meth:`dropbox.dropbox.Dropbox.team_groups_members_list_continue` can
        retrieve them.
    """

    __slots__ = [
        '_members_value',
        '_members_present',
        '_cursor_value',
        '_cursor_present',
        '_has_more_value',
        '_has_more_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 members=None,
                 cursor=None,
                 has_more=None):
        self._members_value = None
        self._members_present = False
        self._cursor_value = None
        self._cursor_present = False
        self._has_more_value = None
        self._has_more_present = False
        if members is not None:
            self.members = members
        if cursor is not None:
            self.cursor = cursor
        if has_more is not None:
            self.has_more = has_more

    @property
    def members(self):
        """
        :rtype: list of [GroupMemberInfo]
        """
        if self._members_present:
            return self._members_value
        else:
            raise AttributeError("missing required field 'members'")

    @members.setter
    def members(self, val):
        val = self._members_validator.validate(val)
        self._members_value = val
        self._members_present = True

    @members.deleter
    def members(self):
        self._members_value = None
        self._members_present = False

    @property
    def cursor(self):
        """
        Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_groups_members_list_continue` to
        obtain additional group members.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            raise AttributeError("missing required field 'cursor'")

    @cursor.setter
    def cursor(self, val):
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    @property
    def has_more(self):
        """
        Is true if there are additional group members that have not been
        returned yet. An additional call to
        :meth:`dropbox.dropbox.Dropbox.team_groups_members_list_continue` can
        retrieve them.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    def __repr__(self):
        return 'GroupsMembersListResult(members={!r}, cursor={!r}, has_more={!r})'.format(
            self._members_value,
            self._cursor_value,
            self._has_more_value,
        )

GroupsMembersListResult_validator = bv.Struct(GroupsMembersListResult)

class GroupsPollError(async.PollError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar access_denied: You are not allowed to poll this job.
    """

    # Attribute is overwritten below the class definition
    access_denied = None

    def is_access_denied(self):
        """
        Check if the union tag is ``access_denied``.

        :rtype: bool
        """
        return self._tag == 'access_denied'

    def __repr__(self):
        return 'GroupsPollError(%r, %r)' % (self._tag, self._value)

GroupsPollError_validator = bv.Union(GroupsPollError)

class GroupsSelector(bb.Union):
    """
    Argument for selecting a list of groups, either by group_ids, or external
    group IDs.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar list of [str] group_ids: List of group IDs.
    :ivar list of [str] group_external_ids: List of external IDs of groups.
    """

    _catch_all = None

    @classmethod
    def group_ids(cls, val):
        """
        Create an instance of this class set to the ``group_ids`` tag with value
        ``val``.

        :param list of [str] val:
        :rtype: GroupsSelector
        """
        return cls('group_ids', val)

    @classmethod
    def group_external_ids(cls, val):
        """
        Create an instance of this class set to the ``group_external_ids`` tag
        with value ``val``.

        :param list of [str] val:
        :rtype: GroupsSelector
        """
        return cls('group_external_ids', val)

    def is_group_ids(self):
        """
        Check if the union tag is ``group_ids``.

        :rtype: bool
        """
        return self._tag == 'group_ids'

    def is_group_external_ids(self):
        """
        Check if the union tag is ``group_external_ids``.

        :rtype: bool
        """
        return self._tag == 'group_external_ids'

    def get_group_ids(self):
        """
        List of group IDs.

        Only call this if :meth:`is_group_ids` is true.

        :rtype: list of [str]
        """
        if not self.is_group_ids():
            raise AttributeError("tag 'group_ids' not set")
        return self._value

    def get_group_external_ids(self):
        """
        List of external IDs of groups.

        Only call this if :meth:`is_group_external_ids` is true.

        :rtype: list of [str]
        """
        if not self.is_group_external_ids():
            raise AttributeError("tag 'group_external_ids' not set")
        return self._value

    def __repr__(self):
        return 'GroupsSelector(%r, %r)' % (self._tag, self._value)

GroupsSelector_validator = bv.Union(GroupsSelector)

class ListMemberAppsArg(object):
    """
    :ivar team_member_id: The team member id
    """

    __slots__ = [
        '_team_member_id_value',
        '_team_member_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_member_id=None):
        self._team_member_id_value = None
        self._team_member_id_present = False
        if team_member_id is not None:
            self.team_member_id = team_member_id

    @property
    def team_member_id(self):
        """
        The team member id

        :rtype: str
        """
        if self._team_member_id_present:
            return self._team_member_id_value
        else:
            raise AttributeError("missing required field 'team_member_id'")

    @team_member_id.setter
    def team_member_id(self, val):
        val = self._team_member_id_validator.validate(val)
        self._team_member_id_value = val
        self._team_member_id_present = True

    @team_member_id.deleter
    def team_member_id(self):
        self._team_member_id_value = None
        self._team_member_id_present = False

    def __repr__(self):
        return 'ListMemberAppsArg(team_member_id={!r})'.format(
            self._team_member_id_value,
        )

ListMemberAppsArg_validator = bv.Struct(ListMemberAppsArg)

class ListMemberAppsError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_member_linked_apps`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar member_not_found: Member not found.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    member_not_found = None
    # Attribute is overwritten below the class definition
    other = None

    def is_member_not_found(self):
        """
        Check if the union tag is ``member_not_found``.

        :rtype: bool
        """
        return self._tag == 'member_not_found'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'ListMemberAppsError(%r, %r)' % (self._tag, self._value)

ListMemberAppsError_validator = bv.Union(ListMemberAppsError)

class ListMemberAppsResult(object):
    """
    :ivar linked_api_apps: List of third party applications linked by this team
        member
    """

    __slots__ = [
        '_linked_api_apps_value',
        '_linked_api_apps_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 linked_api_apps=None):
        self._linked_api_apps_value = None
        self._linked_api_apps_present = False
        if linked_api_apps is not None:
            self.linked_api_apps = linked_api_apps

    @property
    def linked_api_apps(self):
        """
        List of third party applications linked by this team member

        :rtype: list of [ApiApp]
        """
        if self._linked_api_apps_present:
            return self._linked_api_apps_value
        else:
            raise AttributeError("missing required field 'linked_api_apps'")

    @linked_api_apps.setter
    def linked_api_apps(self, val):
        val = self._linked_api_apps_validator.validate(val)
        self._linked_api_apps_value = val
        self._linked_api_apps_present = True

    @linked_api_apps.deleter
    def linked_api_apps(self):
        self._linked_api_apps_value = None
        self._linked_api_apps_present = False

    def __repr__(self):
        return 'ListMemberAppsResult(linked_api_apps={!r})'.format(
            self._linked_api_apps_value,
        )

ListMemberAppsResult_validator = bv.Struct(ListMemberAppsResult)

class ListMemberDevicesArg(object):
    """
    :ivar team_member_id: The team's member id
    :ivar include_web_sessions: Whether to list web sessions of the team's
        member
    :ivar include_desktop_clients: Whether to list linked desktop devices of the
        team's member
    :ivar include_mobile_clients: Whether to list linked mobile devices of the
        team's member
    """

    __slots__ = [
        '_team_member_id_value',
        '_team_member_id_present',
        '_include_web_sessions_value',
        '_include_web_sessions_present',
        '_include_desktop_clients_value',
        '_include_desktop_clients_present',
        '_include_mobile_clients_value',
        '_include_mobile_clients_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_member_id=None,
                 include_web_sessions=None,
                 include_desktop_clients=None,
                 include_mobile_clients=None):
        self._team_member_id_value = None
        self._team_member_id_present = False
        self._include_web_sessions_value = None
        self._include_web_sessions_present = False
        self._include_desktop_clients_value = None
        self._include_desktop_clients_present = False
        self._include_mobile_clients_value = None
        self._include_mobile_clients_present = False
        if team_member_id is not None:
            self.team_member_id = team_member_id
        if include_web_sessions is not None:
            self.include_web_sessions = include_web_sessions
        if include_desktop_clients is not None:
            self.include_desktop_clients = include_desktop_clients
        if include_mobile_clients is not None:
            self.include_mobile_clients = include_mobile_clients

    @property
    def team_member_id(self):
        """
        The team's member id

        :rtype: str
        """
        if self._team_member_id_present:
            return self._team_member_id_value
        else:
            raise AttributeError("missing required field 'team_member_id'")

    @team_member_id.setter
    def team_member_id(self, val):
        val = self._team_member_id_validator.validate(val)
        self._team_member_id_value = val
        self._team_member_id_present = True

    @team_member_id.deleter
    def team_member_id(self):
        self._team_member_id_value = None
        self._team_member_id_present = False

    @property
    def include_web_sessions(self):
        """
        Whether to list web sessions of the team's member

        :rtype: bool
        """
        if self._include_web_sessions_present:
            return self._include_web_sessions_value
        else:
            return True

    @include_web_sessions.setter
    def include_web_sessions(self, val):
        val = self._include_web_sessions_validator.validate(val)
        self._include_web_sessions_value = val
        self._include_web_sessions_present = True

    @include_web_sessions.deleter
    def include_web_sessions(self):
        self._include_web_sessions_value = None
        self._include_web_sessions_present = False

    @property
    def include_desktop_clients(self):
        """
        Whether to list linked desktop devices of the team's member

        :rtype: bool
        """
        if self._include_desktop_clients_present:
            return self._include_desktop_clients_value
        else:
            return True

    @include_desktop_clients.setter
    def include_desktop_clients(self, val):
        val = self._include_desktop_clients_validator.validate(val)
        self._include_desktop_clients_value = val
        self._include_desktop_clients_present = True

    @include_desktop_clients.deleter
    def include_desktop_clients(self):
        self._include_desktop_clients_value = None
        self._include_desktop_clients_present = False

    @property
    def include_mobile_clients(self):
        """
        Whether to list linked mobile devices of the team's member

        :rtype: bool
        """
        if self._include_mobile_clients_present:
            return self._include_mobile_clients_value
        else:
            return True

    @include_mobile_clients.setter
    def include_mobile_clients(self, val):
        val = self._include_mobile_clients_validator.validate(val)
        self._include_mobile_clients_value = val
        self._include_mobile_clients_present = True

    @include_mobile_clients.deleter
    def include_mobile_clients(self):
        self._include_mobile_clients_value = None
        self._include_mobile_clients_present = False

    def __repr__(self):
        return 'ListMemberDevicesArg(team_member_id={!r}, include_web_sessions={!r}, include_desktop_clients={!r}, include_mobile_clients={!r})'.format(
            self._team_member_id_value,
            self._include_web_sessions_value,
            self._include_desktop_clients_value,
            self._include_mobile_clients_value,
        )

ListMemberDevicesArg_validator = bv.Struct(ListMemberDevicesArg)

class ListMemberDevicesError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar member_not_found: Member not found.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    member_not_found = None
    # Attribute is overwritten below the class definition
    other = None

    def is_member_not_found(self):
        """
        Check if the union tag is ``member_not_found``.

        :rtype: bool
        """
        return self._tag == 'member_not_found'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'ListMemberDevicesError(%r, %r)' % (self._tag, self._value)

ListMemberDevicesError_validator = bv.Union(ListMemberDevicesError)

class ListMemberDevicesResult(object):
    """
    :ivar active_web_sessions: List of web sessions made by this team member
    :ivar desktop_client_sessions: List of desktop clients used by this team
        member
    :ivar mobile_client_sessions: List of mobile client used by this team member
    """

    __slots__ = [
        '_active_web_sessions_value',
        '_active_web_sessions_present',
        '_desktop_client_sessions_value',
        '_desktop_client_sessions_present',
        '_mobile_client_sessions_value',
        '_mobile_client_sessions_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 active_web_sessions=None,
                 desktop_client_sessions=None,
                 mobile_client_sessions=None):
        self._active_web_sessions_value = None
        self._active_web_sessions_present = False
        self._desktop_client_sessions_value = None
        self._desktop_client_sessions_present = False
        self._mobile_client_sessions_value = None
        self._mobile_client_sessions_present = False
        if active_web_sessions is not None:
            self.active_web_sessions = active_web_sessions
        if desktop_client_sessions is not None:
            self.desktop_client_sessions = desktop_client_sessions
        if mobile_client_sessions is not None:
            self.mobile_client_sessions = mobile_client_sessions

    @property
    def active_web_sessions(self):
        """
        List of web sessions made by this team member

        :rtype: list of [ActiveWebSession]
        """
        if self._active_web_sessions_present:
            return self._active_web_sessions_value
        else:
            return None

    @active_web_sessions.setter
    def active_web_sessions(self, val):
        if val is None:
            del self.active_web_sessions
            return
        val = self._active_web_sessions_validator.validate(val)
        self._active_web_sessions_value = val
        self._active_web_sessions_present = True

    @active_web_sessions.deleter
    def active_web_sessions(self):
        self._active_web_sessions_value = None
        self._active_web_sessions_present = False

    @property
    def desktop_client_sessions(self):
        """
        List of desktop clients used by this team member

        :rtype: list of [DesktopClientSession]
        """
        if self._desktop_client_sessions_present:
            return self._desktop_client_sessions_value
        else:
            return None

    @desktop_client_sessions.setter
    def desktop_client_sessions(self, val):
        if val is None:
            del self.desktop_client_sessions
            return
        val = self._desktop_client_sessions_validator.validate(val)
        self._desktop_client_sessions_value = val
        self._desktop_client_sessions_present = True

    @desktop_client_sessions.deleter
    def desktop_client_sessions(self):
        self._desktop_client_sessions_value = None
        self._desktop_client_sessions_present = False

    @property
    def mobile_client_sessions(self):
        """
        List of mobile client used by this team member

        :rtype: list of [MobileClientSession]
        """
        if self._mobile_client_sessions_present:
            return self._mobile_client_sessions_value
        else:
            return None

    @mobile_client_sessions.setter
    def mobile_client_sessions(self, val):
        if val is None:
            del self.mobile_client_sessions
            return
        val = self._mobile_client_sessions_validator.validate(val)
        self._mobile_client_sessions_value = val
        self._mobile_client_sessions_present = True

    @mobile_client_sessions.deleter
    def mobile_client_sessions(self):
        self._mobile_client_sessions_value = None
        self._mobile_client_sessions_present = False

    def __repr__(self):
        return 'ListMemberDevicesResult(active_web_sessions={!r}, desktop_client_sessions={!r}, mobile_client_sessions={!r})'.format(
            self._active_web_sessions_value,
            self._desktop_client_sessions_value,
            self._mobile_client_sessions_value,
        )

ListMemberDevicesResult_validator = bv.Struct(ListMemberDevicesResult)

class ListMembersAppsArg(object):
    """
    Arguments for
    :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_members_linked_apps`.

    :ivar cursor: At the first call to the
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_members_linked_apps`
        the cursor shouldn't be passed. Then, if the result of the call includes
        a cursor, the following requests should include the received cursors in
        order to receive the next sub list of the team applications
    """

    __slots__ = [
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 cursor=None):
        self._cursor_value = None
        self._cursor_present = False
        if cursor is not None:
            self.cursor = cursor

    @property
    def cursor(self):
        """
        At the first call to the
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_members_linked_apps`
        the cursor shouldn't be passed. Then, if the result of the call includes
        a cursor, the following requests should include the received cursors in
        order to receive the next sub list of the team applications

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'ListMembersAppsArg(cursor={!r})'.format(
            self._cursor_value,
        )

ListMembersAppsArg_validator = bv.Struct(ListMembersAppsArg)

class ListMembersAppsError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_members_linked_apps`

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar reset: Indicates that the cursor has been invalidated. Call
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_members_linked_apps`
        again with an empty cursor to obtain a new cursor.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    reset = None
    # Attribute is overwritten below the class definition
    other = None

    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        return self._tag == 'reset'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'ListMembersAppsError(%r, %r)' % (self._tag, self._value)

ListMembersAppsError_validator = bv.Union(ListMembersAppsError)

class ListMembersAppsResult(object):
    """
    Information returned by
    :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_members_linked_apps`.

    :ivar apps: The linked applications of each member of the team
    :ivar has_more: If true, then there are more apps available. Pass the cursor
        to
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_members_linked_apps`
        to retrieve the rest.
    :ivar cursor: Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_members_linked_apps`
        to receive the next sub list of team's applications.
    """

    __slots__ = [
        '_apps_value',
        '_apps_present',
        '_has_more_value',
        '_has_more_present',
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 apps=None,
                 has_more=None,
                 cursor=None):
        self._apps_value = None
        self._apps_present = False
        self._has_more_value = None
        self._has_more_present = False
        self._cursor_value = None
        self._cursor_present = False
        if apps is not None:
            self.apps = apps
        if has_more is not None:
            self.has_more = has_more
        if cursor is not None:
            self.cursor = cursor

    @property
    def apps(self):
        """
        The linked applications of each member of the team

        :rtype: list of [MemberLinkedApps]
        """
        if self._apps_present:
            return self._apps_value
        else:
            raise AttributeError("missing required field 'apps'")

    @apps.setter
    def apps(self, val):
        val = self._apps_validator.validate(val)
        self._apps_value = val
        self._apps_present = True

    @apps.deleter
    def apps(self):
        self._apps_value = None
        self._apps_present = False

    @property
    def has_more(self):
        """
        If true, then there are more apps available. Pass the cursor to
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_members_linked_apps`
        to retrieve the rest.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    @property
    def cursor(self):
        """
        Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_members_linked_apps`
        to receive the next sub list of team's applications.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'ListMembersAppsResult(apps={!r}, has_more={!r}, cursor={!r})'.format(
            self._apps_value,
            self._has_more_value,
            self._cursor_value,
        )

ListMembersAppsResult_validator = bv.Struct(ListMembersAppsResult)

class ListMembersDevicesArg(object):
    """
    :ivar cursor: At the first call to the
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_members_devices` the
        cursor shouldn't be passed. Then, if the result of the call includes a
        cursor, the following requests should include the received cursors in
        order to receive the next sub list of team devices
    :ivar include_web_sessions: Whether to list web sessions of the team members
    :ivar include_desktop_clients: Whether to list desktop clients of the team
        members
    :ivar include_mobile_clients: Whether to list mobile clients of the team
        members
    """

    __slots__ = [
        '_cursor_value',
        '_cursor_present',
        '_include_web_sessions_value',
        '_include_web_sessions_present',
        '_include_desktop_clients_value',
        '_include_desktop_clients_present',
        '_include_mobile_clients_value',
        '_include_mobile_clients_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 cursor=None,
                 include_web_sessions=None,
                 include_desktop_clients=None,
                 include_mobile_clients=None):
        self._cursor_value = None
        self._cursor_present = False
        self._include_web_sessions_value = None
        self._include_web_sessions_present = False
        self._include_desktop_clients_value = None
        self._include_desktop_clients_present = False
        self._include_mobile_clients_value = None
        self._include_mobile_clients_present = False
        if cursor is not None:
            self.cursor = cursor
        if include_web_sessions is not None:
            self.include_web_sessions = include_web_sessions
        if include_desktop_clients is not None:
            self.include_desktop_clients = include_desktop_clients
        if include_mobile_clients is not None:
            self.include_mobile_clients = include_mobile_clients

    @property
    def cursor(self):
        """
        At the first call to the
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_members_devices` the
        cursor shouldn't be passed. Then, if the result of the call includes a
        cursor, the following requests should include the received cursors in
        order to receive the next sub list of team devices

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    @property
    def include_web_sessions(self):
        """
        Whether to list web sessions of the team members

        :rtype: bool
        """
        if self._include_web_sessions_present:
            return self._include_web_sessions_value
        else:
            return True

    @include_web_sessions.setter
    def include_web_sessions(self, val):
        val = self._include_web_sessions_validator.validate(val)
        self._include_web_sessions_value = val
        self._include_web_sessions_present = True

    @include_web_sessions.deleter
    def include_web_sessions(self):
        self._include_web_sessions_value = None
        self._include_web_sessions_present = False

    @property
    def include_desktop_clients(self):
        """
        Whether to list desktop clients of the team members

        :rtype: bool
        """
        if self._include_desktop_clients_present:
            return self._include_desktop_clients_value
        else:
            return True

    @include_desktop_clients.setter
    def include_desktop_clients(self, val):
        val = self._include_desktop_clients_validator.validate(val)
        self._include_desktop_clients_value = val
        self._include_desktop_clients_present = True

    @include_desktop_clients.deleter
    def include_desktop_clients(self):
        self._include_desktop_clients_value = None
        self._include_desktop_clients_present = False

    @property
    def include_mobile_clients(self):
        """
        Whether to list mobile clients of the team members

        :rtype: bool
        """
        if self._include_mobile_clients_present:
            return self._include_mobile_clients_value
        else:
            return True

    @include_mobile_clients.setter
    def include_mobile_clients(self, val):
        val = self._include_mobile_clients_validator.validate(val)
        self._include_mobile_clients_value = val
        self._include_mobile_clients_present = True

    @include_mobile_clients.deleter
    def include_mobile_clients(self):
        self._include_mobile_clients_value = None
        self._include_mobile_clients_present = False

    def __repr__(self):
        return 'ListMembersDevicesArg(cursor={!r}, include_web_sessions={!r}, include_desktop_clients={!r}, include_mobile_clients={!r})'.format(
            self._cursor_value,
            self._include_web_sessions_value,
            self._include_desktop_clients_value,
            self._include_mobile_clients_value,
        )

ListMembersDevicesArg_validator = bv.Struct(ListMembersDevicesArg)

class ListMembersDevicesError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar reset: Indicates that the cursor has been invalidated. Call
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_members_devices` again
        with an empty cursor to obtain a new cursor.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    reset = None
    # Attribute is overwritten below the class definition
    other = None

    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        return self._tag == 'reset'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'ListMembersDevicesError(%r, %r)' % (self._tag, self._value)

ListMembersDevicesError_validator = bv.Union(ListMembersDevicesError)

class ListMembersDevicesResult(object):
    """
    :ivar devices: The devices of each member of the team
    :ivar has_more: If true, then there are more devices available. Pass the
        cursor to
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_members_devices` to
        retrieve the rest.
    :ivar cursor: Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_members_devices` to
        receive the next sub list of team's devices.
    """

    __slots__ = [
        '_devices_value',
        '_devices_present',
        '_has_more_value',
        '_has_more_present',
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 devices=None,
                 has_more=None,
                 cursor=None):
        self._devices_value = None
        self._devices_present = False
        self._has_more_value = None
        self._has_more_present = False
        self._cursor_value = None
        self._cursor_present = False
        if devices is not None:
            self.devices = devices
        if has_more is not None:
            self.has_more = has_more
        if cursor is not None:
            self.cursor = cursor

    @property
    def devices(self):
        """
        The devices of each member of the team

        :rtype: list of [MemberDevices]
        """
        if self._devices_present:
            return self._devices_value
        else:
            raise AttributeError("missing required field 'devices'")

    @devices.setter
    def devices(self, val):
        val = self._devices_validator.validate(val)
        self._devices_value = val
        self._devices_present = True

    @devices.deleter
    def devices(self):
        self._devices_value = None
        self._devices_present = False

    @property
    def has_more(self):
        """
        If true, then there are more devices available. Pass the cursor to
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_members_devices` to
        retrieve the rest.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    @property
    def cursor(self):
        """
        Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_members_devices` to
        receive the next sub list of team's devices.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'ListMembersDevicesResult(devices={!r}, has_more={!r}, cursor={!r})'.format(
            self._devices_value,
            self._has_more_value,
            self._cursor_value,
        )

ListMembersDevicesResult_validator = bv.Struct(ListMembersDevicesResult)

class ListTeamAppsArg(object):
    """
    Arguments for
    :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_team_linked_apps`.

    :ivar cursor: At the first call to the
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_team_linked_apps`
        the cursor shouldn't be passed. Then, if the result of the call includes
        a cursor, the following requests should include the received cursors in
        order to receive the next sub list of the team applications
    """

    __slots__ = [
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 cursor=None):
        self._cursor_value = None
        self._cursor_present = False
        if cursor is not None:
            self.cursor = cursor

    @property
    def cursor(self):
        """
        At the first call to the
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_team_linked_apps`
        the cursor shouldn't be passed. Then, if the result of the call includes
        a cursor, the following requests should include the received cursors in
        order to receive the next sub list of the team applications

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'ListTeamAppsArg(cursor={!r})'.format(
            self._cursor_value,
        )

ListTeamAppsArg_validator = bv.Struct(ListTeamAppsArg)

class ListTeamAppsError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_team_linked_apps`

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar reset: Indicates that the cursor has been invalidated. Call
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_team_linked_apps`
        again with an empty cursor to obtain a new cursor.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    reset = None
    # Attribute is overwritten below the class definition
    other = None

    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        return self._tag == 'reset'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'ListTeamAppsError(%r, %r)' % (self._tag, self._value)

ListTeamAppsError_validator = bv.Union(ListTeamAppsError)

class ListTeamAppsResult(object):
    """
    Information returned by
    :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_team_linked_apps`.

    :ivar apps: The linked applications of each member of the team
    :ivar has_more: If true, then there are more apps available. Pass the cursor
        to
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_team_linked_apps`
        to retrieve the rest.
    :ivar cursor: Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_team_linked_apps`
        to receive the next sub list of team's applications.
    """

    __slots__ = [
        '_apps_value',
        '_apps_present',
        '_has_more_value',
        '_has_more_present',
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 apps=None,
                 has_more=None,
                 cursor=None):
        self._apps_value = None
        self._apps_present = False
        self._has_more_value = None
        self._has_more_present = False
        self._cursor_value = None
        self._cursor_present = False
        if apps is not None:
            self.apps = apps
        if has_more is not None:
            self.has_more = has_more
        if cursor is not None:
            self.cursor = cursor

    @property
    def apps(self):
        """
        The linked applications of each member of the team

        :rtype: list of [MemberLinkedApps]
        """
        if self._apps_present:
            return self._apps_value
        else:
            raise AttributeError("missing required field 'apps'")

    @apps.setter
    def apps(self, val):
        val = self._apps_validator.validate(val)
        self._apps_value = val
        self._apps_present = True

    @apps.deleter
    def apps(self):
        self._apps_value = None
        self._apps_present = False

    @property
    def has_more(self):
        """
        If true, then there are more apps available. Pass the cursor to
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_team_linked_apps`
        to retrieve the rest.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    @property
    def cursor(self):
        """
        Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_linked_apps_list_team_linked_apps`
        to receive the next sub list of team's applications.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'ListTeamAppsResult(apps={!r}, has_more={!r}, cursor={!r})'.format(
            self._apps_value,
            self._has_more_value,
            self._cursor_value,
        )

ListTeamAppsResult_validator = bv.Struct(ListTeamAppsResult)

class ListTeamDevicesArg(object):
    """
    :ivar cursor: At the first call to the
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_team_devices` the
        cursor shouldn't be passed. Then, if the result of the call includes a
        cursor, the following requests should include the received cursors in
        order to receive the next sub list of team devices
    :ivar include_web_sessions: Whether to list web sessions of the team members
    :ivar include_desktop_clients: Whether to list desktop clients of the team
        members
    :ivar include_mobile_clients: Whether to list mobile clients of the team
        members
    """

    __slots__ = [
        '_cursor_value',
        '_cursor_present',
        '_include_web_sessions_value',
        '_include_web_sessions_present',
        '_include_desktop_clients_value',
        '_include_desktop_clients_present',
        '_include_mobile_clients_value',
        '_include_mobile_clients_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 cursor=None,
                 include_web_sessions=None,
                 include_desktop_clients=None,
                 include_mobile_clients=None):
        self._cursor_value = None
        self._cursor_present = False
        self._include_web_sessions_value = None
        self._include_web_sessions_present = False
        self._include_desktop_clients_value = None
        self._include_desktop_clients_present = False
        self._include_mobile_clients_value = None
        self._include_mobile_clients_present = False
        if cursor is not None:
            self.cursor = cursor
        if include_web_sessions is not None:
            self.include_web_sessions = include_web_sessions
        if include_desktop_clients is not None:
            self.include_desktop_clients = include_desktop_clients
        if include_mobile_clients is not None:
            self.include_mobile_clients = include_mobile_clients

    @property
    def cursor(self):
        """
        At the first call to the
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_team_devices` the
        cursor shouldn't be passed. Then, if the result of the call includes a
        cursor, the following requests should include the received cursors in
        order to receive the next sub list of team devices

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    @property
    def include_web_sessions(self):
        """
        Whether to list web sessions of the team members

        :rtype: bool
        """
        if self._include_web_sessions_present:
            return self._include_web_sessions_value
        else:
            return True

    @include_web_sessions.setter
    def include_web_sessions(self, val):
        val = self._include_web_sessions_validator.validate(val)
        self._include_web_sessions_value = val
        self._include_web_sessions_present = True

    @include_web_sessions.deleter
    def include_web_sessions(self):
        self._include_web_sessions_value = None
        self._include_web_sessions_present = False

    @property
    def include_desktop_clients(self):
        """
        Whether to list desktop clients of the team members

        :rtype: bool
        """
        if self._include_desktop_clients_present:
            return self._include_desktop_clients_value
        else:
            return True

    @include_desktop_clients.setter
    def include_desktop_clients(self, val):
        val = self._include_desktop_clients_validator.validate(val)
        self._include_desktop_clients_value = val
        self._include_desktop_clients_present = True

    @include_desktop_clients.deleter
    def include_desktop_clients(self):
        self._include_desktop_clients_value = None
        self._include_desktop_clients_present = False

    @property
    def include_mobile_clients(self):
        """
        Whether to list mobile clients of the team members

        :rtype: bool
        """
        if self._include_mobile_clients_present:
            return self._include_mobile_clients_value
        else:
            return True

    @include_mobile_clients.setter
    def include_mobile_clients(self, val):
        val = self._include_mobile_clients_validator.validate(val)
        self._include_mobile_clients_value = val
        self._include_mobile_clients_present = True

    @include_mobile_clients.deleter
    def include_mobile_clients(self):
        self._include_mobile_clients_value = None
        self._include_mobile_clients_present = False

    def __repr__(self):
        return 'ListTeamDevicesArg(cursor={!r}, include_web_sessions={!r}, include_desktop_clients={!r}, include_mobile_clients={!r})'.format(
            self._cursor_value,
            self._include_web_sessions_value,
            self._include_desktop_clients_value,
            self._include_mobile_clients_value,
        )

ListTeamDevicesArg_validator = bv.Struct(ListTeamDevicesArg)

class ListTeamDevicesError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar reset: Indicates that the cursor has been invalidated. Call
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_team_devices` again
        with an empty cursor to obtain a new cursor.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    reset = None
    # Attribute is overwritten below the class definition
    other = None

    def is_reset(self):
        """
        Check if the union tag is ``reset``.

        :rtype: bool
        """
        return self._tag == 'reset'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'ListTeamDevicesError(%r, %r)' % (self._tag, self._value)

ListTeamDevicesError_validator = bv.Union(ListTeamDevicesError)

class ListTeamDevicesResult(object):
    """
    :ivar devices: The devices of each member of the team
    :ivar has_more: If true, then there are more devices available. Pass the
        cursor to :meth:`dropbox.dropbox.Dropbox.team_devices_list_team_devices`
        to retrieve the rest.
    :ivar cursor: Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_team_devices` to
        receive the next sub list of team's devices.
    """

    __slots__ = [
        '_devices_value',
        '_devices_present',
        '_has_more_value',
        '_has_more_present',
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 devices=None,
                 has_more=None,
                 cursor=None):
        self._devices_value = None
        self._devices_present = False
        self._has_more_value = None
        self._has_more_present = False
        self._cursor_value = None
        self._cursor_present = False
        if devices is not None:
            self.devices = devices
        if has_more is not None:
            self.has_more = has_more
        if cursor is not None:
            self.cursor = cursor

    @property
    def devices(self):
        """
        The devices of each member of the team

        :rtype: list of [MemberDevices]
        """
        if self._devices_present:
            return self._devices_value
        else:
            raise AttributeError("missing required field 'devices'")

    @devices.setter
    def devices(self, val):
        val = self._devices_validator.validate(val)
        self._devices_value = val
        self._devices_present = True

    @devices.deleter
    def devices(self):
        self._devices_value = None
        self._devices_present = False

    @property
    def has_more(self):
        """
        If true, then there are more devices available. Pass the cursor to
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_team_devices` to
        retrieve the rest.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    @property
    def cursor(self):
        """
        Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_devices_list_team_devices` to
        receive the next sub list of team's devices.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            return None

    @cursor.setter
    def cursor(self, val):
        if val is None:
            del self.cursor
            return
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'ListTeamDevicesResult(devices={!r}, has_more={!r}, cursor={!r})'.format(
            self._devices_value,
            self._has_more_value,
            self._cursor_value,
        )

ListTeamDevicesResult_validator = bv.Struct(ListTeamDevicesResult)

class MemberAccess(object):
    """
    Specify access type a member should have when joined to a group.

    :ivar user: Identity of a user.
    :ivar access_type: Access type.
    """

    __slots__ = [
        '_user_value',
        '_user_present',
        '_access_type_value',
        '_access_type_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user=None,
                 access_type=None):
        self._user_value = None
        self._user_present = False
        self._access_type_value = None
        self._access_type_present = False
        if user is not None:
            self.user = user
        if access_type is not None:
            self.access_type = access_type

    @property
    def user(self):
        """
        Identity of a user.

        :rtype: UserSelectorArg
        """
        if self._user_present:
            return self._user_value
        else:
            raise AttributeError("missing required field 'user'")

    @user.setter
    def user(self, val):
        self._user_validator.validate_type_only(val)
        self._user_value = val
        self._user_present = True

    @user.deleter
    def user(self):
        self._user_value = None
        self._user_present = False

    @property
    def access_type(self):
        """
        Access type.

        :rtype: GroupAccessType
        """
        if self._access_type_present:
            return self._access_type_value
        else:
            raise AttributeError("missing required field 'access_type'")

    @access_type.setter
    def access_type(self, val):
        self._access_type_validator.validate_type_only(val)
        self._access_type_value = val
        self._access_type_present = True

    @access_type.deleter
    def access_type(self):
        self._access_type_value = None
        self._access_type_present = False

    def __repr__(self):
        return 'MemberAccess(user={!r}, access_type={!r})'.format(
            self._user_value,
            self._access_type_value,
        )

MemberAccess_validator = bv.Struct(MemberAccess)

class MemberAddArg(object):
    """
    :ivar member_given_name: Member's first name.
    :ivar member_surname: Member's last name.
    :ivar member_external_id: External ID for member.
    :ivar member_persistent_id: Persistent ID for member. This field is only
        available to teams using persistent ID SAML configuration.
    :ivar send_welcome_email: Whether to send a welcome email to the member. If
        send_welcome_email is false, no email invitation will be sent to the
        user. This may be useful for apps using single sign-on (SSO) flows for
        onboarding that want to handle announcements themselves.
    """

    __slots__ = [
        '_member_email_value',
        '_member_email_present',
        '_member_given_name_value',
        '_member_given_name_present',
        '_member_surname_value',
        '_member_surname_present',
        '_member_external_id_value',
        '_member_external_id_present',
        '_member_persistent_id_value',
        '_member_persistent_id_present',
        '_send_welcome_email_value',
        '_send_welcome_email_present',
        '_role_value',
        '_role_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 member_email=None,
                 member_given_name=None,
                 member_surname=None,
                 member_external_id=None,
                 member_persistent_id=None,
                 send_welcome_email=None,
                 role=None):
        self._member_email_value = None
        self._member_email_present = False
        self._member_given_name_value = None
        self._member_given_name_present = False
        self._member_surname_value = None
        self._member_surname_present = False
        self._member_external_id_value = None
        self._member_external_id_present = False
        self._member_persistent_id_value = None
        self._member_persistent_id_present = False
        self._send_welcome_email_value = None
        self._send_welcome_email_present = False
        self._role_value = None
        self._role_present = False
        if member_email is not None:
            self.member_email = member_email
        if member_given_name is not None:
            self.member_given_name = member_given_name
        if member_surname is not None:
            self.member_surname = member_surname
        if member_external_id is not None:
            self.member_external_id = member_external_id
        if member_persistent_id is not None:
            self.member_persistent_id = member_persistent_id
        if send_welcome_email is not None:
            self.send_welcome_email = send_welcome_email
        if role is not None:
            self.role = role

    @property
    def member_email(self):
        """
        :rtype: str
        """
        if self._member_email_present:
            return self._member_email_value
        else:
            raise AttributeError("missing required field 'member_email'")

    @member_email.setter
    def member_email(self, val):
        val = self._member_email_validator.validate(val)
        self._member_email_value = val
        self._member_email_present = True

    @member_email.deleter
    def member_email(self):
        self._member_email_value = None
        self._member_email_present = False

    @property
    def member_given_name(self):
        """
        Member's first name.

        :rtype: str
        """
        if self._member_given_name_present:
            return self._member_given_name_value
        else:
            raise AttributeError("missing required field 'member_given_name'")

    @member_given_name.setter
    def member_given_name(self, val):
        val = self._member_given_name_validator.validate(val)
        self._member_given_name_value = val
        self._member_given_name_present = True

    @member_given_name.deleter
    def member_given_name(self):
        self._member_given_name_value = None
        self._member_given_name_present = False

    @property
    def member_surname(self):
        """
        Member's last name.

        :rtype: str
        """
        if self._member_surname_present:
            return self._member_surname_value
        else:
            raise AttributeError("missing required field 'member_surname'")

    @member_surname.setter
    def member_surname(self, val):
        val = self._member_surname_validator.validate(val)
        self._member_surname_value = val
        self._member_surname_present = True

    @member_surname.deleter
    def member_surname(self):
        self._member_surname_value = None
        self._member_surname_present = False

    @property
    def member_external_id(self):
        """
        External ID for member.

        :rtype: str
        """
        if self._member_external_id_present:
            return self._member_external_id_value
        else:
            return None

    @member_external_id.setter
    def member_external_id(self, val):
        if val is None:
            del self.member_external_id
            return
        val = self._member_external_id_validator.validate(val)
        self._member_external_id_value = val
        self._member_external_id_present = True

    @member_external_id.deleter
    def member_external_id(self):
        self._member_external_id_value = None
        self._member_external_id_present = False

    @property
    def member_persistent_id(self):
        """
        Persistent ID for member. This field is only available to teams using
        persistent ID SAML configuration.

        :rtype: str
        """
        if self._member_persistent_id_present:
            return self._member_persistent_id_value
        else:
            return None

    @member_persistent_id.setter
    def member_persistent_id(self, val):
        if val is None:
            del self.member_persistent_id
            return
        val = self._member_persistent_id_validator.validate(val)
        self._member_persistent_id_value = val
        self._member_persistent_id_present = True

    @member_persistent_id.deleter
    def member_persistent_id(self):
        self._member_persistent_id_value = None
        self._member_persistent_id_present = False

    @property
    def send_welcome_email(self):
        """
        Whether to send a welcome email to the member. If send_welcome_email is
        false, no email invitation will be sent to the user. This may be useful
        for apps using single sign-on (SSO) flows for onboarding that want to
        handle announcements themselves.

        :rtype: bool
        """
        if self._send_welcome_email_present:
            return self._send_welcome_email_value
        else:
            return True

    @send_welcome_email.setter
    def send_welcome_email(self, val):
        val = self._send_welcome_email_validator.validate(val)
        self._send_welcome_email_value = val
        self._send_welcome_email_present = True

    @send_welcome_email.deleter
    def send_welcome_email(self):
        self._send_welcome_email_value = None
        self._send_welcome_email_present = False

    @property
    def role(self):
        """
        :rtype: AdminTier
        """
        if self._role_present:
            return self._role_value
        else:
            return AdminTier.member_only

    @role.setter
    def role(self, val):
        self._role_validator.validate_type_only(val)
        self._role_value = val
        self._role_present = True

    @role.deleter
    def role(self):
        self._role_value = None
        self._role_present = False

    def __repr__(self):
        return 'MemberAddArg(member_email={!r}, member_given_name={!r}, member_surname={!r}, member_external_id={!r}, member_persistent_id={!r}, send_welcome_email={!r}, role={!r})'.format(
            self._member_email_value,
            self._member_given_name_value,
            self._member_surname_value,
            self._member_external_id_value,
            self._member_persistent_id_value,
            self._send_welcome_email_value,
            self._role_value,
        )

MemberAddArg_validator = bv.Struct(MemberAddArg)

class MemberAddResult(bb.Union):
    """
    Describes the result of attempting to add a single user to the team.
    'success' is the only value indicating that a user was indeed added to the
    team - the other values explain the type of failure that occurred, and
    include the email of the user for which the operation has failed.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar TeamMemberInfo success: Describes a user that was successfully added
        to the team.
    :ivar str team_license_limit: Team is already full. The organization has no
        available licenses.
    :ivar str free_team_member_limit_reached: Team is already full. The free
        team member limit has been reached.
    :ivar str user_already_on_team: User is already on this team. The provided
        email address is associated with a user who is already a member of
        (including in recoverable state) or invited to the team.
    :ivar str user_on_another_team: User is already on another team. The
        provided email address is associated with a user that is already a
        member or invited to another team.
    :ivar str user_already_paired: User is already paired.
    :ivar str user_migration_failed: User migration has failed.
    :ivar str duplicate_external_member_id: A user with the given external
        member ID already exists on the team (including in recoverable state).
    :ivar str duplicate_member_persistent_id: A user with the given persistent
        ID already exists on the team (including in recoverable state).
    :ivar str persistent_id_disabled: Persistent ID is only available to teams
        with persistent ID SAML configuration. Please contact Dropbox for more
        information.
    :ivar str user_creation_failed: User creation has failed.
    """

    _catch_all = None

    @classmethod
    def success(cls, val):
        """
        Create an instance of this class set to the ``success`` tag with value
        ``val``.

        :param TeamMemberInfo val:
        :rtype: MemberAddResult
        """
        return cls('success', val)

    @classmethod
    def team_license_limit(cls, val):
        """
        Create an instance of this class set to the ``team_license_limit`` tag
        with value ``val``.

        :param str val:
        :rtype: MemberAddResult
        """
        return cls('team_license_limit', val)

    @classmethod
    def free_team_member_limit_reached(cls, val):
        """
        Create an instance of this class set to the
        ``free_team_member_limit_reached`` tag with value ``val``.

        :param str val:
        :rtype: MemberAddResult
        """
        return cls('free_team_member_limit_reached', val)

    @classmethod
    def user_already_on_team(cls, val):
        """
        Create an instance of this class set to the ``user_already_on_team`` tag
        with value ``val``.

        :param str val:
        :rtype: MemberAddResult
        """
        return cls('user_already_on_team', val)

    @classmethod
    def user_on_another_team(cls, val):
        """
        Create an instance of this class set to the ``user_on_another_team`` tag
        with value ``val``.

        :param str val:
        :rtype: MemberAddResult
        """
        return cls('user_on_another_team', val)

    @classmethod
    def user_already_paired(cls, val):
        """
        Create an instance of this class set to the ``user_already_paired`` tag
        with value ``val``.

        :param str val:
        :rtype: MemberAddResult
        """
        return cls('user_already_paired', val)

    @classmethod
    def user_migration_failed(cls, val):
        """
        Create an instance of this class set to the ``user_migration_failed``
        tag with value ``val``.

        :param str val:
        :rtype: MemberAddResult
        """
        return cls('user_migration_failed', val)

    @classmethod
    def duplicate_external_member_id(cls, val):
        """
        Create an instance of this class set to the
        ``duplicate_external_member_id`` tag with value ``val``.

        :param str val:
        :rtype: MemberAddResult
        """
        return cls('duplicate_external_member_id', val)

    @classmethod
    def duplicate_member_persistent_id(cls, val):
        """
        Create an instance of this class set to the
        ``duplicate_member_persistent_id`` tag with value ``val``.

        :param str val:
        :rtype: MemberAddResult
        """
        return cls('duplicate_member_persistent_id', val)

    @classmethod
    def persistent_id_disabled(cls, val):
        """
        Create an instance of this class set to the ``persistent_id_disabled``
        tag with value ``val``.

        :param str val:
        :rtype: MemberAddResult
        """
        return cls('persistent_id_disabled', val)

    @classmethod
    def user_creation_failed(cls, val):
        """
        Create an instance of this class set to the ``user_creation_failed`` tag
        with value ``val``.

        :param str val:
        :rtype: MemberAddResult
        """
        return cls('user_creation_failed', val)

    def is_success(self):
        """
        Check if the union tag is ``success``.

        :rtype: bool
        """
        return self._tag == 'success'

    def is_team_license_limit(self):
        """
        Check if the union tag is ``team_license_limit``.

        :rtype: bool
        """
        return self._tag == 'team_license_limit'

    def is_free_team_member_limit_reached(self):
        """
        Check if the union tag is ``free_team_member_limit_reached``.

        :rtype: bool
        """
        return self._tag == 'free_team_member_limit_reached'

    def is_user_already_on_team(self):
        """
        Check if the union tag is ``user_already_on_team``.

        :rtype: bool
        """
        return self._tag == 'user_already_on_team'

    def is_user_on_another_team(self):
        """
        Check if the union tag is ``user_on_another_team``.

        :rtype: bool
        """
        return self._tag == 'user_on_another_team'

    def is_user_already_paired(self):
        """
        Check if the union tag is ``user_already_paired``.

        :rtype: bool
        """
        return self._tag == 'user_already_paired'

    def is_user_migration_failed(self):
        """
        Check if the union tag is ``user_migration_failed``.

        :rtype: bool
        """
        return self._tag == 'user_migration_failed'

    def is_duplicate_external_member_id(self):
        """
        Check if the union tag is ``duplicate_external_member_id``.

        :rtype: bool
        """
        return self._tag == 'duplicate_external_member_id'

    def is_duplicate_member_persistent_id(self):
        """
        Check if the union tag is ``duplicate_member_persistent_id``.

        :rtype: bool
        """
        return self._tag == 'duplicate_member_persistent_id'

    def is_persistent_id_disabled(self):
        """
        Check if the union tag is ``persistent_id_disabled``.

        :rtype: bool
        """
        return self._tag == 'persistent_id_disabled'

    def is_user_creation_failed(self):
        """
        Check if the union tag is ``user_creation_failed``.

        :rtype: bool
        """
        return self._tag == 'user_creation_failed'

    def get_success(self):
        """
        Describes a user that was successfully added to the team.

        Only call this if :meth:`is_success` is true.

        :rtype: TeamMemberInfo
        """
        if not self.is_success():
            raise AttributeError("tag 'success' not set")
        return self._value

    def get_team_license_limit(self):
        """
        Team is already full. The organization has no available licenses.

        Only call this if :meth:`is_team_license_limit` is true.

        :rtype: str
        """
        if not self.is_team_license_limit():
            raise AttributeError("tag 'team_license_limit' not set")
        return self._value

    def get_free_team_member_limit_reached(self):
        """
        Team is already full. The free team member limit has been reached.

        Only call this if :meth:`is_free_team_member_limit_reached` is true.

        :rtype: str
        """
        if not self.is_free_team_member_limit_reached():
            raise AttributeError("tag 'free_team_member_limit_reached' not set")
        return self._value

    def get_user_already_on_team(self):
        """
        User is already on this team. The provided email address is associated
        with a user who is already a member of (including in recoverable state)
        or invited to the team.

        Only call this if :meth:`is_user_already_on_team` is true.

        :rtype: str
        """
        if not self.is_user_already_on_team():
            raise AttributeError("tag 'user_already_on_team' not set")
        return self._value

    def get_user_on_another_team(self):
        """
        User is already on another team. The provided email address is
        associated with a user that is already a member or invited to another
        team.

        Only call this if :meth:`is_user_on_another_team` is true.

        :rtype: str
        """
        if not self.is_user_on_another_team():
            raise AttributeError("tag 'user_on_another_team' not set")
        return self._value

    def get_user_already_paired(self):
        """
        User is already paired.

        Only call this if :meth:`is_user_already_paired` is true.

        :rtype: str
        """
        if not self.is_user_already_paired():
            raise AttributeError("tag 'user_already_paired' not set")
        return self._value

    def get_user_migration_failed(self):
        """
        User migration has failed.

        Only call this if :meth:`is_user_migration_failed` is true.

        :rtype: str
        """
        if not self.is_user_migration_failed():
            raise AttributeError("tag 'user_migration_failed' not set")
        return self._value

    def get_duplicate_external_member_id(self):
        """
        A user with the given external member ID already exists on the team
        (including in recoverable state).

        Only call this if :meth:`is_duplicate_external_member_id` is true.

        :rtype: str
        """
        if not self.is_duplicate_external_member_id():
            raise AttributeError("tag 'duplicate_external_member_id' not set")
        return self._value

    def get_duplicate_member_persistent_id(self):
        """
        A user with the given persistent ID already exists on the team
        (including in recoverable state).

        Only call this if :meth:`is_duplicate_member_persistent_id` is true.

        :rtype: str
        """
        if not self.is_duplicate_member_persistent_id():
            raise AttributeError("tag 'duplicate_member_persistent_id' not set")
        return self._value

    def get_persistent_id_disabled(self):
        """
        Persistent ID is only available to teams with persistent ID SAML
        configuration. Please contact Dropbox for more information.

        Only call this if :meth:`is_persistent_id_disabled` is true.

        :rtype: str
        """
        if not self.is_persistent_id_disabled():
            raise AttributeError("tag 'persistent_id_disabled' not set")
        return self._value

    def get_user_creation_failed(self):
        """
        User creation has failed.

        Only call this if :meth:`is_user_creation_failed` is true.

        :rtype: str
        """
        if not self.is_user_creation_failed():
            raise AttributeError("tag 'user_creation_failed' not set")
        return self._value

    def __repr__(self):
        return 'MemberAddResult(%r, %r)' % (self._tag, self._value)

MemberAddResult_validator = bv.Union(MemberAddResult)

class MemberDevices(object):
    """
    Information on devices of a team's member.

    :ivar team_member_id: The member unique Id
    :ivar web_sessions: List of web sessions made by this team member
    :ivar desktop_clients: List of desktop clients by this team member
    :ivar mobile_clients: List of mobile clients by this team member
    """

    __slots__ = [
        '_team_member_id_value',
        '_team_member_id_present',
        '_web_sessions_value',
        '_web_sessions_present',
        '_desktop_clients_value',
        '_desktop_clients_present',
        '_mobile_clients_value',
        '_mobile_clients_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_member_id=None,
                 web_sessions=None,
                 desktop_clients=None,
                 mobile_clients=None):
        self._team_member_id_value = None
        self._team_member_id_present = False
        self._web_sessions_value = None
        self._web_sessions_present = False
        self._desktop_clients_value = None
        self._desktop_clients_present = False
        self._mobile_clients_value = None
        self._mobile_clients_present = False
        if team_member_id is not None:
            self.team_member_id = team_member_id
        if web_sessions is not None:
            self.web_sessions = web_sessions
        if desktop_clients is not None:
            self.desktop_clients = desktop_clients
        if mobile_clients is not None:
            self.mobile_clients = mobile_clients

    @property
    def team_member_id(self):
        """
        The member unique Id

        :rtype: str
        """
        if self._team_member_id_present:
            return self._team_member_id_value
        else:
            raise AttributeError("missing required field 'team_member_id'")

    @team_member_id.setter
    def team_member_id(self, val):
        val = self._team_member_id_validator.validate(val)
        self._team_member_id_value = val
        self._team_member_id_present = True

    @team_member_id.deleter
    def team_member_id(self):
        self._team_member_id_value = None
        self._team_member_id_present = False

    @property
    def web_sessions(self):
        """
        List of web sessions made by this team member

        :rtype: list of [ActiveWebSession]
        """
        if self._web_sessions_present:
            return self._web_sessions_value
        else:
            return None

    @web_sessions.setter
    def web_sessions(self, val):
        if val is None:
            del self.web_sessions
            return
        val = self._web_sessions_validator.validate(val)
        self._web_sessions_value = val
        self._web_sessions_present = True

    @web_sessions.deleter
    def web_sessions(self):
        self._web_sessions_value = None
        self._web_sessions_present = False

    @property
    def desktop_clients(self):
        """
        List of desktop clients by this team member

        :rtype: list of [DesktopClientSession]
        """
        if self._desktop_clients_present:
            return self._desktop_clients_value
        else:
            return None

    @desktop_clients.setter
    def desktop_clients(self, val):
        if val is None:
            del self.desktop_clients
            return
        val = self._desktop_clients_validator.validate(val)
        self._desktop_clients_value = val
        self._desktop_clients_present = True

    @desktop_clients.deleter
    def desktop_clients(self):
        self._desktop_clients_value = None
        self._desktop_clients_present = False

    @property
    def mobile_clients(self):
        """
        List of mobile clients by this team member

        :rtype: list of [MobileClientSession]
        """
        if self._mobile_clients_present:
            return self._mobile_clients_value
        else:
            return None

    @mobile_clients.setter
    def mobile_clients(self, val):
        if val is None:
            del self.mobile_clients
            return
        val = self._mobile_clients_validator.validate(val)
        self._mobile_clients_value = val
        self._mobile_clients_present = True

    @mobile_clients.deleter
    def mobile_clients(self):
        self._mobile_clients_value = None
        self._mobile_clients_present = False

    def __repr__(self):
        return 'MemberDevices(team_member_id={!r}, web_sessions={!r}, desktop_clients={!r}, mobile_clients={!r})'.format(
            self._team_member_id_value,
            self._web_sessions_value,
            self._desktop_clients_value,
            self._mobile_clients_value,
        )

MemberDevices_validator = bv.Struct(MemberDevices)

class MemberLinkedApps(object):
    """
    Information on linked applications of a team member.

    :ivar team_member_id: The member unique Id
    :ivar linked_api_apps: List of third party applications linked by this team
        member
    """

    __slots__ = [
        '_team_member_id_value',
        '_team_member_id_present',
        '_linked_api_apps_value',
        '_linked_api_apps_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_member_id=None,
                 linked_api_apps=None):
        self._team_member_id_value = None
        self._team_member_id_present = False
        self._linked_api_apps_value = None
        self._linked_api_apps_present = False
        if team_member_id is not None:
            self.team_member_id = team_member_id
        if linked_api_apps is not None:
            self.linked_api_apps = linked_api_apps

    @property
    def team_member_id(self):
        """
        The member unique Id

        :rtype: str
        """
        if self._team_member_id_present:
            return self._team_member_id_value
        else:
            raise AttributeError("missing required field 'team_member_id'")

    @team_member_id.setter
    def team_member_id(self, val):
        val = self._team_member_id_validator.validate(val)
        self._team_member_id_value = val
        self._team_member_id_present = True

    @team_member_id.deleter
    def team_member_id(self):
        self._team_member_id_value = None
        self._team_member_id_present = False

    @property
    def linked_api_apps(self):
        """
        List of third party applications linked by this team member

        :rtype: list of [ApiApp]
        """
        if self._linked_api_apps_present:
            return self._linked_api_apps_value
        else:
            raise AttributeError("missing required field 'linked_api_apps'")

    @linked_api_apps.setter
    def linked_api_apps(self, val):
        val = self._linked_api_apps_validator.validate(val)
        self._linked_api_apps_value = val
        self._linked_api_apps_present = True

    @linked_api_apps.deleter
    def linked_api_apps(self):
        self._linked_api_apps_value = None
        self._linked_api_apps_present = False

    def __repr__(self):
        return 'MemberLinkedApps(team_member_id={!r}, linked_api_apps={!r})'.format(
            self._team_member_id_value,
            self._linked_api_apps_value,
        )

MemberLinkedApps_validator = bv.Struct(MemberLinkedApps)

class MemberProfile(object):
    """
    Basic member profile.

    :ivar team_member_id: ID of user as a member of a team.
    :ivar external_id: External ID that a team can attach to the user. An
        application using the API may find it easier to use their own IDs
        instead of Dropbox IDs like account_id or team_member_id.
    :ivar account_id: A user's account identifier.
    :ivar email: Email address of user.
    :ivar email_verified: Is true if the user's email is verified to be owned by
        the user.
    :ivar status: The user's status as a member of a specific team.
    :ivar name: Representations for a person's name.
    :ivar membership_type: The user's membership type: full (normal team member)
        vs limited (does not use a license; no access to the team's shared
        quota).
    :ivar joined_on: The date and time the user joined as a member of a specific
        team.
    :ivar persistent_id: Persistent ID that a team can attach to the user. The
        persistent ID is unique ID to be used for SAML authentication.
    """

    __slots__ = [
        '_team_member_id_value',
        '_team_member_id_present',
        '_external_id_value',
        '_external_id_present',
        '_account_id_value',
        '_account_id_present',
        '_email_value',
        '_email_present',
        '_email_verified_value',
        '_email_verified_present',
        '_status_value',
        '_status_present',
        '_name_value',
        '_name_present',
        '_membership_type_value',
        '_membership_type_present',
        '_joined_on_value',
        '_joined_on_present',
        '_persistent_id_value',
        '_persistent_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_member_id=None,
                 email=None,
                 email_verified=None,
                 status=None,
                 name=None,
                 membership_type=None,
                 external_id=None,
                 account_id=None,
                 joined_on=None,
                 persistent_id=None):
        self._team_member_id_value = None
        self._team_member_id_present = False
        self._external_id_value = None
        self._external_id_present = False
        self._account_id_value = None
        self._account_id_present = False
        self._email_value = None
        self._email_present = False
        self._email_verified_value = None
        self._email_verified_present = False
        self._status_value = None
        self._status_present = False
        self._name_value = None
        self._name_present = False
        self._membership_type_value = None
        self._membership_type_present = False
        self._joined_on_value = None
        self._joined_on_present = False
        self._persistent_id_value = None
        self._persistent_id_present = False
        if team_member_id is not None:
            self.team_member_id = team_member_id
        if external_id is not None:
            self.external_id = external_id
        if account_id is not None:
            self.account_id = account_id
        if email is not None:
            self.email = email
        if email_verified is not None:
            self.email_verified = email_verified
        if status is not None:
            self.status = status
        if name is not None:
            self.name = name
        if membership_type is not None:
            self.membership_type = membership_type
        if joined_on is not None:
            self.joined_on = joined_on
        if persistent_id is not None:
            self.persistent_id = persistent_id

    @property
    def team_member_id(self):
        """
        ID of user as a member of a team.

        :rtype: str
        """
        if self._team_member_id_present:
            return self._team_member_id_value
        else:
            raise AttributeError("missing required field 'team_member_id'")

    @team_member_id.setter
    def team_member_id(self, val):
        val = self._team_member_id_validator.validate(val)
        self._team_member_id_value = val
        self._team_member_id_present = True

    @team_member_id.deleter
    def team_member_id(self):
        self._team_member_id_value = None
        self._team_member_id_present = False

    @property
    def external_id(self):
        """
        External ID that a team can attach to the user. An application using the
        API may find it easier to use their own IDs instead of Dropbox IDs like
        account_id or team_member_id.

        :rtype: str
        """
        if self._external_id_present:
            return self._external_id_value
        else:
            return None

    @external_id.setter
    def external_id(self, val):
        if val is None:
            del self.external_id
            return
        val = self._external_id_validator.validate(val)
        self._external_id_value = val
        self._external_id_present = True

    @external_id.deleter
    def external_id(self):
        self._external_id_value = None
        self._external_id_present = False

    @property
    def account_id(self):
        """
        A user's account identifier.

        :rtype: str
        """
        if self._account_id_present:
            return self._account_id_value
        else:
            return None

    @account_id.setter
    def account_id(self, val):
        if val is None:
            del self.account_id
            return
        val = self._account_id_validator.validate(val)
        self._account_id_value = val
        self._account_id_present = True

    @account_id.deleter
    def account_id(self):
        self._account_id_value = None
        self._account_id_present = False

    @property
    def email(self):
        """
        Email address of user.

        :rtype: str
        """
        if self._email_present:
            return self._email_value
        else:
            raise AttributeError("missing required field 'email'")

    @email.setter
    def email(self, val):
        val = self._email_validator.validate(val)
        self._email_value = val
        self._email_present = True

    @email.deleter
    def email(self):
        self._email_value = None
        self._email_present = False

    @property
    def email_verified(self):
        """
        Is true if the user's email is verified to be owned by the user.

        :rtype: bool
        """
        if self._email_verified_present:
            return self._email_verified_value
        else:
            raise AttributeError("missing required field 'email_verified'")

    @email_verified.setter
    def email_verified(self, val):
        val = self._email_verified_validator.validate(val)
        self._email_verified_value = val
        self._email_verified_present = True

    @email_verified.deleter
    def email_verified(self):
        self._email_verified_value = None
        self._email_verified_present = False

    @property
    def status(self):
        """
        The user's status as a member of a specific team.

        :rtype: TeamMemberStatus
        """
        if self._status_present:
            return self._status_value
        else:
            raise AttributeError("missing required field 'status'")

    @status.setter
    def status(self, val):
        self._status_validator.validate_type_only(val)
        self._status_value = val
        self._status_present = True

    @status.deleter
    def status(self):
        self._status_value = None
        self._status_present = False

    @property
    def name(self):
        """
        Representations for a person's name.

        :rtype: users.Name_validator
        """
        if self._name_present:
            return self._name_value
        else:
            raise AttributeError("missing required field 'name'")

    @name.setter
    def name(self, val):
        self._name_validator.validate_type_only(val)
        self._name_value = val
        self._name_present = True

    @name.deleter
    def name(self):
        self._name_value = None
        self._name_present = False

    @property
    def membership_type(self):
        """
        The user's membership type: full (normal team member) vs limited (does
        not use a license; no access to the team's shared quota).

        :rtype: TeamMembershipType
        """
        if self._membership_type_present:
            return self._membership_type_value
        else:
            raise AttributeError("missing required field 'membership_type'")

    @membership_type.setter
    def membership_type(self, val):
        self._membership_type_validator.validate_type_only(val)
        self._membership_type_value = val
        self._membership_type_present = True

    @membership_type.deleter
    def membership_type(self):
        self._membership_type_value = None
        self._membership_type_present = False

    @property
    def joined_on(self):
        """
        The date and time the user joined as a member of a specific team.

        :rtype: datetime.datetime
        """
        if self._joined_on_present:
            return self._joined_on_value
        else:
            return None

    @joined_on.setter
    def joined_on(self, val):
        if val is None:
            del self.joined_on
            return
        val = self._joined_on_validator.validate(val)
        self._joined_on_value = val
        self._joined_on_present = True

    @joined_on.deleter
    def joined_on(self):
        self._joined_on_value = None
        self._joined_on_present = False

    @property
    def persistent_id(self):
        """
        Persistent ID that a team can attach to the user. The persistent ID is
        unique ID to be used for SAML authentication.

        :rtype: str
        """
        if self._persistent_id_present:
            return self._persistent_id_value
        else:
            return None

    @persistent_id.setter
    def persistent_id(self, val):
        if val is None:
            del self.persistent_id
            return
        val = self._persistent_id_validator.validate(val)
        self._persistent_id_value = val
        self._persistent_id_present = True

    @persistent_id.deleter
    def persistent_id(self):
        self._persistent_id_value = None
        self._persistent_id_present = False

    def __repr__(self):
        return 'MemberProfile(team_member_id={!r}, email={!r}, email_verified={!r}, status={!r}, name={!r}, membership_type={!r}, external_id={!r}, account_id={!r}, joined_on={!r}, persistent_id={!r})'.format(
            self._team_member_id_value,
            self._email_value,
            self._email_verified_value,
            self._status_value,
            self._name_value,
            self._membership_type_value,
            self._external_id_value,
            self._account_id_value,
            self._joined_on_value,
            self._persistent_id_value,
        )

MemberProfile_validator = bv.Struct(MemberProfile)

class UserSelectorError(bb.Union):
    """
    Error that can be returned whenever a struct derived from
    :class:`UserSelectorArg` is used.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar user_not_found: No matching user found. The provided team_member_id,
        email, or external_id does not exist on this team.
    """

    _catch_all = None
    # Attribute is overwritten below the class definition
    user_not_found = None

    def is_user_not_found(self):
        """
        Check if the union tag is ``user_not_found``.

        :rtype: bool
        """
        return self._tag == 'user_not_found'

    def __repr__(self):
        return 'UserSelectorError(%r, %r)' % (self._tag, self._value)

UserSelectorError_validator = bv.Union(UserSelectorError)

class MemberSelectorError(UserSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar user_not_in_team: The user is not a member of the team.
    """

    # Attribute is overwritten below the class definition
    user_not_in_team = None

    def is_user_not_in_team(self):
        """
        Check if the union tag is ``user_not_in_team``.

        :rtype: bool
        """
        return self._tag == 'user_not_in_team'

    def __repr__(self):
        return 'MemberSelectorError(%r, %r)' % (self._tag, self._value)

MemberSelectorError_validator = bv.Union(MemberSelectorError)

class MembersAddArg(object):
    """
    :ivar new_members: Details of new members to be added to the team.
    :ivar force_async: Whether to force the add to happen asynchronously.
    """

    __slots__ = [
        '_new_members_value',
        '_new_members_present',
        '_force_async_value',
        '_force_async_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 new_members=None,
                 force_async=None):
        self._new_members_value = None
        self._new_members_present = False
        self._force_async_value = None
        self._force_async_present = False
        if new_members is not None:
            self.new_members = new_members
        if force_async is not None:
            self.force_async = force_async

    @property
    def new_members(self):
        """
        Details of new members to be added to the team.

        :rtype: list of [MemberAddArg]
        """
        if self._new_members_present:
            return self._new_members_value
        else:
            raise AttributeError("missing required field 'new_members'")

    @new_members.setter
    def new_members(self, val):
        val = self._new_members_validator.validate(val)
        self._new_members_value = val
        self._new_members_present = True

    @new_members.deleter
    def new_members(self):
        self._new_members_value = None
        self._new_members_present = False

    @property
    def force_async(self):
        """
        Whether to force the add to happen asynchronously.

        :rtype: bool
        """
        if self._force_async_present:
            return self._force_async_value
        else:
            return False

    @force_async.setter
    def force_async(self, val):
        val = self._force_async_validator.validate(val)
        self._force_async_value = val
        self._force_async_present = True

    @force_async.deleter
    def force_async(self):
        self._force_async_value = None
        self._force_async_present = False

    def __repr__(self):
        return 'MembersAddArg(new_members={!r}, force_async={!r})'.format(
            self._new_members_value,
            self._force_async_value,
        )

MembersAddArg_validator = bv.Struct(MembersAddArg)

class MembersAddJobStatus(async.PollResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar list of [MemberAddResult] complete: The asynchronous job has finished.
        For each member that was specified in the parameter
        :type:`MembersAddArg` that was provided to :route:`members/add`, a
        corresponding item is returned in this list.
    :ivar str failed: The asynchronous job returned an error. The string
        contains an error message.
    """

    @classmethod
    def complete(cls, val):
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param list of [MemberAddResult] val:
        :rtype: MembersAddJobStatus
        """
        return cls('complete', val)

    @classmethod
    def failed(cls, val):
        """
        Create an instance of this class set to the ``failed`` tag with value
        ``val``.

        :param str val:
        :rtype: MembersAddJobStatus
        """
        return cls('failed', val)

    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        return self._tag == 'complete'

    def is_failed(self):
        """
        Check if the union tag is ``failed``.

        :rtype: bool
        """
        return self._tag == 'failed'

    def get_complete(self):
        """
        The asynchronous job has finished. For each member that was specified in
        the parameter :class:`MembersAddArg` that was provided to
        :meth:`dropbox.dropbox.Dropbox.team_members_add`, a corresponding item
        is returned in this list.

        Only call this if :meth:`is_complete` is true.

        :rtype: list of [MemberAddResult]
        """
        if not self.is_complete():
            raise AttributeError("tag 'complete' not set")
        return self._value

    def get_failed(self):
        """
        The asynchronous job returned an error. The string contains an error
        message.

        Only call this if :meth:`is_failed` is true.

        :rtype: str
        """
        if not self.is_failed():
            raise AttributeError("tag 'failed' not set")
        return self._value

    def __repr__(self):
        return 'MembersAddJobStatus(%r, %r)' % (self._tag, self._value)

MembersAddJobStatus_validator = bv.Union(MembersAddJobStatus)

class MembersAddLaunch(async.LaunchResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    @classmethod
    def complete(cls, val):
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param list of [MemberAddResult] val:
        :rtype: MembersAddLaunch
        """
        return cls('complete', val)

    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        return self._tag == 'complete'

    def get_complete(self):
        """
        Only call this if :meth:`is_complete` is true.

        :rtype: list of [MemberAddResult]
        """
        if not self.is_complete():
            raise AttributeError("tag 'complete' not set")
        return self._value

    def __repr__(self):
        return 'MembersAddLaunch(%r, %r)' % (self._tag, self._value)

MembersAddLaunch_validator = bv.Union(MembersAddLaunch)

class MembersDeactivateArg(object):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account.

    :ivar user: Identity of user to remove/suspend.
    :ivar wipe_data: If provided, controls if the user's data will be deleted on
        their linked devices.
    """

    __slots__ = [
        '_user_value',
        '_user_present',
        '_wipe_data_value',
        '_wipe_data_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user=None,
                 wipe_data=None):
        self._user_value = None
        self._user_present = False
        self._wipe_data_value = None
        self._wipe_data_present = False
        if user is not None:
            self.user = user
        if wipe_data is not None:
            self.wipe_data = wipe_data

    @property
    def user(self):
        """
        Identity of user to remove/suspend.

        :rtype: UserSelectorArg
        """
        if self._user_present:
            return self._user_value
        else:
            raise AttributeError("missing required field 'user'")

    @user.setter
    def user(self, val):
        self._user_validator.validate_type_only(val)
        self._user_value = val
        self._user_present = True

    @user.deleter
    def user(self):
        self._user_value = None
        self._user_present = False

    @property
    def wipe_data(self):
        """
        If provided, controls if the user's data will be deleted on their linked
        devices.

        :rtype: bool
        """
        if self._wipe_data_present:
            return self._wipe_data_value
        else:
            return True

    @wipe_data.setter
    def wipe_data(self, val):
        val = self._wipe_data_validator.validate(val)
        self._wipe_data_value = val
        self._wipe_data_present = True

    @wipe_data.deleter
    def wipe_data(self):
        self._wipe_data_value = None
        self._wipe_data_present = False

    def __repr__(self):
        return 'MembersDeactivateArg(user={!r}, wipe_data={!r})'.format(
            self._user_value,
            self._wipe_data_value,
        )

MembersDeactivateArg_validator = bv.Struct(MembersDeactivateArg)

class MembersDeactivateError(UserSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar user_not_in_team: The user is not a member of the team.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    user_not_in_team = None
    # Attribute is overwritten below the class definition
    other = None

    def is_user_not_in_team(self):
        """
        Check if the union tag is ``user_not_in_team``.

        :rtype: bool
        """
        return self._tag == 'user_not_in_team'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersDeactivateError(%r, %r)' % (self._tag, self._value)

MembersDeactivateError_validator = bv.Union(MembersDeactivateError)

class MembersGetInfoArgs(object):
    """
    :ivar members: List of team members.
    """

    __slots__ = [
        '_members_value',
        '_members_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 members=None):
        self._members_value = None
        self._members_present = False
        if members is not None:
            self.members = members

    @property
    def members(self):
        """
        List of team members.

        :rtype: list of [UserSelectorArg]
        """
        if self._members_present:
            return self._members_value
        else:
            raise AttributeError("missing required field 'members'")

    @members.setter
    def members(self, val):
        val = self._members_validator.validate(val)
        self._members_value = val
        self._members_present = True

    @members.deleter
    def members(self):
        self._members_value = None
        self._members_present = False

    def __repr__(self):
        return 'MembersGetInfoArgs(members={!r})'.format(
            self._members_value,
        )

MembersGetInfoArgs_validator = bv.Struct(MembersGetInfoArgs)

class MembersGetInfoError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersGetInfoError(%r, %r)' % (self._tag, self._value)

MembersGetInfoError_validator = bv.Union(MembersGetInfoError)

class MembersGetInfoItem(bb.Union):
    """
    Describes a result obtained for a single user whose id was specified in the
    parameter of :meth:`dropbox.dropbox.Dropbox.team_members_get_info`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str id_not_found: An ID that was provided as a parameter to
        :route:`members/get_info`, and did not match a corresponding user. This
        might be a team_member_id, an email, or an external ID, depending on how
        the method was called.
    :ivar TeamMemberInfo member_info: Info about a team member.
    """

    _catch_all = None

    @classmethod
    def id_not_found(cls, val):
        """
        Create an instance of this class set to the ``id_not_found`` tag with
        value ``val``.

        :param str val:
        :rtype: MembersGetInfoItem
        """
        return cls('id_not_found', val)

    @classmethod
    def member_info(cls, val):
        """
        Create an instance of this class set to the ``member_info`` tag with
        value ``val``.

        :param TeamMemberInfo val:
        :rtype: MembersGetInfoItem
        """
        return cls('member_info', val)

    def is_id_not_found(self):
        """
        Check if the union tag is ``id_not_found``.

        :rtype: bool
        """
        return self._tag == 'id_not_found'

    def is_member_info(self):
        """
        Check if the union tag is ``member_info``.

        :rtype: bool
        """
        return self._tag == 'member_info'

    def get_id_not_found(self):
        """
        An ID that was provided as a parameter to
        :meth:`dropbox.dropbox.Dropbox.team_members_get_info`, and did not match
        a corresponding user. This might be a team_member_id, an email, or an
        external ID, depending on how the method was called.

        Only call this if :meth:`is_id_not_found` is true.

        :rtype: str
        """
        if not self.is_id_not_found():
            raise AttributeError("tag 'id_not_found' not set")
        return self._value

    def get_member_info(self):
        """
        Info about a team member.

        Only call this if :meth:`is_member_info` is true.

        :rtype: TeamMemberInfo
        """
        if not self.is_member_info():
            raise AttributeError("tag 'member_info' not set")
        return self._value

    def __repr__(self):
        return 'MembersGetInfoItem(%r, %r)' % (self._tag, self._value)

MembersGetInfoItem_validator = bv.Union(MembersGetInfoItem)

class MembersListArg(object):
    """
    :ivar limit: Number of results to return per call.
    :ivar include_removed: Whether to return removed members.
    """

    __slots__ = [
        '_limit_value',
        '_limit_present',
        '_include_removed_value',
        '_include_removed_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 limit=None,
                 include_removed=None):
        self._limit_value = None
        self._limit_present = False
        self._include_removed_value = None
        self._include_removed_present = False
        if limit is not None:
            self.limit = limit
        if include_removed is not None:
            self.include_removed = include_removed

    @property
    def limit(self):
        """
        Number of results to return per call.

        :rtype: long
        """
        if self._limit_present:
            return self._limit_value
        else:
            return 1000

    @limit.setter
    def limit(self, val):
        val = self._limit_validator.validate(val)
        self._limit_value = val
        self._limit_present = True

    @limit.deleter
    def limit(self):
        self._limit_value = None
        self._limit_present = False

    @property
    def include_removed(self):
        """
        Whether to return removed members.

        :rtype: bool
        """
        if self._include_removed_present:
            return self._include_removed_value
        else:
            return False

    @include_removed.setter
    def include_removed(self, val):
        val = self._include_removed_validator.validate(val)
        self._include_removed_value = val
        self._include_removed_present = True

    @include_removed.deleter
    def include_removed(self):
        self._include_removed_value = None
        self._include_removed_present = False

    def __repr__(self):
        return 'MembersListArg(limit={!r}, include_removed={!r})'.format(
            self._limit_value,
            self._include_removed_value,
        )

MembersListArg_validator = bv.Struct(MembersListArg)

class MembersListContinueArg(object):
    """
    :ivar cursor: Indicates from what point to get the next set of members.
    """

    __slots__ = [
        '_cursor_value',
        '_cursor_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 cursor=None):
        self._cursor_value = None
        self._cursor_present = False
        if cursor is not None:
            self.cursor = cursor

    @property
    def cursor(self):
        """
        Indicates from what point to get the next set of members.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            raise AttributeError("missing required field 'cursor'")

    @cursor.setter
    def cursor(self, val):
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    def __repr__(self):
        return 'MembersListContinueArg(cursor={!r})'.format(
            self._cursor_value,
        )

MembersListContinueArg_validator = bv.Struct(MembersListContinueArg)

class MembersListContinueError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar invalid_cursor: The cursor is invalid.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    invalid_cursor = None
    # Attribute is overwritten below the class definition
    other = None

    def is_invalid_cursor(self):
        """
        Check if the union tag is ``invalid_cursor``.

        :rtype: bool
        """
        return self._tag == 'invalid_cursor'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersListContinueError(%r, %r)' % (self._tag, self._value)

MembersListContinueError_validator = bv.Union(MembersListContinueError)

class MembersListError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersListError(%r, %r)' % (self._tag, self._value)

MembersListError_validator = bv.Union(MembersListError)

class MembersListResult(object):
    """
    :ivar members: List of team members.
    :ivar cursor: Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_members_list_continue` to obtain the
        additional members.
    :ivar has_more: Is true if there are additional team members that have not
        been returned yet. An additional call to
        :meth:`dropbox.dropbox.Dropbox.team_members_list_continue` can retrieve
        them.
    """

    __slots__ = [
        '_members_value',
        '_members_present',
        '_cursor_value',
        '_cursor_present',
        '_has_more_value',
        '_has_more_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 members=None,
                 cursor=None,
                 has_more=None):
        self._members_value = None
        self._members_present = False
        self._cursor_value = None
        self._cursor_present = False
        self._has_more_value = None
        self._has_more_present = False
        if members is not None:
            self.members = members
        if cursor is not None:
            self.cursor = cursor
        if has_more is not None:
            self.has_more = has_more

    @property
    def members(self):
        """
        List of team members.

        :rtype: list of [TeamMemberInfo]
        """
        if self._members_present:
            return self._members_value
        else:
            raise AttributeError("missing required field 'members'")

    @members.setter
    def members(self, val):
        val = self._members_validator.validate(val)
        self._members_value = val
        self._members_present = True

    @members.deleter
    def members(self):
        self._members_value = None
        self._members_present = False

    @property
    def cursor(self):
        """
        Pass the cursor into
        :meth:`dropbox.dropbox.Dropbox.team_members_list_continue` to obtain the
        additional members.

        :rtype: str
        """
        if self._cursor_present:
            return self._cursor_value
        else:
            raise AttributeError("missing required field 'cursor'")

    @cursor.setter
    def cursor(self, val):
        val = self._cursor_validator.validate(val)
        self._cursor_value = val
        self._cursor_present = True

    @cursor.deleter
    def cursor(self):
        self._cursor_value = None
        self._cursor_present = False

    @property
    def has_more(self):
        """
        Is true if there are additional team members that have not been returned
        yet. An additional call to
        :meth:`dropbox.dropbox.Dropbox.team_members_list_continue` can retrieve
        them.

        :rtype: bool
        """
        if self._has_more_present:
            return self._has_more_value
        else:
            raise AttributeError("missing required field 'has_more'")

    @has_more.setter
    def has_more(self, val):
        val = self._has_more_validator.validate(val)
        self._has_more_value = val
        self._has_more_present = True

    @has_more.deleter
    def has_more(self):
        self._has_more_value = None
        self._has_more_present = False

    def __repr__(self):
        return 'MembersListResult(members={!r}, cursor={!r}, has_more={!r})'.format(
            self._members_value,
            self._cursor_value,
            self._has_more_value,
        )

MembersListResult_validator = bv.Struct(MembersListResult)

class MembersRecoverArg(object):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account.

    :ivar user: Identity of user to recover.
    """

    __slots__ = [
        '_user_value',
        '_user_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user=None):
        self._user_value = None
        self._user_present = False
        if user is not None:
            self.user = user

    @property
    def user(self):
        """
        Identity of user to recover.

        :rtype: UserSelectorArg
        """
        if self._user_present:
            return self._user_value
        else:
            raise AttributeError("missing required field 'user'")

    @user.setter
    def user(self, val):
        self._user_validator.validate_type_only(val)
        self._user_value = val
        self._user_present = True

    @user.deleter
    def user(self):
        self._user_value = None
        self._user_present = False

    def __repr__(self):
        return 'MembersRecoverArg(user={!r})'.format(
            self._user_value,
        )

MembersRecoverArg_validator = bv.Struct(MembersRecoverArg)

class MembersRecoverError(UserSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar user_unrecoverable: The user is not recoverable.
    :ivar user_not_in_team: The user is not a member of the team.
    :ivar team_license_limit: Team is full. The organization has no available
        licenses.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    user_unrecoverable = None
    # Attribute is overwritten below the class definition
    user_not_in_team = None
    # Attribute is overwritten below the class definition
    team_license_limit = None
    # Attribute is overwritten below the class definition
    other = None

    def is_user_unrecoverable(self):
        """
        Check if the union tag is ``user_unrecoverable``.

        :rtype: bool
        """
        return self._tag == 'user_unrecoverable'

    def is_user_not_in_team(self):
        """
        Check if the union tag is ``user_not_in_team``.

        :rtype: bool
        """
        return self._tag == 'user_not_in_team'

    def is_team_license_limit(self):
        """
        Check if the union tag is ``team_license_limit``.

        :rtype: bool
        """
        return self._tag == 'team_license_limit'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersRecoverError(%r, %r)' % (self._tag, self._value)

MembersRecoverError_validator = bv.Union(MembersRecoverError)

class MembersRemoveArg(MembersDeactivateArg):
    """
    :ivar transfer_dest_id: If provided, files from the deleted member account
        will be transferred to this user.
    :ivar transfer_admin_id: If provided, errors during the transfer process
        will be sent via email to this user. If the transfer_dest_id argument
        was provided, then this argument must be provided as well.
    :ivar keep_account: Downgrade the member to a Basic account. The user will
        retain the email address associated with their Dropbox  account and data
        in their account that is not restricted to team members. In order to
        keep the account the argument wipe_data should be set to False.
    """

    __slots__ = [
        '_transfer_dest_id_value',
        '_transfer_dest_id_present',
        '_transfer_admin_id_value',
        '_transfer_admin_id_present',
        '_keep_account_value',
        '_keep_account_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user=None,
                 wipe_data=None,
                 transfer_dest_id=None,
                 transfer_admin_id=None,
                 keep_account=None):
        super(MembersRemoveArg, self).__init__(user,
                                               wipe_data)
        self._transfer_dest_id_value = None
        self._transfer_dest_id_present = False
        self._transfer_admin_id_value = None
        self._transfer_admin_id_present = False
        self._keep_account_value = None
        self._keep_account_present = False
        if transfer_dest_id is not None:
            self.transfer_dest_id = transfer_dest_id
        if transfer_admin_id is not None:
            self.transfer_admin_id = transfer_admin_id
        if keep_account is not None:
            self.keep_account = keep_account

    @property
    def transfer_dest_id(self):
        """
        If provided, files from the deleted member account will be transferred
        to this user.

        :rtype: UserSelectorArg
        """
        if self._transfer_dest_id_present:
            return self._transfer_dest_id_value
        else:
            return None

    @transfer_dest_id.setter
    def transfer_dest_id(self, val):
        if val is None:
            del self.transfer_dest_id
            return
        self._transfer_dest_id_validator.validate_type_only(val)
        self._transfer_dest_id_value = val
        self._transfer_dest_id_present = True

    @transfer_dest_id.deleter
    def transfer_dest_id(self):
        self._transfer_dest_id_value = None
        self._transfer_dest_id_present = False

    @property
    def transfer_admin_id(self):
        """
        If provided, errors during the transfer process will be sent via email
        to this user. If the transfer_dest_id argument was provided, then this
        argument must be provided as well.

        :rtype: UserSelectorArg
        """
        if self._transfer_admin_id_present:
            return self._transfer_admin_id_value
        else:
            return None

    @transfer_admin_id.setter
    def transfer_admin_id(self, val):
        if val is None:
            del self.transfer_admin_id
            return
        self._transfer_admin_id_validator.validate_type_only(val)
        self._transfer_admin_id_value = val
        self._transfer_admin_id_present = True

    @transfer_admin_id.deleter
    def transfer_admin_id(self):
        self._transfer_admin_id_value = None
        self._transfer_admin_id_present = False

    @property
    def keep_account(self):
        """
        Downgrade the member to a Basic account. The user will retain the email
        address associated with their Dropbox  account and data in their account
        that is not restricted to team members. In order to keep the account the
        argument wipe_data should be set to False.

        :rtype: bool
        """
        if self._keep_account_present:
            return self._keep_account_value
        else:
            return False

    @keep_account.setter
    def keep_account(self, val):
        val = self._keep_account_validator.validate(val)
        self._keep_account_value = val
        self._keep_account_present = True

    @keep_account.deleter
    def keep_account(self):
        self._keep_account_value = None
        self._keep_account_present = False

    def __repr__(self):
        return 'MembersRemoveArg(user={!r}, wipe_data={!r}, transfer_dest_id={!r}, transfer_admin_id={!r}, keep_account={!r})'.format(
            self._user_value,
            self._wipe_data_value,
            self._transfer_dest_id_value,
            self._transfer_admin_id_value,
            self._keep_account_value,
        )

MembersRemoveArg_validator = bv.Struct(MembersRemoveArg)

class MembersRemoveError(MembersDeactivateError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar remove_last_admin: The user is the last admin of the team, so it
        cannot be removed from it.
    :ivar removed_and_transfer_dest_should_differ: Expected removed user and
        transfer_dest user to be different
    :ivar removed_and_transfer_admin_should_differ: Expected removed user and
        transfer_admin user to be different.
    :ivar transfer_dest_user_not_found: No matching user found for the argument
        transfer_dest_id.
    :ivar transfer_dest_user_not_in_team: The provided transfer_dest_id does not
        exist on this team.
    :ivar transfer_admin_user_not_found: No matching user found for the argument
        transfer_admin_id.
    :ivar transfer_admin_user_not_in_team: The provided transfer_admin_id does
        not exist on this team.
    :ivar unspecified_transfer_admin_id: The transfer_admin_id argument must be
        provided when file transfer is requested.
    :ivar transfer_admin_is_not_admin: Specified transfer_admin user is not a
        team admin.
    :ivar cannot_keep_account_and_transfer: Cannot keep account and transfer the
        data to another user at the same time.
    :ivar cannot_keep_account_and_delete_data: Cannot keep account and delete
        the data at the same time. To keep the account the argument wipe_data
        should be set to False.
    :ivar email_address_too_long_to_be_disabled: The email address of the user
        is too long to be disabled.
    """

    # Attribute is overwritten below the class definition
    remove_last_admin = None
    # Attribute is overwritten below the class definition
    removed_and_transfer_dest_should_differ = None
    # Attribute is overwritten below the class definition
    removed_and_transfer_admin_should_differ = None
    # Attribute is overwritten below the class definition
    transfer_dest_user_not_found = None
    # Attribute is overwritten below the class definition
    transfer_dest_user_not_in_team = None
    # Attribute is overwritten below the class definition
    transfer_admin_user_not_found = None
    # Attribute is overwritten below the class definition
    transfer_admin_user_not_in_team = None
    # Attribute is overwritten below the class definition
    unspecified_transfer_admin_id = None
    # Attribute is overwritten below the class definition
    transfer_admin_is_not_admin = None
    # Attribute is overwritten below the class definition
    cannot_keep_account_and_transfer = None
    # Attribute is overwritten below the class definition
    cannot_keep_account_and_delete_data = None
    # Attribute is overwritten below the class definition
    email_address_too_long_to_be_disabled = None

    def is_remove_last_admin(self):
        """
        Check if the union tag is ``remove_last_admin``.

        :rtype: bool
        """
        return self._tag == 'remove_last_admin'

    def is_removed_and_transfer_dest_should_differ(self):
        """
        Check if the union tag is ``removed_and_transfer_dest_should_differ``.

        :rtype: bool
        """
        return self._tag == 'removed_and_transfer_dest_should_differ'

    def is_removed_and_transfer_admin_should_differ(self):
        """
        Check if the union tag is ``removed_and_transfer_admin_should_differ``.

        :rtype: bool
        """
        return self._tag == 'removed_and_transfer_admin_should_differ'

    def is_transfer_dest_user_not_found(self):
        """
        Check if the union tag is ``transfer_dest_user_not_found``.

        :rtype: bool
        """
        return self._tag == 'transfer_dest_user_not_found'

    def is_transfer_dest_user_not_in_team(self):
        """
        Check if the union tag is ``transfer_dest_user_not_in_team``.

        :rtype: bool
        """
        return self._tag == 'transfer_dest_user_not_in_team'

    def is_transfer_admin_user_not_found(self):
        """
        Check if the union tag is ``transfer_admin_user_not_found``.

        :rtype: bool
        """
        return self._tag == 'transfer_admin_user_not_found'

    def is_transfer_admin_user_not_in_team(self):
        """
        Check if the union tag is ``transfer_admin_user_not_in_team``.

        :rtype: bool
        """
        return self._tag == 'transfer_admin_user_not_in_team'

    def is_unspecified_transfer_admin_id(self):
        """
        Check if the union tag is ``unspecified_transfer_admin_id``.

        :rtype: bool
        """
        return self._tag == 'unspecified_transfer_admin_id'

    def is_transfer_admin_is_not_admin(self):
        """
        Check if the union tag is ``transfer_admin_is_not_admin``.

        :rtype: bool
        """
        return self._tag == 'transfer_admin_is_not_admin'

    def is_cannot_keep_account_and_transfer(self):
        """
        Check if the union tag is ``cannot_keep_account_and_transfer``.

        :rtype: bool
        """
        return self._tag == 'cannot_keep_account_and_transfer'

    def is_cannot_keep_account_and_delete_data(self):
        """
        Check if the union tag is ``cannot_keep_account_and_delete_data``.

        :rtype: bool
        """
        return self._tag == 'cannot_keep_account_and_delete_data'

    def is_email_address_too_long_to_be_disabled(self):
        """
        Check if the union tag is ``email_address_too_long_to_be_disabled``.

        :rtype: bool
        """
        return self._tag == 'email_address_too_long_to_be_disabled'

    def __repr__(self):
        return 'MembersRemoveError(%r, %r)' % (self._tag, self._value)

MembersRemoveError_validator = bv.Union(MembersRemoveError)

class MembersSendWelcomeError(MemberSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersSendWelcomeError(%r, %r)' % (self._tag, self._value)

MembersSendWelcomeError_validator = bv.Union(MembersSendWelcomeError)

class MembersSetPermissionsArg(object):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account.

    :ivar user: Identity of user whose role will be set.
    :ivar new_role: The new role of the member.
    """

    __slots__ = [
        '_user_value',
        '_user_present',
        '_new_role_value',
        '_new_role_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user=None,
                 new_role=None):
        self._user_value = None
        self._user_present = False
        self._new_role_value = None
        self._new_role_present = False
        if user is not None:
            self.user = user
        if new_role is not None:
            self.new_role = new_role

    @property
    def user(self):
        """
        Identity of user whose role will be set.

        :rtype: UserSelectorArg
        """
        if self._user_present:
            return self._user_value
        else:
            raise AttributeError("missing required field 'user'")

    @user.setter
    def user(self, val):
        self._user_validator.validate_type_only(val)
        self._user_value = val
        self._user_present = True

    @user.deleter
    def user(self):
        self._user_value = None
        self._user_present = False

    @property
    def new_role(self):
        """
        The new role of the member.

        :rtype: AdminTier
        """
        if self._new_role_present:
            return self._new_role_value
        else:
            raise AttributeError("missing required field 'new_role'")

    @new_role.setter
    def new_role(self, val):
        self._new_role_validator.validate_type_only(val)
        self._new_role_value = val
        self._new_role_present = True

    @new_role.deleter
    def new_role(self):
        self._new_role_value = None
        self._new_role_present = False

    def __repr__(self):
        return 'MembersSetPermissionsArg(user={!r}, new_role={!r})'.format(
            self._user_value,
            self._new_role_value,
        )

MembersSetPermissionsArg_validator = bv.Struct(MembersSetPermissionsArg)

class MembersSetPermissionsError(UserSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar last_admin: Cannot remove the admin setting of the last admin.
    :ivar user_not_in_team: The user is not a member of the team.
    :ivar cannot_set_permissions: Cannot remove/grant permissions.
    :ivar team_license_limit: Team is full. The organization has no available
        licenses.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    last_admin = None
    # Attribute is overwritten below the class definition
    user_not_in_team = None
    # Attribute is overwritten below the class definition
    cannot_set_permissions = None
    # Attribute is overwritten below the class definition
    team_license_limit = None
    # Attribute is overwritten below the class definition
    other = None

    def is_last_admin(self):
        """
        Check if the union tag is ``last_admin``.

        :rtype: bool
        """
        return self._tag == 'last_admin'

    def is_user_not_in_team(self):
        """
        Check if the union tag is ``user_not_in_team``.

        :rtype: bool
        """
        return self._tag == 'user_not_in_team'

    def is_cannot_set_permissions(self):
        """
        Check if the union tag is ``cannot_set_permissions``.

        :rtype: bool
        """
        return self._tag == 'cannot_set_permissions'

    def is_team_license_limit(self):
        """
        Check if the union tag is ``team_license_limit``.

        :rtype: bool
        """
        return self._tag == 'team_license_limit'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersSetPermissionsError(%r, %r)' % (self._tag, self._value)

MembersSetPermissionsError_validator = bv.Union(MembersSetPermissionsError)

class MembersSetPermissionsResult(object):
    """
    :ivar team_member_id: The member ID of the user to which the change was
        applied.
    :ivar role: The role after the change.
    """

    __slots__ = [
        '_team_member_id_value',
        '_team_member_id_present',
        '_role_value',
        '_role_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_member_id=None,
                 role=None):
        self._team_member_id_value = None
        self._team_member_id_present = False
        self._role_value = None
        self._role_present = False
        if team_member_id is not None:
            self.team_member_id = team_member_id
        if role is not None:
            self.role = role

    @property
    def team_member_id(self):
        """
        The member ID of the user to which the change was applied.

        :rtype: str
        """
        if self._team_member_id_present:
            return self._team_member_id_value
        else:
            raise AttributeError("missing required field 'team_member_id'")

    @team_member_id.setter
    def team_member_id(self, val):
        val = self._team_member_id_validator.validate(val)
        self._team_member_id_value = val
        self._team_member_id_present = True

    @team_member_id.deleter
    def team_member_id(self):
        self._team_member_id_value = None
        self._team_member_id_present = False

    @property
    def role(self):
        """
        The role after the change.

        :rtype: AdminTier
        """
        if self._role_present:
            return self._role_value
        else:
            raise AttributeError("missing required field 'role'")

    @role.setter
    def role(self, val):
        self._role_validator.validate_type_only(val)
        self._role_value = val
        self._role_present = True

    @role.deleter
    def role(self):
        self._role_value = None
        self._role_present = False

    def __repr__(self):
        return 'MembersSetPermissionsResult(team_member_id={!r}, role={!r})'.format(
            self._team_member_id_value,
            self._role_value,
        )

MembersSetPermissionsResult_validator = bv.Struct(MembersSetPermissionsResult)

class MembersSetProfileArg(object):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account. At least one of new_email, new_external_id,
    new_given_name, and/or new_surname must be provided.

    :ivar user: Identity of user whose profile will be set.
    :ivar new_email: New email for member.
    :ivar new_external_id: New external ID for member.
    :ivar new_given_name: New given name for member.
    :ivar new_surname: New surname for member.
    :ivar new_persistent_id: New persistent ID. This field only available to
        teams using persistent ID SAML configuration.
    """

    __slots__ = [
        '_user_value',
        '_user_present',
        '_new_email_value',
        '_new_email_present',
        '_new_external_id_value',
        '_new_external_id_present',
        '_new_given_name_value',
        '_new_given_name_present',
        '_new_surname_value',
        '_new_surname_present',
        '_new_persistent_id_value',
        '_new_persistent_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user=None,
                 new_email=None,
                 new_external_id=None,
                 new_given_name=None,
                 new_surname=None,
                 new_persistent_id=None):
        self._user_value = None
        self._user_present = False
        self._new_email_value = None
        self._new_email_present = False
        self._new_external_id_value = None
        self._new_external_id_present = False
        self._new_given_name_value = None
        self._new_given_name_present = False
        self._new_surname_value = None
        self._new_surname_present = False
        self._new_persistent_id_value = None
        self._new_persistent_id_present = False
        if user is not None:
            self.user = user
        if new_email is not None:
            self.new_email = new_email
        if new_external_id is not None:
            self.new_external_id = new_external_id
        if new_given_name is not None:
            self.new_given_name = new_given_name
        if new_surname is not None:
            self.new_surname = new_surname
        if new_persistent_id is not None:
            self.new_persistent_id = new_persistent_id

    @property
    def user(self):
        """
        Identity of user whose profile will be set.

        :rtype: UserSelectorArg
        """
        if self._user_present:
            return self._user_value
        else:
            raise AttributeError("missing required field 'user'")

    @user.setter
    def user(self, val):
        self._user_validator.validate_type_only(val)
        self._user_value = val
        self._user_present = True

    @user.deleter
    def user(self):
        self._user_value = None
        self._user_present = False

    @property
    def new_email(self):
        """
        New email for member.

        :rtype: str
        """
        if self._new_email_present:
            return self._new_email_value
        else:
            return None

    @new_email.setter
    def new_email(self, val):
        if val is None:
            del self.new_email
            return
        val = self._new_email_validator.validate(val)
        self._new_email_value = val
        self._new_email_present = True

    @new_email.deleter
    def new_email(self):
        self._new_email_value = None
        self._new_email_present = False

    @property
    def new_external_id(self):
        """
        New external ID for member.

        :rtype: str
        """
        if self._new_external_id_present:
            return self._new_external_id_value
        else:
            return None

    @new_external_id.setter
    def new_external_id(self, val):
        if val is None:
            del self.new_external_id
            return
        val = self._new_external_id_validator.validate(val)
        self._new_external_id_value = val
        self._new_external_id_present = True

    @new_external_id.deleter
    def new_external_id(self):
        self._new_external_id_value = None
        self._new_external_id_present = False

    @property
    def new_given_name(self):
        """
        New given name for member.

        :rtype: str
        """
        if self._new_given_name_present:
            return self._new_given_name_value
        else:
            return None

    @new_given_name.setter
    def new_given_name(self, val):
        if val is None:
            del self.new_given_name
            return
        val = self._new_given_name_validator.validate(val)
        self._new_given_name_value = val
        self._new_given_name_present = True

    @new_given_name.deleter
    def new_given_name(self):
        self._new_given_name_value = None
        self._new_given_name_present = False

    @property
    def new_surname(self):
        """
        New surname for member.

        :rtype: str
        """
        if self._new_surname_present:
            return self._new_surname_value
        else:
            return None

    @new_surname.setter
    def new_surname(self, val):
        if val is None:
            del self.new_surname
            return
        val = self._new_surname_validator.validate(val)
        self._new_surname_value = val
        self._new_surname_present = True

    @new_surname.deleter
    def new_surname(self):
        self._new_surname_value = None
        self._new_surname_present = False

    @property
    def new_persistent_id(self):
        """
        New persistent ID. This field only available to teams using persistent
        ID SAML configuration.

        :rtype: str
        """
        if self._new_persistent_id_present:
            return self._new_persistent_id_value
        else:
            return None

    @new_persistent_id.setter
    def new_persistent_id(self, val):
        if val is None:
            del self.new_persistent_id
            return
        val = self._new_persistent_id_validator.validate(val)
        self._new_persistent_id_value = val
        self._new_persistent_id_present = True

    @new_persistent_id.deleter
    def new_persistent_id(self):
        self._new_persistent_id_value = None
        self._new_persistent_id_present = False

    def __repr__(self):
        return 'MembersSetProfileArg(user={!r}, new_email={!r}, new_external_id={!r}, new_given_name={!r}, new_surname={!r}, new_persistent_id={!r})'.format(
            self._user_value,
            self._new_email_value,
            self._new_external_id_value,
            self._new_given_name_value,
            self._new_surname_value,
            self._new_persistent_id_value,
        )

MembersSetProfileArg_validator = bv.Struct(MembersSetProfileArg)

class MembersSetProfileError(MemberSelectorError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar external_id_and_new_external_id_unsafe: It is unsafe to use both
        external_id and new_external_id
    :ivar no_new_data_specified: None of new_email, new_given_name, new_surname,
        or new_external_id are specified
    :ivar email_reserved_for_other_user: Email is already reserved for another
        user.
    :ivar external_id_used_by_other_user: The external ID is already in use by
        another team member.
    :ivar set_profile_disallowed: Pending team member's email cannot be
        modified.
    :ivar param_cannot_be_empty: Parameter new_email cannot be empty.
    :ivar persistent_id_disabled: Persistent ID is only available to teams with
        persistent ID SAML configuration. Please contact Dropbox for more
        information.
    :ivar persistent_id_used_by_other_user: The persistent ID is already in use
        by another team member.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    external_id_and_new_external_id_unsafe = None
    # Attribute is overwritten below the class definition
    no_new_data_specified = None
    # Attribute is overwritten below the class definition
    email_reserved_for_other_user = None
    # Attribute is overwritten below the class definition
    external_id_used_by_other_user = None
    # Attribute is overwritten below the class definition
    set_profile_disallowed = None
    # Attribute is overwritten below the class definition
    param_cannot_be_empty = None
    # Attribute is overwritten below the class definition
    persistent_id_disabled = None
    # Attribute is overwritten below the class definition
    persistent_id_used_by_other_user = None
    # Attribute is overwritten below the class definition
    other = None

    def is_external_id_and_new_external_id_unsafe(self):
        """
        Check if the union tag is ``external_id_and_new_external_id_unsafe``.

        :rtype: bool
        """
        return self._tag == 'external_id_and_new_external_id_unsafe'

    def is_no_new_data_specified(self):
        """
        Check if the union tag is ``no_new_data_specified``.

        :rtype: bool
        """
        return self._tag == 'no_new_data_specified'

    def is_email_reserved_for_other_user(self):
        """
        Check if the union tag is ``email_reserved_for_other_user``.

        :rtype: bool
        """
        return self._tag == 'email_reserved_for_other_user'

    def is_external_id_used_by_other_user(self):
        """
        Check if the union tag is ``external_id_used_by_other_user``.

        :rtype: bool
        """
        return self._tag == 'external_id_used_by_other_user'

    def is_set_profile_disallowed(self):
        """
        Check if the union tag is ``set_profile_disallowed``.

        :rtype: bool
        """
        return self._tag == 'set_profile_disallowed'

    def is_param_cannot_be_empty(self):
        """
        Check if the union tag is ``param_cannot_be_empty``.

        :rtype: bool
        """
        return self._tag == 'param_cannot_be_empty'

    def is_persistent_id_disabled(self):
        """
        Check if the union tag is ``persistent_id_disabled``.

        :rtype: bool
        """
        return self._tag == 'persistent_id_disabled'

    def is_persistent_id_used_by_other_user(self):
        """
        Check if the union tag is ``persistent_id_used_by_other_user``.

        :rtype: bool
        """
        return self._tag == 'persistent_id_used_by_other_user'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'MembersSetProfileError(%r, %r)' % (self._tag, self._value)

MembersSetProfileError_validator = bv.Union(MembersSetProfileError)

class MembersSuspendError(MembersDeactivateError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar suspend_inactive_user: The user is not active, so it cannot be
        suspended.
    :ivar suspend_last_admin: The user is the last admin of the team, so it
        cannot be suspended.
    :ivar team_license_limit: Team is full. The organization has no available
        licenses.
    """

    # Attribute is overwritten below the class definition
    suspend_inactive_user = None
    # Attribute is overwritten below the class definition
    suspend_last_admin = None
    # Attribute is overwritten below the class definition
    team_license_limit = None

    def is_suspend_inactive_user(self):
        """
        Check if the union tag is ``suspend_inactive_user``.

        :rtype: bool
        """
        return self._tag == 'suspend_inactive_user'

    def is_suspend_last_admin(self):
        """
        Check if the union tag is ``suspend_last_admin``.

        :rtype: bool
        """
        return self._tag == 'suspend_last_admin'

    def is_team_license_limit(self):
        """
        Check if the union tag is ``team_license_limit``.

        :rtype: bool
        """
        return self._tag == 'team_license_limit'

    def __repr__(self):
        return 'MembersSuspendError(%r, %r)' % (self._tag, self._value)

MembersSuspendError_validator = bv.Union(MembersSuspendError)

class MembersUnsuspendArg(object):
    """
    Exactly one of team_member_id, email, or external_id must be provided to
    identify the user account.

    :ivar user: Identity of user to unsuspend.
    """

    __slots__ = [
        '_user_value',
        '_user_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 user=None):
        self._user_value = None
        self._user_present = False
        if user is not None:
            self.user = user

    @property
    def user(self):
        """
        Identity of user to unsuspend.

        :rtype: UserSelectorArg
        """
        if self._user_present:
            return self._user_value
        else:
            raise AttributeError("missing required field 'user'")

    @user.setter
    def user(self, val):
        self._user_validator.validate_type_only(val)
        self._user_value = val
        self._user_present = True

    @user.deleter
    def user(self):
        self._user_value = None
        self._user_present = False

    def __repr__(self):
        return 'MembersUnsuspendArg(user={!r})'.format(
            self._user_value,
        )

MembersUnsuspendArg_validator = bv.Struct(MembersUnsuspendArg)

class MembersUnsuspendError(MembersDeactivateError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar unsuspend_non_suspended_member: The user is unsuspended, so it cannot
        be unsuspended again.
    :ivar team_license_limit: Team is full. The organization has no available
        licenses.
    """

    # Attribute is overwritten below the class definition
    unsuspend_non_suspended_member = None
    # Attribute is overwritten below the class definition
    team_license_limit = None

    def is_unsuspend_non_suspended_member(self):
        """
        Check if the union tag is ``unsuspend_non_suspended_member``.

        :rtype: bool
        """
        return self._tag == 'unsuspend_non_suspended_member'

    def is_team_license_limit(self):
        """
        Check if the union tag is ``team_license_limit``.

        :rtype: bool
        """
        return self._tag == 'team_license_limit'

    def __repr__(self):
        return 'MembersUnsuspendError(%r, %r)' % (self._tag, self._value)

MembersUnsuspendError_validator = bv.Union(MembersUnsuspendError)

class MobileClientPlatform(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar iphone: Official Dropbox iPhone client
    :ivar ipad: Official Dropbox iPad client
    :ivar android: Official Dropbox Android client
    :ivar windows_phone: Official Dropbox Windows phone client
    :ivar blackberry: Official Dropbox Blackberry client
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    iphone = None
    # Attribute is overwritten below the class definition
    ipad = None
    # Attribute is overwritten below the class definition
    android = None
    # Attribute is overwritten below the class definition
    windows_phone = None
    # Attribute is overwritten below the class definition
    blackberry = None
    # Attribute is overwritten below the class definition
    other = None

    def is_iphone(self):
        """
        Check if the union tag is ``iphone``.

        :rtype: bool
        """
        return self._tag == 'iphone'

    def is_ipad(self):
        """
        Check if the union tag is ``ipad``.

        :rtype: bool
        """
        return self._tag == 'ipad'

    def is_android(self):
        """
        Check if the union tag is ``android``.

        :rtype: bool
        """
        return self._tag == 'android'

    def is_windows_phone(self):
        """
        Check if the union tag is ``windows_phone``.

        :rtype: bool
        """
        return self._tag == 'windows_phone'

    def is_blackberry(self):
        """
        Check if the union tag is ``blackberry``.

        :rtype: bool
        """
        return self._tag == 'blackberry'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'MobileClientPlatform(%r, %r)' % (self._tag, self._value)

MobileClientPlatform_validator = bv.Union(MobileClientPlatform)

class MobileClientSession(DeviceSession):
    """
    Information about linked Dropbox mobile client sessions

    :ivar device_name: The device name
    :ivar client_type: The mobile application type
    :ivar client_version: The dropbox client version
    :ivar os_version: The hosting OS version
    :ivar last_carrier: last carrier used by the device
    """

    __slots__ = [
        '_device_name_value',
        '_device_name_present',
        '_client_type_value',
        '_client_type_present',
        '_client_version_value',
        '_client_version_present',
        '_os_version_value',
        '_os_version_present',
        '_last_carrier_value',
        '_last_carrier_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 device_name=None,
                 client_type=None,
                 ip_address=None,
                 country=None,
                 created=None,
                 updated=None,
                 client_version=None,
                 os_version=None,
                 last_carrier=None):
        super(MobileClientSession, self).__init__(session_id,
                                                  ip_address,
                                                  country,
                                                  created,
                                                  updated)
        self._device_name_value = None
        self._device_name_present = False
        self._client_type_value = None
        self._client_type_present = False
        self._client_version_value = None
        self._client_version_present = False
        self._os_version_value = None
        self._os_version_present = False
        self._last_carrier_value = None
        self._last_carrier_present = False
        if device_name is not None:
            self.device_name = device_name
        if client_type is not None:
            self.client_type = client_type
        if client_version is not None:
            self.client_version = client_version
        if os_version is not None:
            self.os_version = os_version
        if last_carrier is not None:
            self.last_carrier = last_carrier

    @property
    def device_name(self):
        """
        The device name

        :rtype: str
        """
        if self._device_name_present:
            return self._device_name_value
        else:
            raise AttributeError("missing required field 'device_name'")

    @device_name.setter
    def device_name(self, val):
        val = self._device_name_validator.validate(val)
        self._device_name_value = val
        self._device_name_present = True

    @device_name.deleter
    def device_name(self):
        self._device_name_value = None
        self._device_name_present = False

    @property
    def client_type(self):
        """
        The mobile application type

        :rtype: MobileClientPlatform
        """
        if self._client_type_present:
            return self._client_type_value
        else:
            raise AttributeError("missing required field 'client_type'")

    @client_type.setter
    def client_type(self, val):
        self._client_type_validator.validate_type_only(val)
        self._client_type_value = val
        self._client_type_present = True

    @client_type.deleter
    def client_type(self):
        self._client_type_value = None
        self._client_type_present = False

    @property
    def client_version(self):
        """
        The dropbox client version

        :rtype: str
        """
        if self._client_version_present:
            return self._client_version_value
        else:
            return None

    @client_version.setter
    def client_version(self, val):
        if val is None:
            del self.client_version
            return
        val = self._client_version_validator.validate(val)
        self._client_version_value = val
        self._client_version_present = True

    @client_version.deleter
    def client_version(self):
        self._client_version_value = None
        self._client_version_present = False

    @property
    def os_version(self):
        """
        The hosting OS version

        :rtype: str
        """
        if self._os_version_present:
            return self._os_version_value
        else:
            return None

    @os_version.setter
    def os_version(self, val):
        if val is None:
            del self.os_version
            return
        val = self._os_version_validator.validate(val)
        self._os_version_value = val
        self._os_version_present = True

    @os_version.deleter
    def os_version(self):
        self._os_version_value = None
        self._os_version_present = False

    @property
    def last_carrier(self):
        """
        last carrier used by the device

        :rtype: str
        """
        if self._last_carrier_present:
            return self._last_carrier_value
        else:
            return None

    @last_carrier.setter
    def last_carrier(self, val):
        if val is None:
            del self.last_carrier
            return
        val = self._last_carrier_validator.validate(val)
        self._last_carrier_value = val
        self._last_carrier_present = True

    @last_carrier.deleter
    def last_carrier(self):
        self._last_carrier_value = None
        self._last_carrier_present = False

    def __repr__(self):
        return 'MobileClientSession(session_id={!r}, device_name={!r}, client_type={!r}, ip_address={!r}, country={!r}, created={!r}, updated={!r}, client_version={!r}, os_version={!r}, last_carrier={!r})'.format(
            self._session_id_value,
            self._device_name_value,
            self._client_type_value,
            self._ip_address_value,
            self._country_value,
            self._created_value,
            self._updated_value,
            self._client_version_value,
            self._os_version_value,
            self._last_carrier_value,
        )

MobileClientSession_validator = bv.Struct(MobileClientSession)

class RemovedStatus(object):
    """
    :ivar is_recoverable: True if the removed team member is recoverable
    """

    __slots__ = [
        '_is_recoverable_value',
        '_is_recoverable_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 is_recoverable=None):
        self._is_recoverable_value = None
        self._is_recoverable_present = False
        if is_recoverable is not None:
            self.is_recoverable = is_recoverable

    @property
    def is_recoverable(self):
        """
        True if the removed team member is recoverable

        :rtype: bool
        """
        if self._is_recoverable_present:
            return self._is_recoverable_value
        else:
            raise AttributeError("missing required field 'is_recoverable'")

    @is_recoverable.setter
    def is_recoverable(self, val):
        val = self._is_recoverable_validator.validate(val)
        self._is_recoverable_value = val
        self._is_recoverable_present = True

    @is_recoverable.deleter
    def is_recoverable(self):
        self._is_recoverable_value = None
        self._is_recoverable_present = False

    def __repr__(self):
        return 'RemovedStatus(is_recoverable={!r})'.format(
            self._is_recoverable_value,
        )

RemovedStatus_validator = bv.Struct(RemovedStatus)

class RevokeDesktopClientArg(DeviceSessionArg):
    """
    :ivar delete_on_unlink: Whether to delete all files of the account (this is
        possible only if supported by the desktop client and  will be made the
        next time the client access the account)
    """

    __slots__ = [
        '_delete_on_unlink_value',
        '_delete_on_unlink_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 session_id=None,
                 team_member_id=None,
                 delete_on_unlink=None):
        super(RevokeDesktopClientArg, self).__init__(session_id,
                                                     team_member_id)
        self._delete_on_unlink_value = None
        self._delete_on_unlink_present = False
        if delete_on_unlink is not None:
            self.delete_on_unlink = delete_on_unlink

    @property
    def delete_on_unlink(self):
        """
        Whether to delete all files of the account (this is possible only if
        supported by the desktop client and  will be made the next time the
        client access the account)

        :rtype: bool
        """
        if self._delete_on_unlink_present:
            return self._delete_on_unlink_value
        else:
            return False

    @delete_on_unlink.setter
    def delete_on_unlink(self, val):
        val = self._delete_on_unlink_validator.validate(val)
        self._delete_on_unlink_value = val
        self._delete_on_unlink_present = True

    @delete_on_unlink.deleter
    def delete_on_unlink(self):
        self._delete_on_unlink_value = None
        self._delete_on_unlink_present = False

    def __repr__(self):
        return 'RevokeDesktopClientArg(session_id={!r}, team_member_id={!r}, delete_on_unlink={!r})'.format(
            self._session_id_value,
            self._team_member_id_value,
            self._delete_on_unlink_value,
        )

RevokeDesktopClientArg_validator = bv.Struct(RevokeDesktopClientArg)

class RevokeDeviceSessionArg(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar DeviceSessionArg web_session: End an active session
    :ivar RevokeDesktopClientArg desktop_client: Unlink a linked desktop device
    :ivar DeviceSessionArg mobile_client: Unlink a linked mobile device
    """

    _catch_all = None

    @classmethod
    def web_session(cls, val):
        """
        Create an instance of this class set to the ``web_session`` tag with
        value ``val``.

        :param DeviceSessionArg val:
        :rtype: RevokeDeviceSessionArg
        """
        return cls('web_session', val)

    @classmethod
    def desktop_client(cls, val):
        """
        Create an instance of this class set to the ``desktop_client`` tag with
        value ``val``.

        :param RevokeDesktopClientArg val:
        :rtype: RevokeDeviceSessionArg
        """
        return cls('desktop_client', val)

    @classmethod
    def mobile_client(cls, val):
        """
        Create an instance of this class set to the ``mobile_client`` tag with
        value ``val``.

        :param DeviceSessionArg val:
        :rtype: RevokeDeviceSessionArg
        """
        return cls('mobile_client', val)

    def is_web_session(self):
        """
        Check if the union tag is ``web_session``.

        :rtype: bool
        """
        return self._tag == 'web_session'

    def is_desktop_client(self):
        """
        Check if the union tag is ``desktop_client``.

        :rtype: bool
        """
        return self._tag == 'desktop_client'

    def is_mobile_client(self):
        """
        Check if the union tag is ``mobile_client``.

        :rtype: bool
        """
        return self._tag == 'mobile_client'

    def get_web_session(self):
        """
        End an active session

        Only call this if :meth:`is_web_session` is true.

        :rtype: DeviceSessionArg
        """
        if not self.is_web_session():
            raise AttributeError("tag 'web_session' not set")
        return self._value

    def get_desktop_client(self):
        """
        Unlink a linked desktop device

        Only call this if :meth:`is_desktop_client` is true.

        :rtype: RevokeDesktopClientArg
        """
        if not self.is_desktop_client():
            raise AttributeError("tag 'desktop_client' not set")
        return self._value

    def get_mobile_client(self):
        """
        Unlink a linked mobile device

        Only call this if :meth:`is_mobile_client` is true.

        :rtype: DeviceSessionArg
        """
        if not self.is_mobile_client():
            raise AttributeError("tag 'mobile_client' not set")
        return self._value

    def __repr__(self):
        return 'RevokeDeviceSessionArg(%r, %r)' % (self._tag, self._value)

RevokeDeviceSessionArg_validator = bv.Union(RevokeDeviceSessionArg)

class RevokeDeviceSessionBatchArg(object):

    __slots__ = [
        '_revoke_devices_value',
        '_revoke_devices_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 revoke_devices=None):
        self._revoke_devices_value = None
        self._revoke_devices_present = False
        if revoke_devices is not None:
            self.revoke_devices = revoke_devices

    @property
    def revoke_devices(self):
        """
        :rtype: list of [RevokeDeviceSessionArg]
        """
        if self._revoke_devices_present:
            return self._revoke_devices_value
        else:
            raise AttributeError("missing required field 'revoke_devices'")

    @revoke_devices.setter
    def revoke_devices(self, val):
        val = self._revoke_devices_validator.validate(val)
        self._revoke_devices_value = val
        self._revoke_devices_present = True

    @revoke_devices.deleter
    def revoke_devices(self):
        self._revoke_devices_value = None
        self._revoke_devices_present = False

    def __repr__(self):
        return 'RevokeDeviceSessionBatchArg(revoke_devices={!r})'.format(
            self._revoke_devices_value,
        )

RevokeDeviceSessionBatchArg_validator = bv.Struct(RevokeDeviceSessionBatchArg)

class RevokeDeviceSessionBatchError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'RevokeDeviceSessionBatchError(%r, %r)' % (self._tag, self._value)

RevokeDeviceSessionBatchError_validator = bv.Union(RevokeDeviceSessionBatchError)

class RevokeDeviceSessionBatchResult(object):

    __slots__ = [
        '_revoke_devices_status_value',
        '_revoke_devices_status_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 revoke_devices_status=None):
        self._revoke_devices_status_value = None
        self._revoke_devices_status_present = False
        if revoke_devices_status is not None:
            self.revoke_devices_status = revoke_devices_status

    @property
    def revoke_devices_status(self):
        """
        :rtype: list of [RevokeDeviceSessionStatus]
        """
        if self._revoke_devices_status_present:
            return self._revoke_devices_status_value
        else:
            raise AttributeError("missing required field 'revoke_devices_status'")

    @revoke_devices_status.setter
    def revoke_devices_status(self, val):
        val = self._revoke_devices_status_validator.validate(val)
        self._revoke_devices_status_value = val
        self._revoke_devices_status_present = True

    @revoke_devices_status.deleter
    def revoke_devices_status(self):
        self._revoke_devices_status_value = None
        self._revoke_devices_status_present = False

    def __repr__(self):
        return 'RevokeDeviceSessionBatchResult(revoke_devices_status={!r})'.format(
            self._revoke_devices_status_value,
        )

RevokeDeviceSessionBatchResult_validator = bv.Struct(RevokeDeviceSessionBatchResult)

class RevokeDeviceSessionError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar device_session_not_found: Device session not found.
    :ivar member_not_found: Member not found.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    device_session_not_found = None
    # Attribute is overwritten below the class definition
    member_not_found = None
    # Attribute is overwritten below the class definition
    other = None

    def is_device_session_not_found(self):
        """
        Check if the union tag is ``device_session_not_found``.

        :rtype: bool
        """
        return self._tag == 'device_session_not_found'

    def is_member_not_found(self):
        """
        Check if the union tag is ``member_not_found``.

        :rtype: bool
        """
        return self._tag == 'member_not_found'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'RevokeDeviceSessionError(%r, %r)' % (self._tag, self._value)

RevokeDeviceSessionError_validator = bv.Union(RevokeDeviceSessionError)

class RevokeDeviceSessionStatus(object):
    """
    :ivar success: Result of the revoking request
    :ivar error_type: The error cause in case of a failure
    """

    __slots__ = [
        '_success_value',
        '_success_present',
        '_error_type_value',
        '_error_type_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 success=None,
                 error_type=None):
        self._success_value = None
        self._success_present = False
        self._error_type_value = None
        self._error_type_present = False
        if success is not None:
            self.success = success
        if error_type is not None:
            self.error_type = error_type

    @property
    def success(self):
        """
        Result of the revoking request

        :rtype: bool
        """
        if self._success_present:
            return self._success_value
        else:
            raise AttributeError("missing required field 'success'")

    @success.setter
    def success(self, val):
        val = self._success_validator.validate(val)
        self._success_value = val
        self._success_present = True

    @success.deleter
    def success(self):
        self._success_value = None
        self._success_present = False

    @property
    def error_type(self):
        """
        The error cause in case of a failure

        :rtype: RevokeDeviceSessionError
        """
        if self._error_type_present:
            return self._error_type_value
        else:
            return None

    @error_type.setter
    def error_type(self, val):
        if val is None:
            del self.error_type
            return
        self._error_type_validator.validate_type_only(val)
        self._error_type_value = val
        self._error_type_present = True

    @error_type.deleter
    def error_type(self):
        self._error_type_value = None
        self._error_type_present = False

    def __repr__(self):
        return 'RevokeDeviceSessionStatus(success={!r}, error_type={!r})'.format(
            self._success_value,
            self._error_type_value,
        )

RevokeDeviceSessionStatus_validator = bv.Struct(RevokeDeviceSessionStatus)

class RevokeLinkedApiAppArg(object):
    """
    :ivar app_id: The application's unique id
    :ivar team_member_id: The unique id of the member owning the device
    :ivar keep_app_folder: Whether to keep the application dedicated folder (in
        case the application uses  one)
    """

    __slots__ = [
        '_app_id_value',
        '_app_id_present',
        '_team_member_id_value',
        '_team_member_id_present',
        '_keep_app_folder_value',
        '_keep_app_folder_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 app_id=None,
                 team_member_id=None,
                 keep_app_folder=None):
        self._app_id_value = None
        self._app_id_present = False
        self._team_member_id_value = None
        self._team_member_id_present = False
        self._keep_app_folder_value = None
        self._keep_app_folder_present = False
        if app_id is not None:
            self.app_id = app_id
        if team_member_id is not None:
            self.team_member_id = team_member_id
        if keep_app_folder is not None:
            self.keep_app_folder = keep_app_folder

    @property
    def app_id(self):
        """
        The application's unique id

        :rtype: str
        """
        if self._app_id_present:
            return self._app_id_value
        else:
            raise AttributeError("missing required field 'app_id'")

    @app_id.setter
    def app_id(self, val):
        val = self._app_id_validator.validate(val)
        self._app_id_value = val
        self._app_id_present = True

    @app_id.deleter
    def app_id(self):
        self._app_id_value = None
        self._app_id_present = False

    @property
    def team_member_id(self):
        """
        The unique id of the member owning the device

        :rtype: str
        """
        if self._team_member_id_present:
            return self._team_member_id_value
        else:
            raise AttributeError("missing required field 'team_member_id'")

    @team_member_id.setter
    def team_member_id(self, val):
        val = self._team_member_id_validator.validate(val)
        self._team_member_id_value = val
        self._team_member_id_present = True

    @team_member_id.deleter
    def team_member_id(self):
        self._team_member_id_value = None
        self._team_member_id_present = False

    @property
    def keep_app_folder(self):
        """
        Whether to keep the application dedicated folder (in case the
        application uses  one)

        :rtype: bool
        """
        if self._keep_app_folder_present:
            return self._keep_app_folder_value
        else:
            return True

    @keep_app_folder.setter
    def keep_app_folder(self, val):
        val = self._keep_app_folder_validator.validate(val)
        self._keep_app_folder_value = val
        self._keep_app_folder_present = True

    @keep_app_folder.deleter
    def keep_app_folder(self):
        self._keep_app_folder_value = None
        self._keep_app_folder_present = False

    def __repr__(self):
        return 'RevokeLinkedApiAppArg(app_id={!r}, team_member_id={!r}, keep_app_folder={!r})'.format(
            self._app_id_value,
            self._team_member_id_value,
            self._keep_app_folder_value,
        )

RevokeLinkedApiAppArg_validator = bv.Struct(RevokeLinkedApiAppArg)

class RevokeLinkedApiAppBatchArg(object):

    __slots__ = [
        '_revoke_linked_app_value',
        '_revoke_linked_app_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 revoke_linked_app=None):
        self._revoke_linked_app_value = None
        self._revoke_linked_app_present = False
        if revoke_linked_app is not None:
            self.revoke_linked_app = revoke_linked_app

    @property
    def revoke_linked_app(self):
        """
        :rtype: list of [RevokeLinkedApiAppArg]
        """
        if self._revoke_linked_app_present:
            return self._revoke_linked_app_value
        else:
            raise AttributeError("missing required field 'revoke_linked_app'")

    @revoke_linked_app.setter
    def revoke_linked_app(self, val):
        val = self._revoke_linked_app_validator.validate(val)
        self._revoke_linked_app_value = val
        self._revoke_linked_app_present = True

    @revoke_linked_app.deleter
    def revoke_linked_app(self):
        self._revoke_linked_app_value = None
        self._revoke_linked_app_present = False

    def __repr__(self):
        return 'RevokeLinkedApiAppBatchArg(revoke_linked_app={!r})'.format(
            self._revoke_linked_app_value,
        )

RevokeLinkedApiAppBatchArg_validator = bv.Struct(RevokeLinkedApiAppBatchArg)

class RevokeLinkedAppBatchError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox.Dropbox.team_linked_apps_revoke_linked_app_batch`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    other = None

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'RevokeLinkedAppBatchError(%r, %r)' % (self._tag, self._value)

RevokeLinkedAppBatchError_validator = bv.Union(RevokeLinkedAppBatchError)

class RevokeLinkedAppBatchResult(object):

    __slots__ = [
        '_revoke_linked_app_status_value',
        '_revoke_linked_app_status_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 revoke_linked_app_status=None):
        self._revoke_linked_app_status_value = None
        self._revoke_linked_app_status_present = False
        if revoke_linked_app_status is not None:
            self.revoke_linked_app_status = revoke_linked_app_status

    @property
    def revoke_linked_app_status(self):
        """
        :rtype: list of [RevokeLinkedAppStatus]
        """
        if self._revoke_linked_app_status_present:
            return self._revoke_linked_app_status_value
        else:
            raise AttributeError("missing required field 'revoke_linked_app_status'")

    @revoke_linked_app_status.setter
    def revoke_linked_app_status(self, val):
        val = self._revoke_linked_app_status_validator.validate(val)
        self._revoke_linked_app_status_value = val
        self._revoke_linked_app_status_present = True

    @revoke_linked_app_status.deleter
    def revoke_linked_app_status(self):
        self._revoke_linked_app_status_value = None
        self._revoke_linked_app_status_present = False

    def __repr__(self):
        return 'RevokeLinkedAppBatchResult(revoke_linked_app_status={!r})'.format(
            self._revoke_linked_app_status_value,
        )

RevokeLinkedAppBatchResult_validator = bv.Struct(RevokeLinkedAppBatchResult)

class RevokeLinkedAppError(bb.Union):
    """
    Error returned by
    :meth:`dropbox.dropbox.Dropbox.team_linked_apps_revoke_linked_app`.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar app_not_found: Application not found.
    :ivar member_not_found: Member not found.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    app_not_found = None
    # Attribute is overwritten below the class definition
    member_not_found = None
    # Attribute is overwritten below the class definition
    other = None

    def is_app_not_found(self):
        """
        Check if the union tag is ``app_not_found``.

        :rtype: bool
        """
        return self._tag == 'app_not_found'

    def is_member_not_found(self):
        """
        Check if the union tag is ``member_not_found``.

        :rtype: bool
        """
        return self._tag == 'member_not_found'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'RevokeLinkedAppError(%r, %r)' % (self._tag, self._value)

RevokeLinkedAppError_validator = bv.Union(RevokeLinkedAppError)

class RevokeLinkedAppStatus(object):
    """
    :ivar success: Result of the revoking request
    :ivar error_type: The error cause in case of a failure
    """

    __slots__ = [
        '_success_value',
        '_success_present',
        '_error_type_value',
        '_error_type_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 success=None,
                 error_type=None):
        self._success_value = None
        self._success_present = False
        self._error_type_value = None
        self._error_type_present = False
        if success is not None:
            self.success = success
        if error_type is not None:
            self.error_type = error_type

    @property
    def success(self):
        """
        Result of the revoking request

        :rtype: bool
        """
        if self._success_present:
            return self._success_value
        else:
            raise AttributeError("missing required field 'success'")

    @success.setter
    def success(self, val):
        val = self._success_validator.validate(val)
        self._success_value = val
        self._success_present = True

    @success.deleter
    def success(self):
        self._success_value = None
        self._success_present = False

    @property
    def error_type(self):
        """
        The error cause in case of a failure

        :rtype: RevokeLinkedAppError
        """
        if self._error_type_present:
            return self._error_type_value
        else:
            return None

    @error_type.setter
    def error_type(self, val):
        if val is None:
            del self.error_type
            return
        self._error_type_validator.validate_type_only(val)
        self._error_type_value = val
        self._error_type_present = True

    @error_type.deleter
    def error_type(self):
        self._error_type_value = None
        self._error_type_present = False

    def __repr__(self):
        return 'RevokeLinkedAppStatus(success={!r}, error_type={!r})'.format(
            self._success_value,
            self._error_type_value,
        )

RevokeLinkedAppStatus_validator = bv.Struct(RevokeLinkedAppStatus)

class StorageBucket(object):
    """
    Describes the number of users in a specific storage bucket.

    :ivar bucket: The name of the storage bucket. For example, '1G' is a bucket
        of users with storage size up to 1 Giga.
    :ivar users: The number of people whose storage is in the range of this
        storage bucket.
    """

    __slots__ = [
        '_bucket_value',
        '_bucket_present',
        '_users_value',
        '_users_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 bucket=None,
                 users=None):
        self._bucket_value = None
        self._bucket_present = False
        self._users_value = None
        self._users_present = False
        if bucket is not None:
            self.bucket = bucket
        if users is not None:
            self.users = users

    @property
    def bucket(self):
        """
        The name of the storage bucket. For example, '1G' is a bucket of users
        with storage size up to 1 Giga.

        :rtype: str
        """
        if self._bucket_present:
            return self._bucket_value
        else:
            raise AttributeError("missing required field 'bucket'")

    @bucket.setter
    def bucket(self, val):
        val = self._bucket_validator.validate(val)
        self._bucket_value = val
        self._bucket_present = True

    @bucket.deleter
    def bucket(self):
        self._bucket_value = None
        self._bucket_present = False

    @property
    def users(self):
        """
        The number of people whose storage is in the range of this storage
        bucket.

        :rtype: long
        """
        if self._users_present:
            return self._users_value
        else:
            raise AttributeError("missing required field 'users'")

    @users.setter
    def users(self, val):
        val = self._users_validator.validate(val)
        self._users_value = val
        self._users_present = True

    @users.deleter
    def users(self):
        self._users_value = None
        self._users_present = False

    def __repr__(self):
        return 'StorageBucket(bucket={!r}, users={!r})'.format(
            self._bucket_value,
            self._users_value,
        )

StorageBucket_validator = bv.Struct(StorageBucket)

class TeamFolderAccessError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar invalid_team_folder_id: The team folder ID is invalid.
    :ivar no_access: The authenticated app does not have permission to manage
        that team folder.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    invalid_team_folder_id = None
    # Attribute is overwritten below the class definition
    no_access = None
    # Attribute is overwritten below the class definition
    other = None

    def is_invalid_team_folder_id(self):
        """
        Check if the union tag is ``invalid_team_folder_id``.

        :rtype: bool
        """
        return self._tag == 'invalid_team_folder_id'

    def is_no_access(self):
        """
        Check if the union tag is ``no_access``.

        :rtype: bool
        """
        return self._tag == 'no_access'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'TeamFolderAccessError(%r, %r)' % (self._tag, self._value)

TeamFolderAccessError_validator = bv.Union(TeamFolderAccessError)

class TeamFolderActivateError(BaseTeamFolderError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    def __repr__(self):
        return 'TeamFolderActivateError(%r, %r)' % (self._tag, self._value)

TeamFolderActivateError_validator = bv.Union(TeamFolderActivateError)

class TeamFolderIdArg(object):
    """
    :ivar team_folder_id: The ID of the team folder.
    """

    __slots__ = [
        '_team_folder_id_value',
        '_team_folder_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_folder_id=None):
        self._team_folder_id_value = None
        self._team_folder_id_present = False
        if team_folder_id is not None:
            self.team_folder_id = team_folder_id

    @property
    def team_folder_id(self):
        """
        The ID of the team folder.

        :rtype: str
        """
        if self._team_folder_id_present:
            return self._team_folder_id_value
        else:
            raise AttributeError("missing required field 'team_folder_id'")

    @team_folder_id.setter
    def team_folder_id(self, val):
        val = self._team_folder_id_validator.validate(val)
        self._team_folder_id_value = val
        self._team_folder_id_present = True

    @team_folder_id.deleter
    def team_folder_id(self):
        self._team_folder_id_value = None
        self._team_folder_id_present = False

    def __repr__(self):
        return 'TeamFolderIdArg(team_folder_id={!r})'.format(
            self._team_folder_id_value,
        )

TeamFolderIdArg_validator = bv.Struct(TeamFolderIdArg)

class TeamFolderArchiveArg(TeamFolderIdArg):
    """
    :ivar force_async_off: Whether to force the archive to happen synchronously.
    """

    __slots__ = [
        '_force_async_off_value',
        '_force_async_off_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_folder_id=None,
                 force_async_off=None):
        super(TeamFolderArchiveArg, self).__init__(team_folder_id)
        self._force_async_off_value = None
        self._force_async_off_present = False
        if force_async_off is not None:
            self.force_async_off = force_async_off

    @property
    def force_async_off(self):
        """
        Whether to force the archive to happen synchronously.

        :rtype: bool
        """
        if self._force_async_off_present:
            return self._force_async_off_value
        else:
            return False

    @force_async_off.setter
    def force_async_off(self, val):
        val = self._force_async_off_validator.validate(val)
        self._force_async_off_value = val
        self._force_async_off_present = True

    @force_async_off.deleter
    def force_async_off(self):
        self._force_async_off_value = None
        self._force_async_off_present = False

    def __repr__(self):
        return 'TeamFolderArchiveArg(team_folder_id={!r}, force_async_off={!r})'.format(
            self._team_folder_id_value,
            self._force_async_off_value,
        )

TeamFolderArchiveArg_validator = bv.Struct(TeamFolderArchiveArg)

class TeamFolderArchiveError(BaseTeamFolderError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    def __repr__(self):
        return 'TeamFolderArchiveError(%r, %r)' % (self._tag, self._value)

TeamFolderArchiveError_validator = bv.Union(TeamFolderArchiveError)

class TeamFolderArchiveJobStatus(async.PollResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar TeamFolderMetadata complete: The archive job has finished. The value
        is the metadata for the resulting team folder.
    :ivar TeamFolderArchiveError failed: Error occurred while performing an
        asynchronous job from
        :meth:`dropbox.dropbox.Dropbox.team_team_folder_archive`.
    """

    @classmethod
    def complete(cls, val):
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param TeamFolderMetadata val:
        :rtype: TeamFolderArchiveJobStatus
        """
        return cls('complete', val)

    @classmethod
    def failed(cls, val):
        """
        Create an instance of this class set to the ``failed`` tag with value
        ``val``.

        :param TeamFolderArchiveError val:
        :rtype: TeamFolderArchiveJobStatus
        """
        return cls('failed', val)

    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        return self._tag == 'complete'

    def is_failed(self):
        """
        Check if the union tag is ``failed``.

        :rtype: bool
        """
        return self._tag == 'failed'

    def get_complete(self):
        """
        The archive job has finished. The value is the metadata for the
        resulting team folder.

        Only call this if :meth:`is_complete` is true.

        :rtype: TeamFolderMetadata
        """
        if not self.is_complete():
            raise AttributeError("tag 'complete' not set")
        return self._value

    def get_failed(self):
        """
        Error occurred while performing an asynchronous job from
        :meth:`dropbox.dropbox.Dropbox.team_team_folder_archive`.

        Only call this if :meth:`is_failed` is true.

        :rtype: TeamFolderArchiveError
        """
        if not self.is_failed():
            raise AttributeError("tag 'failed' not set")
        return self._value

    def __repr__(self):
        return 'TeamFolderArchiveJobStatus(%r, %r)' % (self._tag, self._value)

TeamFolderArchiveJobStatus_validator = bv.Union(TeamFolderArchiveJobStatus)

class TeamFolderArchiveLaunch(async.LaunchResultBase):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    @classmethod
    def complete(cls, val):
        """
        Create an instance of this class set to the ``complete`` tag with value
        ``val``.

        :param TeamFolderMetadata val:
        :rtype: TeamFolderArchiveLaunch
        """
        return cls('complete', val)

    def is_complete(self):
        """
        Check if the union tag is ``complete``.

        :rtype: bool
        """
        return self._tag == 'complete'

    def get_complete(self):
        """
        Only call this if :meth:`is_complete` is true.

        :rtype: TeamFolderMetadata
        """
        if not self.is_complete():
            raise AttributeError("tag 'complete' not set")
        return self._value

    def __repr__(self):
        return 'TeamFolderArchiveLaunch(%r, %r)' % (self._tag, self._value)

TeamFolderArchiveLaunch_validator = bv.Union(TeamFolderArchiveLaunch)

class TeamFolderCreateArg(object):
    """
    :ivar name: Name for the new team folder.
    """

    __slots__ = [
        '_name_value',
        '_name_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 name=None):
        self._name_value = None
        self._name_present = False
        if name is not None:
            self.name = name

    @property
    def name(self):
        """
        Name for the new team folder.

        :rtype: str
        """
        if self._name_present:
            return self._name_value
        else:
            raise AttributeError("missing required field 'name'")

    @name.setter
    def name(self, val):
        val = self._name_validator.validate(val)
        self._name_value = val
        self._name_present = True

    @name.deleter
    def name(self):
        self._name_value = None
        self._name_present = False

    def __repr__(self):
        return 'TeamFolderCreateArg(name={!r})'.format(
            self._name_value,
        )

TeamFolderCreateArg_validator = bv.Struct(TeamFolderCreateArg)

class TeamFolderCreateError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar invalid_folder_name: The provided name cannot be used.
    :ivar folder_name_already_used: There is already a team folder with the
        provided name.
    :ivar folder_name_reserved: The provided name cannot be used because it is
        reserved.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    invalid_folder_name = None
    # Attribute is overwritten below the class definition
    folder_name_already_used = None
    # Attribute is overwritten below the class definition
    folder_name_reserved = None
    # Attribute is overwritten below the class definition
    other = None

    def is_invalid_folder_name(self):
        """
        Check if the union tag is ``invalid_folder_name``.

        :rtype: bool
        """
        return self._tag == 'invalid_folder_name'

    def is_folder_name_already_used(self):
        """
        Check if the union tag is ``folder_name_already_used``.

        :rtype: bool
        """
        return self._tag == 'folder_name_already_used'

    def is_folder_name_reserved(self):
        """
        Check if the union tag is ``folder_name_reserved``.

        :rtype: bool
        """
        return self._tag == 'folder_name_reserved'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'TeamFolderCreateError(%r, %r)' % (self._tag, self._value)

TeamFolderCreateError_validator = bv.Union(TeamFolderCreateError)

class TeamFolderGetInfoItem(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar str id_not_found: An ID that was provided as a parameter to
        :route:`team_folder/get_info` did not match any of the team's team
        folders.
    :ivar TeamFolderMetadata team_folder_metadata: Properties of a team folder.
    """

    _catch_all = None

    @classmethod
    def id_not_found(cls, val):
        """
        Create an instance of this class set to the ``id_not_found`` tag with
        value ``val``.

        :param str val:
        :rtype: TeamFolderGetInfoItem
        """
        return cls('id_not_found', val)

    @classmethod
    def team_folder_metadata(cls, val):
        """
        Create an instance of this class set to the ``team_folder_metadata`` tag
        with value ``val``.

        :param TeamFolderMetadata val:
        :rtype: TeamFolderGetInfoItem
        """
        return cls('team_folder_metadata', val)

    def is_id_not_found(self):
        """
        Check if the union tag is ``id_not_found``.

        :rtype: bool
        """
        return self._tag == 'id_not_found'

    def is_team_folder_metadata(self):
        """
        Check if the union tag is ``team_folder_metadata``.

        :rtype: bool
        """
        return self._tag == 'team_folder_metadata'

    def get_id_not_found(self):
        """
        An ID that was provided as a parameter to
        :meth:`dropbox.dropbox.Dropbox.team_team_folder_get_info` did not match
        any of the team's team folders.

        Only call this if :meth:`is_id_not_found` is true.

        :rtype: str
        """
        if not self.is_id_not_found():
            raise AttributeError("tag 'id_not_found' not set")
        return self._value

    def get_team_folder_metadata(self):
        """
        Properties of a team folder.

        Only call this if :meth:`is_team_folder_metadata` is true.

        :rtype: TeamFolderMetadata
        """
        if not self.is_team_folder_metadata():
            raise AttributeError("tag 'team_folder_metadata' not set")
        return self._value

    def __repr__(self):
        return 'TeamFolderGetInfoItem(%r, %r)' % (self._tag, self._value)

TeamFolderGetInfoItem_validator = bv.Union(TeamFolderGetInfoItem)

class TeamFolderIdListArg(object):
    """
    :ivar team_folder_ids: The list of team folder IDs.
    """

    __slots__ = [
        '_team_folder_ids_value',
        '_team_folder_ids_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_folder_ids=None):
        self._team_folder_ids_value = None
        self._team_folder_ids_present = False
        if team_folder_ids is not None:
            self.team_folder_ids = team_folder_ids

    @property
    def team_folder_ids(self):
        """
        The list of team folder IDs.

        :rtype: list of [str]
        """
        if self._team_folder_ids_present:
            return self._team_folder_ids_value
        else:
            raise AttributeError("missing required field 'team_folder_ids'")

    @team_folder_ids.setter
    def team_folder_ids(self, val):
        val = self._team_folder_ids_validator.validate(val)
        self._team_folder_ids_value = val
        self._team_folder_ids_present = True

    @team_folder_ids.deleter
    def team_folder_ids(self):
        self._team_folder_ids_value = None
        self._team_folder_ids_present = False

    def __repr__(self):
        return 'TeamFolderIdListArg(team_folder_ids={!r})'.format(
            self._team_folder_ids_value,
        )

TeamFolderIdListArg_validator = bv.Struct(TeamFolderIdListArg)

class TeamFolderInvalidStatusError(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar active: The folder is active and the operation did not succeed.
    :ivar archived: The folder is archived and the operation did not succeed.
    :ivar archive_in_progress: The folder is being archived and the operation
        did not succeed.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    active = None
    # Attribute is overwritten below the class definition
    archived = None
    # Attribute is overwritten below the class definition
    archive_in_progress = None
    # Attribute is overwritten below the class definition
    other = None

    def is_active(self):
        """
        Check if the union tag is ``active``.

        :rtype: bool
        """
        return self._tag == 'active'

    def is_archived(self):
        """
        Check if the union tag is ``archived``.

        :rtype: bool
        """
        return self._tag == 'archived'

    def is_archive_in_progress(self):
        """
        Check if the union tag is ``archive_in_progress``.

        :rtype: bool
        """
        return self._tag == 'archive_in_progress'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'TeamFolderInvalidStatusError(%r, %r)' % (self._tag, self._value)

TeamFolderInvalidStatusError_validator = bv.Union(TeamFolderInvalidStatusError)

class TeamFolderListArg(object):
    """
    :ivar limit: The maximum number of results to return per request.
    """

    __slots__ = [
        '_limit_value',
        '_limit_present',
    ]

    _has_required_fields = False

    def __init__(self,
                 limit=None):
        self._limit_value = None
        self._limit_present = False
        if limit is not None:
            self.limit = limit

    @property
    def limit(self):
        """
        The maximum number of results to return per request.

        :rtype: long
        """
        if self._limit_present:
            return self._limit_value
        else:
            return 1000

    @limit.setter
    def limit(self, val):
        val = self._limit_validator.validate(val)
        self._limit_value = val
        self._limit_present = True

    @limit.deleter
    def limit(self):
        self._limit_value = None
        self._limit_present = False

    def __repr__(self):
        return 'TeamFolderListArg(limit={!r})'.format(
            self._limit_value,
        )

TeamFolderListArg_validator = bv.Struct(TeamFolderListArg)

class TeamFolderListError(object):

    __slots__ = [
        '_access_error_value',
        '_access_error_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 access_error=None):
        self._access_error_value = None
        self._access_error_present = False
        if access_error is not None:
            self.access_error = access_error

    @property
    def access_error(self):
        """
        :rtype: TeamFolderAccessError
        """
        if self._access_error_present:
            return self._access_error_value
        else:
            raise AttributeError("missing required field 'access_error'")

    @access_error.setter
    def access_error(self, val):
        self._access_error_validator.validate_type_only(val)
        self._access_error_value = val
        self._access_error_present = True

    @access_error.deleter
    def access_error(self):
        self._access_error_value = None
        self._access_error_present = False

    def __repr__(self):
        return 'TeamFolderListError(access_error={!r})'.format(
            self._access_error_value,
        )

TeamFolderListError_validator = bv.Struct(TeamFolderListError)

class TeamFolderListResult(object):
    """
    Result for :meth:`dropbox.dropbox.Dropbox.team_team_folder_list`.

    :ivar team_folders: List of all team folders in the authenticated team.
    """

    __slots__ = [
        '_team_folders_value',
        '_team_folders_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_folders=None):
        self._team_folders_value = None
        self._team_folders_present = False
        if team_folders is not None:
            self.team_folders = team_folders

    @property
    def team_folders(self):
        """
        List of all team folders in the authenticated team.

        :rtype: list of [TeamFolderMetadata]
        """
        if self._team_folders_present:
            return self._team_folders_value
        else:
            raise AttributeError("missing required field 'team_folders'")

    @team_folders.setter
    def team_folders(self, val):
        val = self._team_folders_validator.validate(val)
        self._team_folders_value = val
        self._team_folders_present = True

    @team_folders.deleter
    def team_folders(self):
        self._team_folders_value = None
        self._team_folders_present = False

    def __repr__(self):
        return 'TeamFolderListResult(team_folders={!r})'.format(
            self._team_folders_value,
        )

TeamFolderListResult_validator = bv.Struct(TeamFolderListResult)

class TeamFolderMetadata(object):
    """
    Properties of a team folder.

    :ivar team_folder_id: The ID of the team folder.
    :ivar name: The name of the team folder.
    :ivar status: The status of the team folder.
    """

    __slots__ = [
        '_team_folder_id_value',
        '_team_folder_id_present',
        '_name_value',
        '_name_present',
        '_status_value',
        '_status_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_folder_id=None,
                 name=None,
                 status=None):
        self._team_folder_id_value = None
        self._team_folder_id_present = False
        self._name_value = None
        self._name_present = False
        self._status_value = None
        self._status_present = False
        if team_folder_id is not None:
            self.team_folder_id = team_folder_id
        if name is not None:
            self.name = name
        if status is not None:
            self.status = status

    @property
    def team_folder_id(self):
        """
        The ID of the team folder.

        :rtype: str
        """
        if self._team_folder_id_present:
            return self._team_folder_id_value
        else:
            raise AttributeError("missing required field 'team_folder_id'")

    @team_folder_id.setter
    def team_folder_id(self, val):
        val = self._team_folder_id_validator.validate(val)
        self._team_folder_id_value = val
        self._team_folder_id_present = True

    @team_folder_id.deleter
    def team_folder_id(self):
        self._team_folder_id_value = None
        self._team_folder_id_present = False

    @property
    def name(self):
        """
        The name of the team folder.

        :rtype: str
        """
        if self._name_present:
            return self._name_value
        else:
            raise AttributeError("missing required field 'name'")

    @name.setter
    def name(self, val):
        val = self._name_validator.validate(val)
        self._name_value = val
        self._name_present = True

    @name.deleter
    def name(self):
        self._name_value = None
        self._name_present = False

    @property
    def status(self):
        """
        The status of the team folder.

        :rtype: TeamFolderStatus
        """
        if self._status_present:
            return self._status_value
        else:
            raise AttributeError("missing required field 'status'")

    @status.setter
    def status(self, val):
        self._status_validator.validate_type_only(val)
        self._status_value = val
        self._status_present = True

    @status.deleter
    def status(self):
        self._status_value = None
        self._status_present = False

    def __repr__(self):
        return 'TeamFolderMetadata(team_folder_id={!r}, name={!r}, status={!r})'.format(
            self._team_folder_id_value,
            self._name_value,
            self._status_value,
        )

TeamFolderMetadata_validator = bv.Struct(TeamFolderMetadata)

class TeamFolderPermanentlyDeleteError(BaseTeamFolderError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    def __repr__(self):
        return 'TeamFolderPermanentlyDeleteError(%r, %r)' % (self._tag, self._value)

TeamFolderPermanentlyDeleteError_validator = bv.Union(TeamFolderPermanentlyDeleteError)

class TeamFolderRenameArg(TeamFolderIdArg):
    """
    :ivar name: New team folder name.
    """

    __slots__ = [
        '_name_value',
        '_name_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_folder_id=None,
                 name=None):
        super(TeamFolderRenameArg, self).__init__(team_folder_id)
        self._name_value = None
        self._name_present = False
        if name is not None:
            self.name = name

    @property
    def name(self):
        """
        New team folder name.

        :rtype: str
        """
        if self._name_present:
            return self._name_value
        else:
            raise AttributeError("missing required field 'name'")

    @name.setter
    def name(self, val):
        val = self._name_validator.validate(val)
        self._name_value = val
        self._name_present = True

    @name.deleter
    def name(self):
        self._name_value = None
        self._name_present = False

    def __repr__(self):
        return 'TeamFolderRenameArg(team_folder_id={!r}, name={!r})'.format(
            self._team_folder_id_value,
            self._name_value,
        )

TeamFolderRenameArg_validator = bv.Struct(TeamFolderRenameArg)

class TeamFolderRenameError(BaseTeamFolderError):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar invalid_folder_name: The provided folder name cannot be used.
    :ivar folder_name_already_used: There is already a team folder with the same
        name.
    :ivar folder_name_reserved: The provided name cannot be used because it is
        reserved.
    """

    # Attribute is overwritten below the class definition
    invalid_folder_name = None
    # Attribute is overwritten below the class definition
    folder_name_already_used = None
    # Attribute is overwritten below the class definition
    folder_name_reserved = None

    def is_invalid_folder_name(self):
        """
        Check if the union tag is ``invalid_folder_name``.

        :rtype: bool
        """
        return self._tag == 'invalid_folder_name'

    def is_folder_name_already_used(self):
        """
        Check if the union tag is ``folder_name_already_used``.

        :rtype: bool
        """
        return self._tag == 'folder_name_already_used'

    def is_folder_name_reserved(self):
        """
        Check if the union tag is ``folder_name_reserved``.

        :rtype: bool
        """
        return self._tag == 'folder_name_reserved'

    def __repr__(self):
        return 'TeamFolderRenameError(%r, %r)' % (self._tag, self._value)

TeamFolderRenameError_validator = bv.Union(TeamFolderRenameError)

class TeamFolderStatus(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar active: The team folder and sub-folders are available to all members.
    :ivar archived: The team folder is not accessible outside of the team folder
        manager.
    :ivar archive_in_progress: The team folder is not accessible outside of the
        team folder manager.
    """

    _catch_all = 'other'
    # Attribute is overwritten below the class definition
    active = None
    # Attribute is overwritten below the class definition
    archived = None
    # Attribute is overwritten below the class definition
    archive_in_progress = None
    # Attribute is overwritten below the class definition
    other = None

    def is_active(self):
        """
        Check if the union tag is ``active``.

        :rtype: bool
        """
        return self._tag == 'active'

    def is_archived(self):
        """
        Check if the union tag is ``archived``.

        :rtype: bool
        """
        return self._tag == 'archived'

    def is_archive_in_progress(self):
        """
        Check if the union tag is ``archive_in_progress``.

        :rtype: bool
        """
        return self._tag == 'archive_in_progress'

    def is_other(self):
        """
        Check if the union tag is ``other``.

        :rtype: bool
        """
        return self._tag == 'other'

    def __repr__(self):
        return 'TeamFolderStatus(%r, %r)' % (self._tag, self._value)

TeamFolderStatus_validator = bv.Union(TeamFolderStatus)

class TeamGetInfoResult(object):
    """
    :ivar name: The name of the team.
    :ivar team_id: The ID of the team.
    :ivar num_licensed_users: The number of licenses available to the team.
    :ivar num_provisioned_users: The number of accounts that have been invited
        or are already active members of the team.
    """

    __slots__ = [
        '_name_value',
        '_name_present',
        '_team_id_value',
        '_team_id_present',
        '_num_licensed_users_value',
        '_num_licensed_users_present',
        '_num_provisioned_users_value',
        '_num_provisioned_users_present',
        '_policies_value',
        '_policies_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 name=None,
                 team_id=None,
                 num_licensed_users=None,
                 num_provisioned_users=None,
                 policies=None):
        self._name_value = None
        self._name_present = False
        self._team_id_value = None
        self._team_id_present = False
        self._num_licensed_users_value = None
        self._num_licensed_users_present = False
        self._num_provisioned_users_value = None
        self._num_provisioned_users_present = False
        self._policies_value = None
        self._policies_present = False
        if name is not None:
            self.name = name
        if team_id is not None:
            self.team_id = team_id
        if num_licensed_users is not None:
            self.num_licensed_users = num_licensed_users
        if num_provisioned_users is not None:
            self.num_provisioned_users = num_provisioned_users
        if policies is not None:
            self.policies = policies

    @property
    def name(self):
        """
        The name of the team.

        :rtype: str
        """
        if self._name_present:
            return self._name_value
        else:
            raise AttributeError("missing required field 'name'")

    @name.setter
    def name(self, val):
        val = self._name_validator.validate(val)
        self._name_value = val
        self._name_present = True

    @name.deleter
    def name(self):
        self._name_value = None
        self._name_present = False

    @property
    def team_id(self):
        """
        The ID of the team.

        :rtype: str
        """
        if self._team_id_present:
            return self._team_id_value
        else:
            raise AttributeError("missing required field 'team_id'")

    @team_id.setter
    def team_id(self, val):
        val = self._team_id_validator.validate(val)
        self._team_id_value = val
        self._team_id_present = True

    @team_id.deleter
    def team_id(self):
        self._team_id_value = None
        self._team_id_present = False

    @property
    def num_licensed_users(self):
        """
        The number of licenses available to the team.

        :rtype: long
        """
        if self._num_licensed_users_present:
            return self._num_licensed_users_value
        else:
            raise AttributeError("missing required field 'num_licensed_users'")

    @num_licensed_users.setter
    def num_licensed_users(self, val):
        val = self._num_licensed_users_validator.validate(val)
        self._num_licensed_users_value = val
        self._num_licensed_users_present = True

    @num_licensed_users.deleter
    def num_licensed_users(self):
        self._num_licensed_users_value = None
        self._num_licensed_users_present = False

    @property
    def num_provisioned_users(self):
        """
        The number of accounts that have been invited or are already active
        members of the team.

        :rtype: long
        """
        if self._num_provisioned_users_present:
            return self._num_provisioned_users_value
        else:
            raise AttributeError("missing required field 'num_provisioned_users'")

    @num_provisioned_users.setter
    def num_provisioned_users(self, val):
        val = self._num_provisioned_users_validator.validate(val)
        self._num_provisioned_users_value = val
        self._num_provisioned_users_present = True

    @num_provisioned_users.deleter
    def num_provisioned_users(self):
        self._num_provisioned_users_value = None
        self._num_provisioned_users_present = False

    @property
    def policies(self):
        """
        :rtype: team_policies.TeamMemberPolicies_validator
        """
        if self._policies_present:
            return self._policies_value
        else:
            raise AttributeError("missing required field 'policies'")

    @policies.setter
    def policies(self, val):
        self._policies_validator.validate_type_only(val)
        self._policies_value = val
        self._policies_present = True

    @policies.deleter
    def policies(self):
        self._policies_value = None
        self._policies_present = False

    def __repr__(self):
        return 'TeamGetInfoResult(name={!r}, team_id={!r}, num_licensed_users={!r}, num_provisioned_users={!r}, policies={!r})'.format(
            self._name_value,
            self._team_id_value,
            self._num_licensed_users_value,
            self._num_provisioned_users_value,
            self._policies_value,
        )

TeamGetInfoResult_validator = bv.Struct(TeamGetInfoResult)

class TeamMemberInfo(object):
    """
    Information about a team member.

    :ivar profile: Profile of a user as a member of a team.
    :ivar role: The user's role in the team.
    """

    __slots__ = [
        '_profile_value',
        '_profile_present',
        '_role_value',
        '_role_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 profile=None,
                 role=None):
        self._profile_value = None
        self._profile_present = False
        self._role_value = None
        self._role_present = False
        if profile is not None:
            self.profile = profile
        if role is not None:
            self.role = role

    @property
    def profile(self):
        """
        Profile of a user as a member of a team.

        :rtype: TeamMemberProfile
        """
        if self._profile_present:
            return self._profile_value
        else:
            raise AttributeError("missing required field 'profile'")

    @profile.setter
    def profile(self, val):
        self._profile_validator.validate_type_only(val)
        self._profile_value = val
        self._profile_present = True

    @profile.deleter
    def profile(self):
        self._profile_value = None
        self._profile_present = False

    @property
    def role(self):
        """
        The user's role in the team.

        :rtype: AdminTier
        """
        if self._role_present:
            return self._role_value
        else:
            raise AttributeError("missing required field 'role'")

    @role.setter
    def role(self, val):
        self._role_validator.validate_type_only(val)
        self._role_value = val
        self._role_present = True

    @role.deleter
    def role(self):
        self._role_value = None
        self._role_present = False

    def __repr__(self):
        return 'TeamMemberInfo(profile={!r}, role={!r})'.format(
            self._profile_value,
            self._role_value,
        )

TeamMemberInfo_validator = bv.Struct(TeamMemberInfo)

class TeamMemberProfile(MemberProfile):
    """
    Profile of a user as a member of a team.

    :ivar groups: List of group IDs of groups that the user belongs to.
    """

    __slots__ = [
        '_groups_value',
        '_groups_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 team_member_id=None,
                 email=None,
                 email_verified=None,
                 status=None,
                 name=None,
                 membership_type=None,
                 groups=None,
                 external_id=None,
                 account_id=None,
                 joined_on=None,
                 persistent_id=None):
        super(TeamMemberProfile, self).__init__(team_member_id,
                                                email,
                                                email_verified,
                                                status,
                                                name,
                                                membership_type,
                                                external_id,
                                                account_id,
                                                joined_on,
                                                persistent_id)
        self._groups_value = None
        self._groups_present = False
        if groups is not None:
            self.groups = groups

    @property
    def groups(self):
        """
        List of group IDs of groups that the user belongs to.

        :rtype: list of [str]
        """
        if self._groups_present:
            return self._groups_value
        else:
            raise AttributeError("missing required field 'groups'")

    @groups.setter
    def groups(self, val):
        val = self._groups_validator.validate(val)
        self._groups_value = val
        self._groups_present = True

    @groups.deleter
    def groups(self):
        self._groups_value = None
        self._groups_present = False

    def __repr__(self):
        return 'TeamMemberProfile(team_member_id={!r}, email={!r}, email_verified={!r}, status={!r}, name={!r}, membership_type={!r}, groups={!r}, external_id={!r}, account_id={!r}, joined_on={!r}, persistent_id={!r})'.format(
            self._team_member_id_value,
            self._email_value,
            self._email_verified_value,
            self._status_value,
            self._name_value,
            self._membership_type_value,
            self._groups_value,
            self._external_id_value,
            self._account_id_value,
            self._joined_on_value,
            self._persistent_id_value,
        )

TeamMemberProfile_validator = bv.Struct(TeamMemberProfile)

class TeamMemberStatus(bb.Union):
    """
    The user's status as a member of a specific team.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar active: User has successfully joined the team.
    :ivar invited: User has been invited to a team, but has not joined the team
        yet.
    :ivar suspended: User is no longer a member of the team, but the account can
        be un-suspended, re-establishing the user as a team member.
    :ivar RemovedStatus removed: User is no longer a member of the team. Removed
        users are only listed when include_removed is true in members/list.
    """

    _catch_all = None
    # Attribute is overwritten below the class definition
    active = None
    # Attribute is overwritten below the class definition
    invited = None
    # Attribute is overwritten below the class definition
    suspended = None

    @classmethod
    def removed(cls, val):
        """
        Create an instance of this class set to the ``removed`` tag with value
        ``val``.

        :param RemovedStatus val:
        :rtype: TeamMemberStatus
        """
        return cls('removed', val)

    def is_active(self):
        """
        Check if the union tag is ``active``.

        :rtype: bool
        """
        return self._tag == 'active'

    def is_invited(self):
        """
        Check if the union tag is ``invited``.

        :rtype: bool
        """
        return self._tag == 'invited'

    def is_suspended(self):
        """
        Check if the union tag is ``suspended``.

        :rtype: bool
        """
        return self._tag == 'suspended'

    def is_removed(self):
        """
        Check if the union tag is ``removed``.

        :rtype: bool
        """
        return self._tag == 'removed'

    def get_removed(self):
        """
        User is no longer a member of the team. Removed users are only listed
        when include_removed is true in members/list.

        Only call this if :meth:`is_removed` is true.

        :rtype: RemovedStatus
        """
        if not self.is_removed():
            raise AttributeError("tag 'removed' not set")
        return self._value

    def __repr__(self):
        return 'TeamMemberStatus(%r, %r)' % (self._tag, self._value)

TeamMemberStatus_validator = bv.Union(TeamMemberStatus)

class TeamMembershipType(bb.Union):
    """
    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar full: User uses a license and has full access to team resources like
        the shared quota.
    :ivar limited: User does not have access to the shared quota and team admins
        have restricted administrative control.
    """

    _catch_all = None
    # Attribute is overwritten below the class definition
    full = None
    # Attribute is overwritten below the class definition
    limited = None

    def is_full(self):
        """
        Check if the union tag is ``full``.

        :rtype: bool
        """
        return self._tag == 'full'

    def is_limited(self):
        """
        Check if the union tag is ``limited``.

        :rtype: bool
        """
        return self._tag == 'limited'

    def __repr__(self):
        return 'TeamMembershipType(%r, %r)' % (self._tag, self._value)

TeamMembershipType_validator = bv.Union(TeamMembershipType)

class UpdatePropertyTemplateArg(object):
    """
    :ivar template_id: An identifier for property template added by
        :meth:`dropbox.dropbox.Dropbox.team_properties_template_add`.
    :ivar name: A display name for the property template. Property template
        names can be up to 256 bytes.
    :ivar description: Description for new property template. Property template
        descriptions can be up to 1024 bytes.
    :ivar add_fields: This is a list of custom properties to add to the property
        template. There can be up to 64 properties in a single property
        template.
    """

    __slots__ = [
        '_template_id_value',
        '_template_id_present',
        '_name_value',
        '_name_present',
        '_description_value',
        '_description_present',
        '_add_fields_value',
        '_add_fields_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 template_id=None,
                 name=None,
                 description=None,
                 add_fields=None):
        self._template_id_value = None
        self._template_id_present = False
        self._name_value = None
        self._name_present = False
        self._description_value = None
        self._description_present = False
        self._add_fields_value = None
        self._add_fields_present = False
        if template_id is not None:
            self.template_id = template_id
        if name is not None:
            self.name = name
        if description is not None:
            self.description = description
        if add_fields is not None:
            self.add_fields = add_fields

    @property
    def template_id(self):
        """
        An identifier for property template added by
        :meth:`dropbox.dropbox.Dropbox.team_properties_template_add`.

        :rtype: str
        """
        if self._template_id_present:
            return self._template_id_value
        else:
            raise AttributeError("missing required field 'template_id'")

    @template_id.setter
    def template_id(self, val):
        val = self._template_id_validator.validate(val)
        self._template_id_value = val
        self._template_id_present = True

    @template_id.deleter
    def template_id(self):
        self._template_id_value = None
        self._template_id_present = False

    @property
    def name(self):
        """
        A display name for the property template. Property template names can be
        up to 256 bytes.

        :rtype: str
        """
        if self._name_present:
            return self._name_value
        else:
            return None

    @name.setter
    def name(self, val):
        if val is None:
            del self.name
            return
        val = self._name_validator.validate(val)
        self._name_value = val
        self._name_present = True

    @name.deleter
    def name(self):
        self._name_value = None
        self._name_present = False

    @property
    def description(self):
        """
        Description for new property template. Property template descriptions
        can be up to 1024 bytes.

        :rtype: str
        """
        if self._description_present:
            return self._description_value
        else:
            return None

    @description.setter
    def description(self, val):
        if val is None:
            del self.description
            return
        val = self._description_validator.validate(val)
        self._description_value = val
        self._description_present = True

    @description.deleter
    def description(self):
        self._description_value = None
        self._description_present = False

    @property
    def add_fields(self):
        """
        This is a list of custom properties to add to the property template.
        There can be up to 64 properties in a single property template.

        :rtype: list of [properties.PropertyFieldTemplate_validator]
        """
        if self._add_fields_present:
            return self._add_fields_value
        else:
            return None

    @add_fields.setter
    def add_fields(self, val):
        if val is None:
            del self.add_fields
            return
        val = self._add_fields_validator.validate(val)
        self._add_fields_value = val
        self._add_fields_present = True

    @add_fields.deleter
    def add_fields(self):
        self._add_fields_value = None
        self._add_fields_present = False

    def __repr__(self):
        return 'UpdatePropertyTemplateArg(template_id={!r}, name={!r}, description={!r}, add_fields={!r})'.format(
            self._template_id_value,
            self._name_value,
            self._description_value,
            self._add_fields_value,
        )

UpdatePropertyTemplateArg_validator = bv.Struct(UpdatePropertyTemplateArg)

class UpdatePropertyTemplateResult(object):
    """
    :ivar template_id: An identifier for property template added by
        :meth:`dropbox.dropbox.Dropbox.team_properties_template_add`.
    """

    __slots__ = [
        '_template_id_value',
        '_template_id_present',
    ]

    _has_required_fields = True

    def __init__(self,
                 template_id=None):
        self._template_id_value = None
        self._template_id_present = False
        if template_id is not None:
            self.template_id = template_id

    @property
    def template_id(self):
        """
        An identifier for property template added by
        :meth:`dropbox.dropbox.Dropbox.team_properties_template_add`.

        :rtype: str
        """
        if self._template_id_present:
            return self._template_id_value
        else:
            raise AttributeError("missing required field 'template_id'")

    @template_id.setter
    def template_id(self, val):
        val = self._template_id_validator.validate(val)
        self._template_id_value = val
        self._template_id_present = True

    @template_id.deleter
    def template_id(self):
        self._template_id_value = None
        self._template_id_present = False

    def __repr__(self):
        return 'UpdatePropertyTemplateResult(template_id={!r})'.format(
            self._template_id_value,
        )

UpdatePropertyTemplateResult_validator = bv.Struct(UpdatePropertyTemplateResult)

class UserSelectorArg(bb.Union):
    """
    Argument for selecting a single user, either by team_member_id, external_id
    or email.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.
    """

    _catch_all = None

    @classmethod
    def team_member_id(cls, val):
        """
        Create an instance of this class set to the ``team_member_id`` tag with
        value ``val``.

        :param str val:
        :rtype: UserSelectorArg
        """
        return cls('team_member_id', val)

    @classmethod
    def external_id(cls, val):
        """
        Create an instance of this class set to the ``external_id`` tag with
        value ``val``.

        :param str val:
        :rtype: UserSelectorArg
        """
        return cls('external_id', val)

    @classmethod
    def email(cls, val):
        """
        Create an instance of this class set to the ``email`` tag with value
        ``val``.

        :param str val:
        :rtype: UserSelectorArg
        """
        return cls('email', val)

    def is_team_member_id(self):
        """
        Check if the union tag is ``team_member_id``.

        :rtype: bool
        """
        return self._tag == 'team_member_id'

    def is_external_id(self):
        """
        Check if the union tag is ``external_id``.

        :rtype: bool
        """
        return self._tag == 'external_id'

    def is_email(self):
        """
        Check if the union tag is ``email``.

        :rtype: bool
        """
        return self._tag == 'email'

    def get_team_member_id(self):
        """
        Only call this if :meth:`is_team_member_id` is true.

        :rtype: str
        """
        if not self.is_team_member_id():
            raise AttributeError("tag 'team_member_id' not set")
        return self._value

    def get_external_id(self):
        """
        Only call this if :meth:`is_external_id` is true.

        :rtype: str
        """
        if not self.is_external_id():
            raise AttributeError("tag 'external_id' not set")
        return self._value

    def get_email(self):
        """
        Only call this if :meth:`is_email` is true.

        :rtype: str
        """
        if not self.is_email():
            raise AttributeError("tag 'email' not set")
        return self._value

    def __repr__(self):
        return 'UserSelectorArg(%r, %r)' % (self._tag, self._value)

UserSelectorArg_validator = bv.Union(UserSelectorArg)

class UsersSelectorArg(bb.Union):
    """
    Argument for selecting a list of users, either by team_member_ids,
    external_ids or emails.

    This class acts as a tagged union. Only one of the ``is_*`` methods will
    return true. To get the associated value of a tag (if one exists), use the
    corresponding ``get_*`` method.

    :ivar list of [str] team_member_ids: List of member IDs.
    :ivar list of [str] external_ids: List of external user IDs.
    :ivar list of [str] emails: List of email addresses.
    """

    _catch_all = None

    @classmethod
    def team_member_ids(cls, val):
        """
        Create an instance of this class set to the ``team_member_ids`` tag with
        value ``val``.

        :param list of [str] val:
        :rtype: UsersSelectorArg
        """
        return cls('team_member_ids', val)

    @classmethod
    def external_ids(cls, val):
        """
        Create an instance of this class set to the ``external_ids`` tag with
        value ``val``.

        :param list of [str] val:
        :rtype: UsersSelectorArg
        """
        return cls('external_ids', val)

    @classmethod
    def emails(cls, val):
        """
        Create an instance of this class set to the ``emails`` tag with value
        ``val``.

        :param list of [str] val:
        :rtype: UsersSelectorArg
        """
        return cls('emails', val)

    def is_team_member_ids(self):
        """
        Check if the union tag is ``team_member_ids``.

        :rtype: bool
        """
        return self._tag == 'team_member_ids'

    def is_external_ids(self):
        """
        Check if the union tag is ``external_ids``.

        :rtype: bool
        """
        return self._tag == 'external_ids'

    def is_emails(self):
        """
        Check if the union tag is ``emails``.

        :rtype: bool
        """
        return self._tag == 'emails'

    def get_team_member_ids(self):
        """
        List of member IDs.

        Only call this if :meth:`is_team_member_ids` is true.

        :rtype: list of [str]
        """
        if not self.is_team_member_ids():
            raise AttributeError("tag 'team_member_ids' not set")
        return self._value

    def get_external_ids(self):
        """
        List of external user IDs.

        Only call this if :meth:`is_external_ids` is true.

        :rtype: list of [str]
        """
        if not self.is_external_ids():
            raise AttributeError("tag 'external_ids' not set")
        return self._value

    def get_emails(self):
        """
        List of email addresses.

        Only call this if :meth:`is_emails` is true.

        :rtype: list of [str]
        """
        if not self.is_emails():
            raise AttributeError("tag 'emails' not set")
        return self._value

    def __repr__(self):
        return 'UsersSelectorArg(%r, %r)' % (self._tag, self._value)

UsersSelectorArg_validator = bv.Union(UsersSelectorArg)

GroupsGetInfoResult_validator = bv.List(GroupsGetInfoItem_validator)
MembersGetInfoResult_validator = bv.List(MembersGetInfoItem_validator)
NumberPerDay_validator = bv.List(bv.Nullable(bv.UInt64()))
DeviceSession._session_id_validator = bv.String()
DeviceSession._ip_address_validator = bv.Nullable(bv.String())
DeviceSession._country_validator = bv.Nullable(bv.String())
DeviceSession._created_validator = bv.Nullable(common.DropboxTimestamp_validator)
DeviceSession._updated_validator = bv.Nullable(common.DropboxTimestamp_validator)
DeviceSession._all_field_names_ = set([
    'session_id',
    'ip_address',
    'country',
    'created',
    'updated',
])
DeviceSession._all_fields_ = [
    ('session_id', DeviceSession._session_id_validator),
    ('ip_address', DeviceSession._ip_address_validator),
    ('country', DeviceSession._country_validator),
    ('created', DeviceSession._created_validator),
    ('updated', DeviceSession._updated_validator),
]

ActiveWebSession._user_agent_validator = bv.String()
ActiveWebSession._os_validator = bv.String()
ActiveWebSession._browser_validator = bv.String()
ActiveWebSession._all_field_names_ = DeviceSession._all_field_names_.union(set([
    'user_agent',
    'os',
    'browser',
]))
ActiveWebSession._all_fields_ = DeviceSession._all_fields_ + [
    ('user_agent', ActiveWebSession._user_agent_validator),
    ('os', ActiveWebSession._os_validator),
    ('browser', ActiveWebSession._browser_validator),
]

AddPropertyTemplateArg._all_field_names_ = properties.PropertyGroupTemplate._all_field_names_.union(set([]))
AddPropertyTemplateArg._all_fields_ = properties.PropertyGroupTemplate._all_fields_ + []

AddPropertyTemplateResult._template_id_validator = properties.TemplateId_validator
AddPropertyTemplateResult._all_field_names_ = set(['template_id'])
AddPropertyTemplateResult._all_fields_ = [('template_id', AddPropertyTemplateResult._template_id_validator)]

AdminTier._team_admin_validator = bv.Void()
AdminTier._user_management_admin_validator = bv.Void()
AdminTier._support_admin_validator = bv.Void()
AdminTier._member_only_validator = bv.Void()
AdminTier._tagmap = {
    'team_admin': AdminTier._team_admin_validator,
    'user_management_admin': AdminTier._user_management_admin_validator,
    'support_admin': AdminTier._support_admin_validator,
    'member_only': AdminTier._member_only_validator,
}

AdminTier.team_admin = AdminTier('team_admin')
AdminTier.user_management_admin = AdminTier('user_management_admin')
AdminTier.support_admin = AdminTier('support_admin')
AdminTier.member_only = AdminTier('member_only')

ApiApp._app_id_validator = bv.String()
ApiApp._app_name_validator = bv.String()
ApiApp._publisher_validator = bv.Nullable(bv.String())
ApiApp._publisher_url_validator = bv.Nullable(bv.String())
ApiApp._linked_validator = bv.Nullable(common.DropboxTimestamp_validator)
ApiApp._is_app_folder_validator = bv.Boolean()
ApiApp._all_field_names_ = set([
    'app_id',
    'app_name',
    'publisher',
    'publisher_url',
    'linked',
    'is_app_folder',
])
ApiApp._all_fields_ = [
    ('app_id', ApiApp._app_id_validator),
    ('app_name', ApiApp._app_name_validator),
    ('publisher', ApiApp._publisher_validator),
    ('publisher_url', ApiApp._publisher_url_validator),
    ('linked', ApiApp._linked_validator),
    ('is_app_folder', ApiApp._is_app_folder_validator),
]

BaseDfbReport._start_date_validator = bv.String()
BaseDfbReport._all_field_names_ = set(['start_date'])
BaseDfbReport._all_fields_ = [('start_date', BaseDfbReport._start_date_validator)]

BaseTeamFolderError._access_error_validator = TeamFolderAccessError_validator
BaseTeamFolderError._status_error_validator = TeamFolderInvalidStatusError_validator
BaseTeamFolderError._other_validator = bv.Void()
BaseTeamFolderError._tagmap = {
    'access_error': BaseTeamFolderError._access_error_validator,
    'status_error': BaseTeamFolderError._status_error_validator,
    'other': BaseTeamFolderError._other_validator,
}

BaseTeamFolderError.other = BaseTeamFolderError('other')

DateRange._start_date_validator = bv.Nullable(common.Date_validator)
DateRange._end_date_validator = bv.Nullable(common.Date_validator)
DateRange._all_field_names_ = set([
    'start_date',
    'end_date',
])
DateRange._all_fields_ = [
    ('start_date', DateRange._start_date_validator),
    ('end_date', DateRange._end_date_validator),
]

DateRangeError._other_validator = bv.Void()
DateRangeError._tagmap = {
    'other': DateRangeError._other_validator,
}

DateRangeError.other = DateRangeError('other')

DesktopClientSession._host_name_validator = bv.String()
DesktopClientSession._client_type_validator = DesktopPlatform_validator
DesktopClientSession._client_version_validator = bv.String()
DesktopClientSession._platform_validator = bv.String()
DesktopClientSession._is_delete_on_unlink_supported_validator = bv.Boolean()
DesktopClientSession._all_field_names_ = DeviceSession._all_field_names_.union(set([
    'host_name',
    'client_type',
    'client_version',
    'platform',
    'is_delete_on_unlink_supported',
]))
DesktopClientSession._all_fields_ = DeviceSession._all_fields_ + [
    ('host_name', DesktopClientSession._host_name_validator),
    ('client_type', DesktopClientSession._client_type_validator),
    ('client_version', DesktopClientSession._client_version_validator),
    ('platform', DesktopClientSession._platform_validator),
    ('is_delete_on_unlink_supported', DesktopClientSession._is_delete_on_unlink_supported_validator),
]

DesktopPlatform._windows_validator = bv.Void()
DesktopPlatform._mac_validator = bv.Void()
DesktopPlatform._linux_validator = bv.Void()
DesktopPlatform._other_validator = bv.Void()
DesktopPlatform._tagmap = {
    'windows': DesktopPlatform._windows_validator,
    'mac': DesktopPlatform._mac_validator,
    'linux': DesktopPlatform._linux_validator,
    'other': DesktopPlatform._other_validator,
}

DesktopPlatform.windows = DesktopPlatform('windows')
DesktopPlatform.mac = DesktopPlatform('mac')
DesktopPlatform.linux = DesktopPlatform('linux')
DesktopPlatform.other = DesktopPlatform('other')

DeviceSessionArg._session_id_validator = bv.String()
DeviceSessionArg._team_member_id_validator = bv.String()
DeviceSessionArg._all_field_names_ = set([
    'session_id',
    'team_member_id',
])
DeviceSessionArg._all_fields_ = [
    ('session_id', DeviceSessionArg._session_id_validator),
    ('team_member_id', DeviceSessionArg._team_member_id_validator),
]

DevicesActive._windows_validator = NumberPerDay_validator
DevicesActive._macos_validator = NumberPerDay_validator
DevicesActive._linux_validator = NumberPerDay_validator
DevicesActive._ios_validator = NumberPerDay_validator
DevicesActive._android_validator = NumberPerDay_validator
DevicesActive._other_validator = NumberPerDay_validator
DevicesActive._total_validator = NumberPerDay_validator
DevicesActive._all_field_names_ = set([
    'windows',
    'macos',
    'linux',
    'ios',
    'android',
    'other',
    'total',
])
DevicesActive._all_fields_ = [
    ('windows', DevicesActive._windows_validator),
    ('macos', DevicesActive._macos_validator),
    ('linux', DevicesActive._linux_validator),
    ('ios', DevicesActive._ios_validator),
    ('android', DevicesActive._android_validator),
    ('other', DevicesActive._other_validator),
    ('total', DevicesActive._total_validator),
]

GetActivityReport._adds_validator = NumberPerDay_validator
GetActivityReport._edits_validator = NumberPerDay_validator
GetActivityReport._deletes_validator = NumberPerDay_validator
GetActivityReport._active_users_28_day_validator = NumberPerDay_validator
GetActivityReport._active_users_7_day_validator = NumberPerDay_validator
GetActivityReport._active_users_1_day_validator = NumberPerDay_validator
GetActivityReport._active_shared_folders_28_day_validator = NumberPerDay_validator
GetActivityReport._active_shared_folders_7_day_validator = NumberPerDay_validator
GetActivityReport._active_shared_folders_1_day_validator = NumberPerDay_validator
GetActivityReport._shared_links_created_validator = NumberPerDay_validator
GetActivityReport._shared_links_viewed_by_team_validator = NumberPerDay_validator
GetActivityReport._shared_links_viewed_by_outside_user_validator = NumberPerDay_validator
GetActivityReport._shared_links_viewed_by_not_logged_in_validator = NumberPerDay_validator
GetActivityReport._shared_links_viewed_total_validator = NumberPerDay_validator
GetActivityReport._all_field_names_ = BaseDfbReport._all_field_names_.union(set([
    'adds',
    'edits',
    'deletes',
    'active_users_28_day',
    'active_users_7_day',
    'active_users_1_day',
    'active_shared_folders_28_day',
    'active_shared_folders_7_day',
    'active_shared_folders_1_day',
    'shared_links_created',
    'shared_links_viewed_by_team',
    'shared_links_viewed_by_outside_user',
    'shared_links_viewed_by_not_logged_in',
    'shared_links_viewed_total',
]))
GetActivityReport._all_fields_ = BaseDfbReport._all_fields_ + [
    ('adds', GetActivityReport._adds_validator),
    ('edits', GetActivityReport._edits_validator),
    ('deletes', GetActivityReport._deletes_validator),
    ('active_users_28_day', GetActivityReport._active_users_28_day_validator),
    ('active_users_7_day', GetActivityReport._active_users_7_day_validator),
    ('active_users_1_day', GetActivityReport._active_users_1_day_validator),
    ('active_shared_folders_28_day', GetActivityReport._active_shared_folders_28_day_validator),
    ('active_shared_folders_7_day', GetActivityReport._active_shared_folders_7_day_validator),
    ('active_shared_folders_1_day', GetActivityReport._active_shared_folders_1_day_validator),
    ('shared_links_created', GetActivityReport._shared_links_created_validator),
    ('shared_links_viewed_by_team', GetActivityReport._shared_links_viewed_by_team_validator),
    ('shared_links_viewed_by_outside_user', GetActivityReport._shared_links_viewed_by_outside_user_validator),
    ('shared_links_viewed_by_not_logged_in', GetActivityReport._shared_links_viewed_by_not_logged_in_validator),
    ('shared_links_viewed_total', GetActivityReport._shared_links_viewed_total_validator),
]

GetDevicesReport._active_1_day_validator = DevicesActive_validator
GetDevicesReport._active_7_day_validator = DevicesActive_validator
GetDevicesReport._active_28_day_validator = DevicesActive_validator
GetDevicesReport._all_field_names_ = BaseDfbReport._all_field_names_.union(set([
    'active_1_day',
    'active_7_day',
    'active_28_day',
]))
GetDevicesReport._all_fields_ = BaseDfbReport._all_fields_ + [
    ('active_1_day', GetDevicesReport._active_1_day_validator),
    ('active_7_day', GetDevicesReport._active_7_day_validator),
    ('active_28_day', GetDevicesReport._active_28_day_validator),
]

GetMembershipReport._team_size_validator = NumberPerDay_validator
GetMembershipReport._pending_invites_validator = NumberPerDay_validator
GetMembershipReport._members_joined_validator = NumberPerDay_validator
GetMembershipReport._suspended_members_validator = NumberPerDay_validator
GetMembershipReport._licenses_validator = NumberPerDay_validator
GetMembershipReport._all_field_names_ = BaseDfbReport._all_field_names_.union(set([
    'team_size',
    'pending_invites',
    'members_joined',
    'suspended_members',
    'licenses',
]))
GetMembershipReport._all_fields_ = BaseDfbReport._all_fields_ + [
    ('team_size', GetMembershipReport._team_size_validator),
    ('pending_invites', GetMembershipReport._pending_invites_validator),
    ('members_joined', GetMembershipReport._members_joined_validator),
    ('suspended_members', GetMembershipReport._suspended_members_validator),
    ('licenses', GetMembershipReport._licenses_validator),
]

GetStorageReport._total_usage_validator = NumberPerDay_validator
GetStorageReport._shared_usage_validator = NumberPerDay_validator
GetStorageReport._unshared_usage_validator = NumberPerDay_validator
GetStorageReport._shared_folders_validator = NumberPerDay_validator
GetStorageReport._member_storage_map_validator = bv.List(bv.List(StorageBucket_validator))
GetStorageReport._all_field_names_ = BaseDfbReport._all_field_names_.union(set([
    'total_usage',
    'shared_usage',
    'unshared_usage',
    'shared_folders',
    'member_storage_map',
]))
GetStorageReport._all_fields_ = BaseDfbReport._all_fields_ + [
    ('total_usage', GetStorageReport._total_usage_validator),
    ('shared_usage', GetStorageReport._shared_usage_validator),
    ('unshared_usage', GetStorageReport._unshared_usage_validator),
    ('shared_folders', GetStorageReport._shared_folders_validator),
    ('member_storage_map', GetStorageReport._member_storage_map_validator),
]

GroupAccessType._member_validator = bv.Void()
GroupAccessType._owner_validator = bv.Void()
GroupAccessType._tagmap = {
    'member': GroupAccessType._member_validator,
    'owner': GroupAccessType._owner_validator,
}

GroupAccessType.member = GroupAccessType('member')
GroupAccessType.owner = GroupAccessType('owner')

GroupCreateArg._group_name_validator = bv.String()
GroupCreateArg._group_external_id_validator = bv.Nullable(team_common.GroupExternalId_validator)
GroupCreateArg._group_management_type_validator = bv.Nullable(team_common.GroupManagementType_validator)
GroupCreateArg._all_field_names_ = set([
    'group_name',
    'group_external_id',
    'group_management_type',
])
GroupCreateArg._all_fields_ = [
    ('group_name', GroupCreateArg._group_name_validator),
    ('group_external_id', GroupCreateArg._group_external_id_validator),
    ('group_management_type', GroupCreateArg._group_management_type_validator),
]

GroupCreateError._group_name_already_used_validator = bv.Void()
GroupCreateError._group_name_invalid_validator = bv.Void()
GroupCreateError._external_id_already_in_use_validator = bv.Void()
GroupCreateError._system_managed_group_disallowed_validator = bv.Void()
GroupCreateError._other_validator = bv.Void()
GroupCreateError._tagmap = {
    'group_name_already_used': GroupCreateError._group_name_already_used_validator,
    'group_name_invalid': GroupCreateError._group_name_invalid_validator,
    'external_id_already_in_use': GroupCreateError._external_id_already_in_use_validator,
    'system_managed_group_disallowed': GroupCreateError._system_managed_group_disallowed_validator,
    'other': GroupCreateError._other_validator,
}

GroupCreateError.group_name_already_used = GroupCreateError('group_name_already_used')
GroupCreateError.group_name_invalid = GroupCreateError('group_name_invalid')
GroupCreateError.external_id_already_in_use = GroupCreateError('external_id_already_in_use')
GroupCreateError.system_managed_group_disallowed = GroupCreateError('system_managed_group_disallowed')
GroupCreateError.other = GroupCreateError('other')

GroupSelectorError._group_not_found_validator = bv.Void()
GroupSelectorError._other_validator = bv.Void()
GroupSelectorError._tagmap = {
    'group_not_found': GroupSelectorError._group_not_found_validator,
    'other': GroupSelectorError._other_validator,
}

GroupSelectorError.group_not_found = GroupSelectorError('group_not_found')
GroupSelectorError.other = GroupSelectorError('other')

GroupSelectorWithTeamGroupError._system_managed_group_disallowed_validator = bv.Void()
GroupSelectorWithTeamGroupError._tagmap = {
    'system_managed_group_disallowed': GroupSelectorWithTeamGroupError._system_managed_group_disallowed_validator,
}
GroupSelectorWithTeamGroupError._tagmap.update(GroupSelectorError._tagmap)

GroupSelectorWithTeamGroupError.system_managed_group_disallowed = GroupSelectorWithTeamGroupError('system_managed_group_disallowed')

GroupDeleteError._group_already_deleted_validator = bv.Void()
GroupDeleteError._tagmap = {
    'group_already_deleted': GroupDeleteError._group_already_deleted_validator,
}
GroupDeleteError._tagmap.update(GroupSelectorWithTeamGroupError._tagmap)

GroupDeleteError.group_already_deleted = GroupDeleteError('group_already_deleted')

GroupFullInfo._members_validator = bv.Nullable(bv.List(GroupMemberInfo_validator))
GroupFullInfo._created_validator = bv.UInt64()
GroupFullInfo._all_field_names_ = team_common.GroupSummary._all_field_names_.union(set([
    'members',
    'created',
]))
GroupFullInfo._all_fields_ = team_common.GroupSummary._all_fields_ + [
    ('members', GroupFullInfo._members_validator),
    ('created', GroupFullInfo._created_validator),
]

GroupMemberInfo._profile_validator = MemberProfile_validator
GroupMemberInfo._access_type_validator = GroupAccessType_validator
GroupMemberInfo._all_field_names_ = set([
    'profile',
    'access_type',
])
GroupMemberInfo._all_fields_ = [
    ('profile', GroupMemberInfo._profile_validator),
    ('access_type', GroupMemberInfo._access_type_validator),
]

GroupMemberSelector._group_validator = GroupSelector_validator
GroupMemberSelector._user_validator = UserSelectorArg_validator
GroupMemberSelector._all_field_names_ = set([
    'group',
    'user',
])
GroupMemberSelector._all_fields_ = [
    ('group', GroupMemberSelector._group_validator),
    ('user', GroupMemberSelector._user_validator),
]

GroupMemberSelectorError._member_not_in_group_validator = bv.Void()
GroupMemberSelectorError._tagmap = {
    'member_not_in_group': GroupMemberSelectorError._member_not_in_group_validator,
}
GroupMemberSelectorError._tagmap.update(GroupSelectorWithTeamGroupError._tagmap)

GroupMemberSelectorError.member_not_in_group = GroupMemberSelectorError('member_not_in_group')

GroupMemberSetAccessTypeError._user_cannot_be_manager_of_company_managed_group_validator = bv.Void()
GroupMemberSetAccessTypeError._tagmap = {
    'user_cannot_be_manager_of_company_managed_group': GroupMemberSetAccessTypeError._user_cannot_be_manager_of_company_managed_group_validator,
}
GroupMemberSetAccessTypeError._tagmap.update(GroupMemberSelectorError._tagmap)

GroupMemberSetAccessTypeError.user_cannot_be_manager_of_company_managed_group = GroupMemberSetAccessTypeError('user_cannot_be_manager_of_company_managed_group')

IncludeMembersArg._return_members_validator = bv.Boolean()
IncludeMembersArg._all_field_names_ = set(['return_members'])
IncludeMembersArg._all_fields_ = [('return_members', IncludeMembersArg._return_members_validator)]

GroupMembersAddArg._group_validator = GroupSelector_validator
GroupMembersAddArg._members_validator = bv.List(MemberAccess_validator)
GroupMembersAddArg._all_field_names_ = IncludeMembersArg._all_field_names_.union(set([
    'group',
    'members',
]))
GroupMembersAddArg._all_fields_ = IncludeMembersArg._all_fields_ + [
    ('group', GroupMembersAddArg._group_validator),
    ('members', GroupMembersAddArg._members_validator),
]

GroupMembersAddError._duplicate_user_validator = bv.Void()
GroupMembersAddError._group_not_in_team_validator = bv.Void()
GroupMembersAddError._members_not_in_team_validator = bv.List(bv.String())
GroupMembersAddError._users_not_found_validator = bv.List(bv.String())
GroupMembersAddError._user_must_be_active_to_be_owner_validator = bv.Void()
GroupMembersAddError._user_cannot_be_manager_of_company_managed_group_validator = bv.List(bv.String())
GroupMembersAddError._tagmap = {
    'duplicate_user': GroupMembersAddError._duplicate_user_validator,
    'group_not_in_team': GroupMembersAddError._group_not_in_team_validator,
    'members_not_in_team': GroupMembersAddError._members_not_in_team_validator,
    'users_not_found': GroupMembersAddError._users_not_found_validator,
    'user_must_be_active_to_be_owner': GroupMembersAddError._user_must_be_active_to_be_owner_validator,
    'user_cannot_be_manager_of_company_managed_group': GroupMembersAddError._user_cannot_be_manager_of_company_managed_group_validator,
}
GroupMembersAddError._tagmap.update(GroupSelectorWithTeamGroupError._tagmap)

GroupMembersAddError.duplicate_user = GroupMembersAddError('duplicate_user')
GroupMembersAddError.group_not_in_team = GroupMembersAddError('group_not_in_team')
GroupMembersAddError.user_must_be_active_to_be_owner = GroupMembersAddError('user_must_be_active_to_be_owner')

GroupMembersChangeResult._group_info_validator = GroupFullInfo_validator
GroupMembersChangeResult._async_job_id_validator = async.AsyncJobId_validator
GroupMembersChangeResult._all_field_names_ = set([
    'group_info',
    'async_job_id',
])
GroupMembersChangeResult._all_fields_ = [
    ('group_info', GroupMembersChangeResult._group_info_validator),
    ('async_job_id', GroupMembersChangeResult._async_job_id_validator),
]

GroupMembersRemoveArg._group_validator = GroupSelector_validator
GroupMembersRemoveArg._users_validator = bv.List(UserSelectorArg_validator)
GroupMembersRemoveArg._all_field_names_ = IncludeMembersArg._all_field_names_.union(set([
    'group',
    'users',
]))
GroupMembersRemoveArg._all_fields_ = IncludeMembersArg._all_fields_ + [
    ('group', GroupMembersRemoveArg._group_validator),
    ('users', GroupMembersRemoveArg._users_validator),
]

GroupMembersSelectorError._member_not_in_group_validator = bv.Void()
GroupMembersSelectorError._tagmap = {
    'member_not_in_group': GroupMembersSelectorError._member_not_in_group_validator,
}
GroupMembersSelectorError._tagmap.update(GroupSelectorWithTeamGroupError._tagmap)

GroupMembersSelectorError.member_not_in_group = GroupMembersSelectorError('member_not_in_group')

GroupMembersRemoveError._group_not_in_team_validator = bv.Void()
GroupMembersRemoveError._members_not_in_team_validator = bv.List(bv.String())
GroupMembersRemoveError._users_not_found_validator = bv.List(bv.String())
GroupMembersRemoveError._tagmap = {
    'group_not_in_team': GroupMembersRemoveError._group_not_in_team_validator,
    'members_not_in_team': GroupMembersRemoveError._members_not_in_team_validator,
    'users_not_found': GroupMembersRemoveError._users_not_found_validator,
}
GroupMembersRemoveError._tagmap.update(GroupMembersSelectorError._tagmap)

GroupMembersRemoveError.group_not_in_team = GroupMembersRemoveError('group_not_in_team')

GroupMembersSelector._group_validator = GroupSelector_validator
GroupMembersSelector._users_validator = UsersSelectorArg_validator
GroupMembersSelector._all_field_names_ = set([
    'group',
    'users',
])
GroupMembersSelector._all_fields_ = [
    ('group', GroupMembersSelector._group_validator),
    ('users', GroupMembersSelector._users_validator),
]

GroupMembersSetAccessTypeArg._access_type_validator = GroupAccessType_validator
GroupMembersSetAccessTypeArg._return_members_validator = bv.Boolean()
GroupMembersSetAccessTypeArg._all_field_names_ = GroupMemberSelector._all_field_names_.union(set([
    'access_type',
    'return_members',
]))
GroupMembersSetAccessTypeArg._all_fields_ = GroupMemberSelector._all_fields_ + [
    ('access_type', GroupMembersSetAccessTypeArg._access_type_validator),
    ('return_members', GroupMembersSetAccessTypeArg._return_members_validator),
]

GroupSelector._group_id_validator = team_common.GroupId_validator
GroupSelector._group_external_id_validator = team_common.GroupExternalId_validator
GroupSelector._tagmap = {
    'group_id': GroupSelector._group_id_validator,
    'group_external_id': GroupSelector._group_external_id_validator,
}

GroupUpdateArgs._group_validator = GroupSelector_validator
GroupUpdateArgs._new_group_name_validator = bv.Nullable(bv.String())
GroupUpdateArgs._new_group_external_id_validator = bv.Nullable(team_common.GroupExternalId_validator)
GroupUpdateArgs._new_group_management_type_validator = bv.Nullable(team_common.GroupManagementType_validator)
GroupUpdateArgs._all_field_names_ = IncludeMembersArg._all_field_names_.union(set([
    'group',
    'new_group_name',
    'new_group_external_id',
    'new_group_management_type',
]))
GroupUpdateArgs._all_fields_ = IncludeMembersArg._all_fields_ + [
    ('group', GroupUpdateArgs._group_validator),
    ('new_group_name', GroupUpdateArgs._new_group_name_validator),
    ('new_group_external_id', GroupUpdateArgs._new_group_external_id_validator),
    ('new_group_management_type', GroupUpdateArgs._new_group_management_type_validator),
]

GroupUpdateError._group_name_already_used_validator = bv.Void()
GroupUpdateError._group_name_invalid_validator = bv.Void()
GroupUpdateError._external_id_already_in_use_validator = bv.Void()
GroupUpdateError._tagmap = {
    'group_name_already_used': GroupUpdateError._group_name_already_used_validator,
    'group_name_invalid': GroupUpdateError._group_name_invalid_validator,
    'external_id_already_in_use': GroupUpdateError._external_id_already_in_use_validator,
}
GroupUpdateError._tagmap.update(GroupSelectorWithTeamGroupError._tagmap)

GroupUpdateError.group_name_already_used = GroupUpdateError('group_name_already_used')
GroupUpdateError.group_name_invalid = GroupUpdateError('group_name_invalid')
GroupUpdateError.external_id_already_in_use = GroupUpdateError('external_id_already_in_use')

GroupsGetInfoError._group_not_on_team_validator = bv.Void()
GroupsGetInfoError._other_validator = bv.Void()
GroupsGetInfoError._tagmap = {
    'group_not_on_team': GroupsGetInfoError._group_not_on_team_validator,
    'other': GroupsGetInfoError._other_validator,
}

GroupsGetInfoError.group_not_on_team = GroupsGetInfoError('group_not_on_team')
GroupsGetInfoError.other = GroupsGetInfoError('other')

GroupsGetInfoItem._id_not_found_validator = bv.String()
GroupsGetInfoItem._group_info_validator = GroupFullInfo_validator
GroupsGetInfoItem._tagmap = {
    'id_not_found': GroupsGetInfoItem._id_not_found_validator,
    'group_info': GroupsGetInfoItem._group_info_validator,
}

GroupsListArg._limit_validator = bv.UInt32(min_value=1, max_value=1000)
GroupsListArg._all_field_names_ = set(['limit'])
GroupsListArg._all_fields_ = [('limit', GroupsListArg._limit_validator)]

GroupsListContinueArg._cursor_validator = bv.String()
GroupsListContinueArg._all_field_names_ = set(['cursor'])
GroupsListContinueArg._all_fields_ = [('cursor', GroupsListContinueArg._cursor_validator)]

GroupsListContinueError._invalid_cursor_validator = bv.Void()
GroupsListContinueError._other_validator = bv.Void()
GroupsListContinueError._tagmap = {
    'invalid_cursor': GroupsListContinueError._invalid_cursor_validator,
    'other': GroupsListContinueError._other_validator,
}

GroupsListContinueError.invalid_cursor = GroupsListContinueError('invalid_cursor')
GroupsListContinueError.other = GroupsListContinueError('other')

GroupsListResult._groups_validator = bv.List(team_common.GroupSummary_validator)
GroupsListResult._cursor_validator = bv.String()
GroupsListResult._has_more_validator = bv.Boolean()
GroupsListResult._all_field_names_ = set([
    'groups',
    'cursor',
    'has_more',
])
GroupsListResult._all_fields_ = [
    ('groups', GroupsListResult._groups_validator),
    ('cursor', GroupsListResult._cursor_validator),
    ('has_more', GroupsListResult._has_more_validator),
]

GroupsMembersListArg._group_validator = GroupSelector_validator
GroupsMembersListArg._limit_validator = bv.UInt32(min_value=1, max_value=1000)
GroupsMembersListArg._all_field_names_ = set([
    'group',
    'limit',
])
GroupsMembersListArg._all_fields_ = [
    ('group', GroupsMembersListArg._group_validator),
    ('limit', GroupsMembersListArg._limit_validator),
]

GroupsMembersListContinueArg._cursor_validator = bv.String()
GroupsMembersListContinueArg._all_field_names_ = set(['cursor'])
GroupsMembersListContinueArg._all_fields_ = [('cursor', GroupsMembersListContinueArg._cursor_validator)]

GroupsMembersListContinueError._invalid_cursor_validator = bv.Void()
GroupsMembersListContinueError._other_validator = bv.Void()
GroupsMembersListContinueError._tagmap = {
    'invalid_cursor': GroupsMembersListContinueError._invalid_cursor_validator,
    'other': GroupsMembersListContinueError._other_validator,
}

GroupsMembersListContinueError.invalid_cursor = GroupsMembersListContinueError('invalid_cursor')
GroupsMembersListContinueError.other = GroupsMembersListContinueError('other')

GroupsMembersListResult._members_validator = bv.List(GroupMemberInfo_validator)
GroupsMembersListResult._cursor_validator = bv.String()
GroupsMembersListResult._has_more_validator = bv.Boolean()
GroupsMembersListResult._all_field_names_ = set([
    'members',
    'cursor',
    'has_more',
])
GroupsMembersListResult._all_fields_ = [
    ('members', GroupsMembersListResult._members_validator),
    ('cursor', GroupsMembersListResult._cursor_validator),
    ('has_more', GroupsMembersListResult._has_more_validator),
]

GroupsPollError._access_denied_validator = bv.Void()
GroupsPollError._tagmap = {
    'access_denied': GroupsPollError._access_denied_validator,
}
GroupsPollError._tagmap.update(async.PollError._tagmap)

GroupsPollError.access_denied = GroupsPollError('access_denied')

GroupsSelector._group_ids_validator = bv.List(team_common.GroupId_validator)
GroupsSelector._group_external_ids_validator = bv.List(bv.String())
GroupsSelector._tagmap = {
    'group_ids': GroupsSelector._group_ids_validator,
    'group_external_ids': GroupsSelector._group_external_ids_validator,
}

ListMemberAppsArg._team_member_id_validator = bv.String()
ListMemberAppsArg._all_field_names_ = set(['team_member_id'])
ListMemberAppsArg._all_fields_ = [('team_member_id', ListMemberAppsArg._team_member_id_validator)]

ListMemberAppsError._member_not_found_validator = bv.Void()
ListMemberAppsError._other_validator = bv.Void()
ListMemberAppsError._tagmap = {
    'member_not_found': ListMemberAppsError._member_not_found_validator,
    'other': ListMemberAppsError._other_validator,
}

ListMemberAppsError.member_not_found = ListMemberAppsError('member_not_found')
ListMemberAppsError.other = ListMemberAppsError('other')

ListMemberAppsResult._linked_api_apps_validator = bv.List(ApiApp_validator)
ListMemberAppsResult._all_field_names_ = set(['linked_api_apps'])
ListMemberAppsResult._all_fields_ = [('linked_api_apps', ListMemberAppsResult._linked_api_apps_validator)]

ListMemberDevicesArg._team_member_id_validator = bv.String()
ListMemberDevicesArg._include_web_sessions_validator = bv.Boolean()
ListMemberDevicesArg._include_desktop_clients_validator = bv.Boolean()
ListMemberDevicesArg._include_mobile_clients_validator = bv.Boolean()
ListMemberDevicesArg._all_field_names_ = set([
    'team_member_id',
    'include_web_sessions',
    'include_desktop_clients',
    'include_mobile_clients',
])
ListMemberDevicesArg._all_fields_ = [
    ('team_member_id', ListMemberDevicesArg._team_member_id_validator),
    ('include_web_sessions', ListMemberDevicesArg._include_web_sessions_validator),
    ('include_desktop_clients', ListMemberDevicesArg._include_desktop_clients_validator),
    ('include_mobile_clients', ListMemberDevicesArg._include_mobile_clients_validator),
]

ListMemberDevicesError._member_not_found_validator = bv.Void()
ListMemberDevicesError._other_validator = bv.Void()
ListMemberDevicesError._tagmap = {
    'member_not_found': ListMemberDevicesError._member_not_found_validator,
    'other': ListMemberDevicesError._other_validator,
}

ListMemberDevicesError.member_not_found = ListMemberDevicesError('member_not_found')
ListMemberDevicesError.other = ListMemberDevicesError('other')

ListMemberDevicesResult._active_web_sessions_validator = bv.Nullable(bv.List(ActiveWebSession_validator))
ListMemberDevicesResult._desktop_client_sessions_validator = bv.Nullable(bv.List(DesktopClientSession_validator))
ListMemberDevicesResult._mobile_client_sessions_validator = bv.Nullable(bv.List(MobileClientSession_validator))
ListMemberDevicesResult._all_field_names_ = set([
    'active_web_sessions',
    'desktop_client_sessions',
    'mobile_client_sessions',
])
ListMemberDevicesResult._all_fields_ = [
    ('active_web_sessions', ListMemberDevicesResult._active_web_sessions_validator),
    ('desktop_client_sessions', ListMemberDevicesResult._desktop_client_sessions_validator),
    ('mobile_client_sessions', ListMemberDevicesResult._mobile_client_sessions_validator),
]

ListMembersAppsArg._cursor_validator = bv.Nullable(bv.String())
ListMembersAppsArg._all_field_names_ = set(['cursor'])
ListMembersAppsArg._all_fields_ = [('cursor', ListMembersAppsArg._cursor_validator)]

ListMembersAppsError._reset_validator = bv.Void()
ListMembersAppsError._other_validator = bv.Void()
ListMembersAppsError._tagmap = {
    'reset': ListMembersAppsError._reset_validator,
    'other': ListMembersAppsError._other_validator,
}

ListMembersAppsError.reset = ListMembersAppsError('reset')
ListMembersAppsError.other = ListMembersAppsError('other')

ListMembersAppsResult._apps_validator = bv.List(MemberLinkedApps_validator)
ListMembersAppsResult._has_more_validator = bv.Boolean()
ListMembersAppsResult._cursor_validator = bv.Nullable(bv.String())
ListMembersAppsResult._all_field_names_ = set([
    'apps',
    'has_more',
    'cursor',
])
ListMembersAppsResult._all_fields_ = [
    ('apps', ListMembersAppsResult._apps_validator),
    ('has_more', ListMembersAppsResult._has_more_validator),
    ('cursor', ListMembersAppsResult._cursor_validator),
]

ListMembersDevicesArg._cursor_validator = bv.Nullable(bv.String())
ListMembersDevicesArg._include_web_sessions_validator = bv.Boolean()
ListMembersDevicesArg._include_desktop_clients_validator = bv.Boolean()
ListMembersDevicesArg._include_mobile_clients_validator = bv.Boolean()
ListMembersDevicesArg._all_field_names_ = set([
    'cursor',
    'include_web_sessions',
    'include_desktop_clients',
    'include_mobile_clients',
])
ListMembersDevicesArg._all_fields_ = [
    ('cursor', ListMembersDevicesArg._cursor_validator),
    ('include_web_sessions', ListMembersDevicesArg._include_web_sessions_validator),
    ('include_desktop_clients', ListMembersDevicesArg._include_desktop_clients_validator),
    ('include_mobile_clients', ListMembersDevicesArg._include_mobile_clients_validator),
]

ListMembersDevicesError._reset_validator = bv.Void()
ListMembersDevicesError._other_validator = bv.Void()
ListMembersDevicesError._tagmap = {
    'reset': ListMembersDevicesError._reset_validator,
    'other': ListMembersDevicesError._other_validator,
}

ListMembersDevicesError.reset = ListMembersDevicesError('reset')
ListMembersDevicesError.other = ListMembersDevicesError('other')

ListMembersDevicesResult._devices_validator = bv.List(MemberDevices_validator)
ListMembersDevicesResult._has_more_validator = bv.Boolean()
ListMembersDevicesResult._cursor_validator = bv.Nullable(bv.String())
ListMembersDevicesResult._all_field_names_ = set([
    'devices',
    'has_more',
    'cursor',
])
ListMembersDevicesResult._all_fields_ = [
    ('devices', ListMembersDevicesResult._devices_validator),
    ('has_more', ListMembersDevicesResult._has_more_validator),
    ('cursor', ListMembersDevicesResult._cursor_validator),
]

ListTeamAppsArg._cursor_validator = bv.Nullable(bv.String())
ListTeamAppsArg._all_field_names_ = set(['cursor'])
ListTeamAppsArg._all_fields_ = [('cursor', ListTeamAppsArg._cursor_validator)]

ListTeamAppsError._reset_validator = bv.Void()
ListTeamAppsError._other_validator = bv.Void()
ListTeamAppsError._tagmap = {
    'reset': ListTeamAppsError._reset_validator,
    'other': ListTeamAppsError._other_validator,
}

ListTeamAppsError.reset = ListTeamAppsError('reset')
ListTeamAppsError.other = ListTeamAppsError('other')

ListTeamAppsResult._apps_validator = bv.List(MemberLinkedApps_validator)
ListTeamAppsResult._has_more_validator = bv.Boolean()
ListTeamAppsResult._cursor_validator = bv.Nullable(bv.String())
ListTeamAppsResult._all_field_names_ = set([
    'apps',
    'has_more',
    'cursor',
])
ListTeamAppsResult._all_fields_ = [
    ('apps', ListTeamAppsResult._apps_validator),
    ('has_more', ListTeamAppsResult._has_more_validator),
    ('cursor', ListTeamAppsResult._cursor_validator),
]

ListTeamDevicesArg._cursor_validator = bv.Nullable(bv.String())
ListTeamDevicesArg._include_web_sessions_validator = bv.Boolean()
ListTeamDevicesArg._include_desktop_clients_validator = bv.Boolean()
ListTeamDevicesArg._include_mobile_clients_validator = bv.Boolean()
ListTeamDevicesArg._all_field_names_ = set([
    'cursor',
    'include_web_sessions',
    'include_desktop_clients',
    'include_mobile_clients',
])
ListTeamDevicesArg._all_fields_ = [
    ('cursor', ListTeamDevicesArg._cursor_validator),
    ('include_web_sessions', ListTeamDevicesArg._include_web_sessions_validator),
    ('include_desktop_clients', ListTeamDevicesArg._include_desktop_clients_validator),
    ('include_mobile_clients', ListTeamDevicesArg._include_mobile_clients_validator),
]

ListTeamDevicesError._reset_validator = bv.Void()
ListTeamDevicesError._other_validator = bv.Void()
ListTeamDevicesError._tagmap = {
    'reset': ListTeamDevicesError._reset_validator,
    'other': ListTeamDevicesError._other_validator,
}

ListTeamDevicesError.reset = ListTeamDevicesError('reset')
ListTeamDevicesError.other = ListTeamDevicesError('other')

ListTeamDevicesResult._devices_validator = bv.List(MemberDevices_validator)
ListTeamDevicesResult._has_more_validator = bv.Boolean()
ListTeamDevicesResult._cursor_validator = bv.Nullable(bv.String())
ListTeamDevicesResult._all_field_names_ = set([
    'devices',
    'has_more',
    'cursor',
])
ListTeamDevicesResult._all_fields_ = [
    ('devices', ListTeamDevicesResult._devices_validator),
    ('has_more', ListTeamDevicesResult._has_more_validator),
    ('cursor', ListTeamDevicesResult._cursor_validator),
]

MemberAccess._user_validator = UserSelectorArg_validator
MemberAccess._access_type_validator = GroupAccessType_validator
MemberAccess._all_field_names_ = set([
    'user',
    'access_type',
])
MemberAccess._all_fields_ = [
    ('user', MemberAccess._user_validator),
    ('access_type', MemberAccess._access_type_validator),
]

MemberAddArg._member_email_validator = common.EmailAddress_validator
MemberAddArg._member_given_name_validator = common.NamePart_validator
MemberAddArg._member_surname_validator = common.NamePart_validator
MemberAddArg._member_external_id_validator = bv.Nullable(team_common.MemberExternalId_validator)
MemberAddArg._member_persistent_id_validator = bv.Nullable(bv.String())
MemberAddArg._send_welcome_email_validator = bv.Boolean()
MemberAddArg._role_validator = AdminTier_validator
MemberAddArg._all_field_names_ = set([
    'member_email',
    'member_given_name',
    'member_surname',
    'member_external_id',
    'member_persistent_id',
    'send_welcome_email',
    'role',
])
MemberAddArg._all_fields_ = [
    ('member_email', MemberAddArg._member_email_validator),
    ('member_given_name', MemberAddArg._member_given_name_validator),
    ('member_surname', MemberAddArg._member_surname_validator),
    ('member_external_id', MemberAddArg._member_external_id_validator),
    ('member_persistent_id', MemberAddArg._member_persistent_id_validator),
    ('send_welcome_email', MemberAddArg._send_welcome_email_validator),
    ('role', MemberAddArg._role_validator),
]

MemberAddResult._success_validator = TeamMemberInfo_validator
MemberAddResult._team_license_limit_validator = common.EmailAddress_validator
MemberAddResult._free_team_member_limit_reached_validator = common.EmailAddress_validator
MemberAddResult._user_already_on_team_validator = common.EmailAddress_validator
MemberAddResult._user_on_another_team_validator = common.EmailAddress_validator
MemberAddResult._user_already_paired_validator = common.EmailAddress_validator
MemberAddResult._user_migration_failed_validator = common.EmailAddress_validator
MemberAddResult._duplicate_external_member_id_validator = common.EmailAddress_validator
MemberAddResult._duplicate_member_persistent_id_validator = common.EmailAddress_validator
MemberAddResult._persistent_id_disabled_validator = common.EmailAddress_validator
MemberAddResult._user_creation_failed_validator = common.EmailAddress_validator
MemberAddResult._tagmap = {
    'success': MemberAddResult._success_validator,
    'team_license_limit': MemberAddResult._team_license_limit_validator,
    'free_team_member_limit_reached': MemberAddResult._free_team_member_limit_reached_validator,
    'user_already_on_team': MemberAddResult._user_already_on_team_validator,
    'user_on_another_team': MemberAddResult._user_on_another_team_validator,
    'user_already_paired': MemberAddResult._user_already_paired_validator,
    'user_migration_failed': MemberAddResult._user_migration_failed_validator,
    'duplicate_external_member_id': MemberAddResult._duplicate_external_member_id_validator,
    'duplicate_member_persistent_id': MemberAddResult._duplicate_member_persistent_id_validator,
    'persistent_id_disabled': MemberAddResult._persistent_id_disabled_validator,
    'user_creation_failed': MemberAddResult._user_creation_failed_validator,
}

MemberDevices._team_member_id_validator = bv.String()
MemberDevices._web_sessions_validator = bv.Nullable(bv.List(ActiveWebSession_validator))
MemberDevices._desktop_clients_validator = bv.Nullable(bv.List(DesktopClientSession_validator))
MemberDevices._mobile_clients_validator = bv.Nullable(bv.List(MobileClientSession_validator))
MemberDevices._all_field_names_ = set([
    'team_member_id',
    'web_sessions',
    'desktop_clients',
    'mobile_clients',
])
MemberDevices._all_fields_ = [
    ('team_member_id', MemberDevices._team_member_id_validator),
    ('web_sessions', MemberDevices._web_sessions_validator),
    ('desktop_clients', MemberDevices._desktop_clients_validator),
    ('mobile_clients', MemberDevices._mobile_clients_validator),
]

MemberLinkedApps._team_member_id_validator = bv.String()
MemberLinkedApps._linked_api_apps_validator = bv.List(ApiApp_validator)
MemberLinkedApps._all_field_names_ = set([
    'team_member_id',
    'linked_api_apps',
])
MemberLinkedApps._all_fields_ = [
    ('team_member_id', MemberLinkedApps._team_member_id_validator),
    ('linked_api_apps', MemberLinkedApps._linked_api_apps_validator),
]

MemberProfile._team_member_id_validator = team_common.TeamMemberId_validator
MemberProfile._external_id_validator = bv.Nullable(bv.String())
MemberProfile._account_id_validator = bv.Nullable(users.AccountId_validator)
MemberProfile._email_validator = bv.String()
MemberProfile._email_verified_validator = bv.Boolean()
MemberProfile._status_validator = TeamMemberStatus_validator
MemberProfile._name_validator = users.Name_validator
MemberProfile._membership_type_validator = TeamMembershipType_validator
MemberProfile._joined_on_validator = bv.Nullable(common.DropboxTimestamp_validator)
MemberProfile._persistent_id_validator = bv.Nullable(bv.String())
MemberProfile._all_field_names_ = set([
    'team_member_id',
    'external_id',
    'account_id',
    'email',
    'email_verified',
    'status',
    'name',
    'membership_type',
    'joined_on',
    'persistent_id',
])
MemberProfile._all_fields_ = [
    ('team_member_id', MemberProfile._team_member_id_validator),
    ('external_id', MemberProfile._external_id_validator),
    ('account_id', MemberProfile._account_id_validator),
    ('email', MemberProfile._email_validator),
    ('email_verified', MemberProfile._email_verified_validator),
    ('status', MemberProfile._status_validator),
    ('name', MemberProfile._name_validator),
    ('membership_type', MemberProfile._membership_type_validator),
    ('joined_on', MemberProfile._joined_on_validator),
    ('persistent_id', MemberProfile._persistent_id_validator),
]

UserSelectorError._user_not_found_validator = bv.Void()
UserSelectorError._tagmap = {
    'user_not_found': UserSelectorError._user_not_found_validator,
}

UserSelectorError.user_not_found = UserSelectorError('user_not_found')

MemberSelectorError._user_not_in_team_validator = bv.Void()
MemberSelectorError._tagmap = {
    'user_not_in_team': MemberSelectorError._user_not_in_team_validator,
}
MemberSelectorError._tagmap.update(UserSelectorError._tagmap)

MemberSelectorError.user_not_in_team = MemberSelectorError('user_not_in_team')

MembersAddArg._new_members_validator = bv.List(MemberAddArg_validator)
MembersAddArg._force_async_validator = bv.Boolean()
MembersAddArg._all_field_names_ = set([
    'new_members',
    'force_async',
])
MembersAddArg._all_fields_ = [
    ('new_members', MembersAddArg._new_members_validator),
    ('force_async', MembersAddArg._force_async_validator),
]

MembersAddJobStatus._complete_validator = bv.List(MemberAddResult_validator)
MembersAddJobStatus._failed_validator = bv.String()
MembersAddJobStatus._tagmap = {
    'complete': MembersAddJobStatus._complete_validator,
    'failed': MembersAddJobStatus._failed_validator,
}
MembersAddJobStatus._tagmap.update(async.PollResultBase._tagmap)

MembersAddLaunch._complete_validator = bv.List(MemberAddResult_validator)
MembersAddLaunch._tagmap = {
    'complete': MembersAddLaunch._complete_validator,
}
MembersAddLaunch._tagmap.update(async.LaunchResultBase._tagmap)

MembersDeactivateArg._user_validator = UserSelectorArg_validator
MembersDeactivateArg._wipe_data_validator = bv.Boolean()
MembersDeactivateArg._all_field_names_ = set([
    'user',
    'wipe_data',
])
MembersDeactivateArg._all_fields_ = [
    ('user', MembersDeactivateArg._user_validator),
    ('wipe_data', MembersDeactivateArg._wipe_data_validator),
]

MembersDeactivateError._user_not_in_team_validator = bv.Void()
MembersDeactivateError._other_validator = bv.Void()
MembersDeactivateError._tagmap = {
    'user_not_in_team': MembersDeactivateError._user_not_in_team_validator,
    'other': MembersDeactivateError._other_validator,
}
MembersDeactivateError._tagmap.update(UserSelectorError._tagmap)

MembersDeactivateError.user_not_in_team = MembersDeactivateError('user_not_in_team')
MembersDeactivateError.other = MembersDeactivateError('other')

MembersGetInfoArgs._members_validator = bv.List(UserSelectorArg_validator)
MembersGetInfoArgs._all_field_names_ = set(['members'])
MembersGetInfoArgs._all_fields_ = [('members', MembersGetInfoArgs._members_validator)]

MembersGetInfoError._other_validator = bv.Void()
MembersGetInfoError._tagmap = {
    'other': MembersGetInfoError._other_validator,
}

MembersGetInfoError.other = MembersGetInfoError('other')

MembersGetInfoItem._id_not_found_validator = bv.String()
MembersGetInfoItem._member_info_validator = TeamMemberInfo_validator
MembersGetInfoItem._tagmap = {
    'id_not_found': MembersGetInfoItem._id_not_found_validator,
    'member_info': MembersGetInfoItem._member_info_validator,
}

MembersListArg._limit_validator = bv.UInt32(min_value=1, max_value=1000)
MembersListArg._include_removed_validator = bv.Boolean()
MembersListArg._all_field_names_ = set([
    'limit',
    'include_removed',
])
MembersListArg._all_fields_ = [
    ('limit', MembersListArg._limit_validator),
    ('include_removed', MembersListArg._include_removed_validator),
]

MembersListContinueArg._cursor_validator = bv.String()
MembersListContinueArg._all_field_names_ = set(['cursor'])
MembersListContinueArg._all_fields_ = [('cursor', MembersListContinueArg._cursor_validator)]

MembersListContinueError._invalid_cursor_validator = bv.Void()
MembersListContinueError._other_validator = bv.Void()
MembersListContinueError._tagmap = {
    'invalid_cursor': MembersListContinueError._invalid_cursor_validator,
    'other': MembersListContinueError._other_validator,
}

MembersListContinueError.invalid_cursor = MembersListContinueError('invalid_cursor')
MembersListContinueError.other = MembersListContinueError('other')

MembersListError._other_validator = bv.Void()
MembersListError._tagmap = {
    'other': MembersListError._other_validator,
}

MembersListError.other = MembersListError('other')

MembersListResult._members_validator = bv.List(TeamMemberInfo_validator)
MembersListResult._cursor_validator = bv.String()
MembersListResult._has_more_validator = bv.Boolean()
MembersListResult._all_field_names_ = set([
    'members',
    'cursor',
    'has_more',
])
MembersListResult._all_fields_ = [
    ('members', MembersListResult._members_validator),
    ('cursor', MembersListResult._cursor_validator),
    ('has_more', MembersListResult._has_more_validator),
]

MembersRecoverArg._user_validator = UserSelectorArg_validator
MembersRecoverArg._all_field_names_ = set(['user'])
MembersRecoverArg._all_fields_ = [('user', MembersRecoverArg._user_validator)]

MembersRecoverError._user_unrecoverable_validator = bv.Void()
MembersRecoverError._user_not_in_team_validator = bv.Void()
MembersRecoverError._team_license_limit_validator = bv.Void()
MembersRecoverError._other_validator = bv.Void()
MembersRecoverError._tagmap = {
    'user_unrecoverable': MembersRecoverError._user_unrecoverable_validator,
    'user_not_in_team': MembersRecoverError._user_not_in_team_validator,
    'team_license_limit': MembersRecoverError._team_license_limit_validator,
    'other': MembersRecoverError._other_validator,
}
MembersRecoverError._tagmap.update(UserSelectorError._tagmap)

MembersRecoverError.user_unrecoverable = MembersRecoverError('user_unrecoverable')
MembersRecoverError.user_not_in_team = MembersRecoverError('user_not_in_team')
MembersRecoverError.team_license_limit = MembersRecoverError('team_license_limit')
MembersRecoverError.other = MembersRecoverError('other')

MembersRemoveArg._transfer_dest_id_validator = bv.Nullable(UserSelectorArg_validator)
MembersRemoveArg._transfer_admin_id_validator = bv.Nullable(UserSelectorArg_validator)
MembersRemoveArg._keep_account_validator = bv.Boolean()
MembersRemoveArg._all_field_names_ = MembersDeactivateArg._all_field_names_.union(set([
    'transfer_dest_id',
    'transfer_admin_id',
    'keep_account',
]))
MembersRemoveArg._all_fields_ = MembersDeactivateArg._all_fields_ + [
    ('transfer_dest_id', MembersRemoveArg._transfer_dest_id_validator),
    ('transfer_admin_id', MembersRemoveArg._transfer_admin_id_validator),
    ('keep_account', MembersRemoveArg._keep_account_validator),
]

MembersRemoveError._remove_last_admin_validator = bv.Void()
MembersRemoveError._removed_and_transfer_dest_should_differ_validator = bv.Void()
MembersRemoveError._removed_and_transfer_admin_should_differ_validator = bv.Void()
MembersRemoveError._transfer_dest_user_not_found_validator = bv.Void()
MembersRemoveError._transfer_dest_user_not_in_team_validator = bv.Void()
MembersRemoveError._transfer_admin_user_not_found_validator = bv.Void()
MembersRemoveError._transfer_admin_user_not_in_team_validator = bv.Void()
MembersRemoveError._unspecified_transfer_admin_id_validator = bv.Void()
MembersRemoveError._transfer_admin_is_not_admin_validator = bv.Void()
MembersRemoveError._cannot_keep_account_and_transfer_validator = bv.Void()
MembersRemoveError._cannot_keep_account_and_delete_data_validator = bv.Void()
MembersRemoveError._email_address_too_long_to_be_disabled_validator = bv.Void()
MembersRemoveError._tagmap = {
    'remove_last_admin': MembersRemoveError._remove_last_admin_validator,
    'removed_and_transfer_dest_should_differ': MembersRemoveError._removed_and_transfer_dest_should_differ_validator,
    'removed_and_transfer_admin_should_differ': MembersRemoveError._removed_and_transfer_admin_should_differ_validator,
    'transfer_dest_user_not_found': MembersRemoveError._transfer_dest_user_not_found_validator,
    'transfer_dest_user_not_in_team': MembersRemoveError._transfer_dest_user_not_in_team_validator,
    'transfer_admin_user_not_found': MembersRemoveError._transfer_admin_user_not_found_validator,
    'transfer_admin_user_not_in_team': MembersRemoveError._transfer_admin_user_not_in_team_validator,
    'unspecified_transfer_admin_id': MembersRemoveError._unspecified_transfer_admin_id_validator,
    'transfer_admin_is_not_admin': MembersRemoveError._transfer_admin_is_not_admin_validator,
    'cannot_keep_account_and_transfer': MembersRemoveError._cannot_keep_account_and_transfer_validator,
    'cannot_keep_account_and_delete_data': MembersRemoveError._cannot_keep_account_and_delete_data_validator,
    'email_address_too_long_to_be_disabled': MembersRemoveError._email_address_too_long_to_be_disabled_validator,
}
MembersRemoveError._tagmap.update(MembersDeactivateError._tagmap)

MembersRemoveError.remove_last_admin = MembersRemoveError('remove_last_admin')
MembersRemoveError.removed_and_transfer_dest_should_differ = MembersRemoveError('removed_and_transfer_dest_should_differ')
MembersRemoveError.removed_and_transfer_admin_should_differ = MembersRemoveError('removed_and_transfer_admin_should_differ')
MembersRemoveError.transfer_dest_user_not_found = MembersRemoveError('transfer_dest_user_not_found')
MembersRemoveError.transfer_dest_user_not_in_team = MembersRemoveError('transfer_dest_user_not_in_team')
MembersRemoveError.transfer_admin_user_not_found = MembersRemoveError('transfer_admin_user_not_found')
MembersRemoveError.transfer_admin_user_not_in_team = MembersRemoveError('transfer_admin_user_not_in_team')
MembersRemoveError.unspecified_transfer_admin_id = MembersRemoveError('unspecified_transfer_admin_id')
MembersRemoveError.transfer_admin_is_not_admin = MembersRemoveError('transfer_admin_is_not_admin')
MembersRemoveError.cannot_keep_account_and_transfer = MembersRemoveError('cannot_keep_account_and_transfer')
MembersRemoveError.cannot_keep_account_and_delete_data = MembersRemoveError('cannot_keep_account_and_delete_data')
MembersRemoveError.email_address_too_long_to_be_disabled = MembersRemoveError('email_address_too_long_to_be_disabled')

MembersSendWelcomeError._other_validator = bv.Void()
MembersSendWelcomeError._tagmap = {
    'other': MembersSendWelcomeError._other_validator,
}
MembersSendWelcomeError._tagmap.update(MemberSelectorError._tagmap)

MembersSendWelcomeError.other = MembersSendWelcomeError('other')

MembersSetPermissionsArg._user_validator = UserSelectorArg_validator
MembersSetPermissionsArg._new_role_validator = AdminTier_validator
MembersSetPermissionsArg._all_field_names_ = set([
    'user',
    'new_role',
])
MembersSetPermissionsArg._all_fields_ = [
    ('user', MembersSetPermissionsArg._user_validator),
    ('new_role', MembersSetPermissionsArg._new_role_validator),
]

MembersSetPermissionsError._last_admin_validator = bv.Void()
MembersSetPermissionsError._user_not_in_team_validator = bv.Void()
MembersSetPermissionsError._cannot_set_permissions_validator = bv.Void()
MembersSetPermissionsError._team_license_limit_validator = bv.Void()
MembersSetPermissionsError._other_validator = bv.Void()
MembersSetPermissionsError._tagmap = {
    'last_admin': MembersSetPermissionsError._last_admin_validator,
    'user_not_in_team': MembersSetPermissionsError._user_not_in_team_validator,
    'cannot_set_permissions': MembersSetPermissionsError._cannot_set_permissions_validator,
    'team_license_limit': MembersSetPermissionsError._team_license_limit_validator,
    'other': MembersSetPermissionsError._other_validator,
}
MembersSetPermissionsError._tagmap.update(UserSelectorError._tagmap)

MembersSetPermissionsError.last_admin = MembersSetPermissionsError('last_admin')
MembersSetPermissionsError.user_not_in_team = MembersSetPermissionsError('user_not_in_team')
MembersSetPermissionsError.cannot_set_permissions = MembersSetPermissionsError('cannot_set_permissions')
MembersSetPermissionsError.team_license_limit = MembersSetPermissionsError('team_license_limit')
MembersSetPermissionsError.other = MembersSetPermissionsError('other')

MembersSetPermissionsResult._team_member_id_validator = team_common.TeamMemberId_validator
MembersSetPermissionsResult._role_validator = AdminTier_validator
MembersSetPermissionsResult._all_field_names_ = set([
    'team_member_id',
    'role',
])
MembersSetPermissionsResult._all_fields_ = [
    ('team_member_id', MembersSetPermissionsResult._team_member_id_validator),
    ('role', MembersSetPermissionsResult._role_validator),
]

MembersSetProfileArg._user_validator = UserSelectorArg_validator
MembersSetProfileArg._new_email_validator = bv.Nullable(common.EmailAddress_validator)
MembersSetProfileArg._new_external_id_validator = bv.Nullable(team_common.MemberExternalId_validator)
MembersSetProfileArg._new_given_name_validator = bv.Nullable(common.NamePart_validator)
MembersSetProfileArg._new_surname_validator = bv.Nullable(common.NamePart_validator)
MembersSetProfileArg._new_persistent_id_validator = bv.Nullable(bv.String())
MembersSetProfileArg._all_field_names_ = set([
    'user',
    'new_email',
    'new_external_id',
    'new_given_name',
    'new_surname',
    'new_persistent_id',
])
MembersSetProfileArg._all_fields_ = [
    ('user', MembersSetProfileArg._user_validator),
    ('new_email', MembersSetProfileArg._new_email_validator),
    ('new_external_id', MembersSetProfileArg._new_external_id_validator),
    ('new_given_name', MembersSetProfileArg._new_given_name_validator),
    ('new_surname', MembersSetProfileArg._new_surname_validator),
    ('new_persistent_id', MembersSetProfileArg._new_persistent_id_validator),
]

MembersSetProfileError._external_id_and_new_external_id_unsafe_validator = bv.Void()
MembersSetProfileError._no_new_data_specified_validator = bv.Void()
MembersSetProfileError._email_reserved_for_other_user_validator = bv.Void()
MembersSetProfileError._external_id_used_by_other_user_validator = bv.Void()
MembersSetProfileError._set_profile_disallowed_validator = bv.Void()
MembersSetProfileError._param_cannot_be_empty_validator = bv.Void()
MembersSetProfileError._persistent_id_disabled_validator = bv.Void()
MembersSetProfileError._persistent_id_used_by_other_user_validator = bv.Void()
MembersSetProfileError._other_validator = bv.Void()
MembersSetProfileError._tagmap = {
    'external_id_and_new_external_id_unsafe': MembersSetProfileError._external_id_and_new_external_id_unsafe_validator,
    'no_new_data_specified': MembersSetProfileError._no_new_data_specified_validator,
    'email_reserved_for_other_user': MembersSetProfileError._email_reserved_for_other_user_validator,
    'external_id_used_by_other_user': MembersSetProfileError._external_id_used_by_other_user_validator,
    'set_profile_disallowed': MembersSetProfileError._set_profile_disallowed_validator,
    'param_cannot_be_empty': MembersSetProfileError._param_cannot_be_empty_validator,
    'persistent_id_disabled': MembersSetProfileError._persistent_id_disabled_validator,
    'persistent_id_used_by_other_user': MembersSetProfileError._persistent_id_used_by_other_user_validator,
    'other': MembersSetProfileError._other_validator,
}
MembersSetProfileError._tagmap.update(MemberSelectorError._tagmap)

MembersSetProfileError.external_id_and_new_external_id_unsafe = MembersSetProfileError('external_id_and_new_external_id_unsafe')
MembersSetProfileError.no_new_data_specified = MembersSetProfileError('no_new_data_specified')
MembersSetProfileError.email_reserved_for_other_user = MembersSetProfileError('email_reserved_for_other_user')
MembersSetProfileError.external_id_used_by_other_user = MembersSetProfileError('external_id_used_by_other_user')
MembersSetProfileError.set_profile_disallowed = MembersSetProfileError('set_profile_disallowed')
MembersSetProfileError.param_cannot_be_empty = MembersSetProfileError('param_cannot_be_empty')
MembersSetProfileError.persistent_id_disabled = MembersSetProfileError('persistent_id_disabled')
MembersSetProfileError.persistent_id_used_by_other_user = MembersSetProfileError('persistent_id_used_by_other_user')
MembersSetProfileError.other = MembersSetProfileError('other')

MembersSuspendError._suspend_inactive_user_validator = bv.Void()
MembersSuspendError._suspend_last_admin_validator = bv.Void()
MembersSuspendError._team_license_limit_validator = bv.Void()
MembersSuspendError._tagmap = {
    'suspend_inactive_user': MembersSuspendError._suspend_inactive_user_validator,
    'suspend_last_admin': MembersSuspendError._suspend_last_admin_validator,
    'team_license_limit': MembersSuspendError._team_license_limit_validator,
}
MembersSuspendError._tagmap.update(MembersDeactivateError._tagmap)

MembersSuspendError.suspend_inactive_user = MembersSuspendError('suspend_inactive_user')
MembersSuspendError.suspend_last_admin = MembersSuspendError('suspend_last_admin')
MembersSuspendError.team_license_limit = MembersSuspendError('team_license_limit')

MembersUnsuspendArg._user_validator = UserSelectorArg_validator
MembersUnsuspendArg._all_field_names_ = set(['user'])
MembersUnsuspendArg._all_fields_ = [('user', MembersUnsuspendArg._user_validator)]

MembersUnsuspendError._unsuspend_non_suspended_member_validator = bv.Void()
MembersUnsuspendError._team_license_limit_validator = bv.Void()
MembersUnsuspendError._tagmap = {
    'unsuspend_non_suspended_member': MembersUnsuspendError._unsuspend_non_suspended_member_validator,
    'team_license_limit': MembersUnsuspendError._team_license_limit_validator,
}
MembersUnsuspendError._tagmap.update(MembersDeactivateError._tagmap)

MembersUnsuspendError.unsuspend_non_suspended_member = MembersUnsuspendError('unsuspend_non_suspended_member')
MembersUnsuspendError.team_license_limit = MembersUnsuspendError('team_license_limit')

MobileClientPlatform._iphone_validator = bv.Void()
MobileClientPlatform._ipad_validator = bv.Void()
MobileClientPlatform._android_validator = bv.Void()
MobileClientPlatform._windows_phone_validator = bv.Void()
MobileClientPlatform._blackberry_validator = bv.Void()
MobileClientPlatform._other_validator = bv.Void()
MobileClientPlatform._tagmap = {
    'iphone': MobileClientPlatform._iphone_validator,
    'ipad': MobileClientPlatform._ipad_validator,
    'android': MobileClientPlatform._android_validator,
    'windows_phone': MobileClientPlatform._windows_phone_validator,
    'blackberry': MobileClientPlatform._blackberry_validator,
    'other': MobileClientPlatform._other_validator,
}

MobileClientPlatform.iphone = MobileClientPlatform('iphone')
MobileClientPlatform.ipad = MobileClientPlatform('ipad')
MobileClientPlatform.android = MobileClientPlatform('android')
MobileClientPlatform.windows_phone = MobileClientPlatform('windows_phone')
MobileClientPlatform.blackberry = MobileClientPlatform('blackberry')
MobileClientPlatform.other = MobileClientPlatform('other')

MobileClientSession._device_name_validator = bv.String()
MobileClientSession._client_type_validator = MobileClientPlatform_validator
MobileClientSession._client_version_validator = bv.Nullable(bv.String())
MobileClientSession._os_version_validator = bv.Nullable(bv.String())
MobileClientSession._last_carrier_validator = bv.Nullable(bv.String())
MobileClientSession._all_field_names_ = DeviceSession._all_field_names_.union(set([
    'device_name',
    'client_type',
    'client_version',
    'os_version',
    'last_carrier',
]))
MobileClientSession._all_fields_ = DeviceSession._all_fields_ + [
    ('device_name', MobileClientSession._device_name_validator),
    ('client_type', MobileClientSession._client_type_validator),
    ('client_version', MobileClientSession._client_version_validator),
    ('os_version', MobileClientSession._os_version_validator),
    ('last_carrier', MobileClientSession._last_carrier_validator),
]

RemovedStatus._is_recoverable_validator = bv.Boolean()
RemovedStatus._all_field_names_ = set(['is_recoverable'])
RemovedStatus._all_fields_ = [('is_recoverable', RemovedStatus._is_recoverable_validator)]

RevokeDesktopClientArg._delete_on_unlink_validator = bv.Boolean()
RevokeDesktopClientArg._all_field_names_ = DeviceSessionArg._all_field_names_.union(set(['delete_on_unlink']))
RevokeDesktopClientArg._all_fields_ = DeviceSessionArg._all_fields_ + [('delete_on_unlink', RevokeDesktopClientArg._delete_on_unlink_validator)]

RevokeDeviceSessionArg._web_session_validator = DeviceSessionArg_validator
RevokeDeviceSessionArg._desktop_client_validator = RevokeDesktopClientArg_validator
RevokeDeviceSessionArg._mobile_client_validator = DeviceSessionArg_validator
RevokeDeviceSessionArg._tagmap = {
    'web_session': RevokeDeviceSessionArg._web_session_validator,
    'desktop_client': RevokeDeviceSessionArg._desktop_client_validator,
    'mobile_client': RevokeDeviceSessionArg._mobile_client_validator,
}

RevokeDeviceSessionBatchArg._revoke_devices_validator = bv.List(RevokeDeviceSessionArg_validator)
RevokeDeviceSessionBatchArg._all_field_names_ = set(['revoke_devices'])
RevokeDeviceSessionBatchArg._all_fields_ = [('revoke_devices', RevokeDeviceSessionBatchArg._revoke_devices_validator)]

RevokeDeviceSessionBatchError._other_validator = bv.Void()
RevokeDeviceSessionBatchError._tagmap = {
    'other': RevokeDeviceSessionBatchError._other_validator,
}

RevokeDeviceSessionBatchError.other = RevokeDeviceSessionBatchError('other')

RevokeDeviceSessionBatchResult._revoke_devices_status_validator = bv.List(RevokeDeviceSessionStatus_validator)
RevokeDeviceSessionBatchResult._all_field_names_ = set(['revoke_devices_status'])
RevokeDeviceSessionBatchResult._all_fields_ = [('revoke_devices_status', RevokeDeviceSessionBatchResult._revoke_devices_status_validator)]

RevokeDeviceSessionError._device_session_not_found_validator = bv.Void()
RevokeDeviceSessionError._member_not_found_validator = bv.Void()
RevokeDeviceSessionError._other_validator = bv.Void()
RevokeDeviceSessionError._tagmap = {
    'device_session_not_found': RevokeDeviceSessionError._device_session_not_found_validator,
    'member_not_found': RevokeDeviceSessionError._member_not_found_validator,
    'other': RevokeDeviceSessionError._other_validator,
}

RevokeDeviceSessionError.device_session_not_found = RevokeDeviceSessionError('device_session_not_found')
RevokeDeviceSessionError.member_not_found = RevokeDeviceSessionError('member_not_found')
RevokeDeviceSessionError.other = RevokeDeviceSessionError('other')

RevokeDeviceSessionStatus._success_validator = bv.Boolean()
RevokeDeviceSessionStatus._error_type_validator = bv.Nullable(RevokeDeviceSessionError_validator)
RevokeDeviceSessionStatus._all_field_names_ = set([
    'success',
    'error_type',
])
RevokeDeviceSessionStatus._all_fields_ = [
    ('success', RevokeDeviceSessionStatus._success_validator),
    ('error_type', RevokeDeviceSessionStatus._error_type_validator),
]

RevokeLinkedApiAppArg._app_id_validator = bv.String()
RevokeLinkedApiAppArg._team_member_id_validator = bv.String()
RevokeLinkedApiAppArg._keep_app_folder_validator = bv.Boolean()
RevokeLinkedApiAppArg._all_field_names_ = set([
    'app_id',
    'team_member_id',
    'keep_app_folder',
])
RevokeLinkedApiAppArg._all_fields_ = [
    ('app_id', RevokeLinkedApiAppArg._app_id_validator),
    ('team_member_id', RevokeLinkedApiAppArg._team_member_id_validator),
    ('keep_app_folder', RevokeLinkedApiAppArg._keep_app_folder_validator),
]

RevokeLinkedApiAppBatchArg._revoke_linked_app_validator = bv.List(RevokeLinkedApiAppArg_validator)
RevokeLinkedApiAppBatchArg._all_field_names_ = set(['revoke_linked_app'])
RevokeLinkedApiAppBatchArg._all_fields_ = [('revoke_linked_app', RevokeLinkedApiAppBatchArg._revoke_linked_app_validator)]

RevokeLinkedAppBatchError._other_validator = bv.Void()
RevokeLinkedAppBatchError._tagmap = {
    'other': RevokeLinkedAppBatchError._other_validator,
}

RevokeLinkedAppBatchError.other = RevokeLinkedAppBatchError('other')

RevokeLinkedAppBatchResult._revoke_linked_app_status_validator = bv.List(RevokeLinkedAppStatus_validator)
RevokeLinkedAppBatchResult._all_field_names_ = set(['revoke_linked_app_status'])
RevokeLinkedAppBatchResult._all_fields_ = [('revoke_linked_app_status', RevokeLinkedAppBatchResult._revoke_linked_app_status_validator)]

RevokeLinkedAppError._app_not_found_validator = bv.Void()
RevokeLinkedAppError._member_not_found_validator = bv.Void()
RevokeLinkedAppError._other_validator = bv.Void()
RevokeLinkedAppError._tagmap = {
    'app_not_found': RevokeLinkedAppError._app_not_found_validator,
    'member_not_found': RevokeLinkedAppError._member_not_found_validator,
    'other': RevokeLinkedAppError._other_validator,
}

RevokeLinkedAppError.app_not_found = RevokeLinkedAppError('app_not_found')
RevokeLinkedAppError.member_not_found = RevokeLinkedAppError('member_not_found')
RevokeLinkedAppError.other = RevokeLinkedAppError('other')

RevokeLinkedAppStatus._success_validator = bv.Boolean()
RevokeLinkedAppStatus._error_type_validator = bv.Nullable(RevokeLinkedAppError_validator)
RevokeLinkedAppStatus._all_field_names_ = set([
    'success',
    'error_type',
])
RevokeLinkedAppStatus._all_fields_ = [
    ('success', RevokeLinkedAppStatus._success_validator),
    ('error_type', RevokeLinkedAppStatus._error_type_validator),
]

StorageBucket._bucket_validator = bv.String()
StorageBucket._users_validator = bv.UInt64()
StorageBucket._all_field_names_ = set([
    'bucket',
    'users',
])
StorageBucket._all_fields_ = [
    ('bucket', StorageBucket._bucket_validator),
    ('users', StorageBucket._users_validator),
]

TeamFolderAccessError._invalid_team_folder_id_validator = bv.Void()
TeamFolderAccessError._no_access_validator = bv.Void()
TeamFolderAccessError._other_validator = bv.Void()
TeamFolderAccessError._tagmap = {
    'invalid_team_folder_id': TeamFolderAccessError._invalid_team_folder_id_validator,
    'no_access': TeamFolderAccessError._no_access_validator,
    'other': TeamFolderAccessError._other_validator,
}

TeamFolderAccessError.invalid_team_folder_id = TeamFolderAccessError('invalid_team_folder_id')
TeamFolderAccessError.no_access = TeamFolderAccessError('no_access')
TeamFolderAccessError.other = TeamFolderAccessError('other')

TeamFolderActivateError._tagmap = {
}
TeamFolderActivateError._tagmap.update(BaseTeamFolderError._tagmap)

TeamFolderIdArg._team_folder_id_validator = common.SharedFolderId_validator
TeamFolderIdArg._all_field_names_ = set(['team_folder_id'])
TeamFolderIdArg._all_fields_ = [('team_folder_id', TeamFolderIdArg._team_folder_id_validator)]

TeamFolderArchiveArg._force_async_off_validator = bv.Boolean()
TeamFolderArchiveArg._all_field_names_ = TeamFolderIdArg._all_field_names_.union(set(['force_async_off']))
TeamFolderArchiveArg._all_fields_ = TeamFolderIdArg._all_fields_ + [('force_async_off', TeamFolderArchiveArg._force_async_off_validator)]

TeamFolderArchiveError._tagmap = {
}
TeamFolderArchiveError._tagmap.update(BaseTeamFolderError._tagmap)

TeamFolderArchiveJobStatus._complete_validator = TeamFolderMetadata_validator
TeamFolderArchiveJobStatus._failed_validator = TeamFolderArchiveError_validator
TeamFolderArchiveJobStatus._tagmap = {
    'complete': TeamFolderArchiveJobStatus._complete_validator,
    'failed': TeamFolderArchiveJobStatus._failed_validator,
}
TeamFolderArchiveJobStatus._tagmap.update(async.PollResultBase._tagmap)

TeamFolderArchiveLaunch._complete_validator = TeamFolderMetadata_validator
TeamFolderArchiveLaunch._tagmap = {
    'complete': TeamFolderArchiveLaunch._complete_validator,
}
TeamFolderArchiveLaunch._tagmap.update(async.LaunchResultBase._tagmap)

TeamFolderCreateArg._name_validator = bv.String()
TeamFolderCreateArg._all_field_names_ = set(['name'])
TeamFolderCreateArg._all_fields_ = [('name', TeamFolderCreateArg._name_validator)]

TeamFolderCreateError._invalid_folder_name_validator = bv.Void()
TeamFolderCreateError._folder_name_already_used_validator = bv.Void()
TeamFolderCreateError._folder_name_reserved_validator = bv.Void()
TeamFolderCreateError._other_validator = bv.Void()
TeamFolderCreateError._tagmap = {
    'invalid_folder_name': TeamFolderCreateError._invalid_folder_name_validator,
    'folder_name_already_used': TeamFolderCreateError._folder_name_already_used_validator,
    'folder_name_reserved': TeamFolderCreateError._folder_name_reserved_validator,
    'other': TeamFolderCreateError._other_validator,
}

TeamFolderCreateError.invalid_folder_name = TeamFolderCreateError('invalid_folder_name')
TeamFolderCreateError.folder_name_already_used = TeamFolderCreateError('folder_name_already_used')
TeamFolderCreateError.folder_name_reserved = TeamFolderCreateError('folder_name_reserved')
TeamFolderCreateError.other = TeamFolderCreateError('other')

TeamFolderGetInfoItem._id_not_found_validator = bv.String()
TeamFolderGetInfoItem._team_folder_metadata_validator = TeamFolderMetadata_validator
TeamFolderGetInfoItem._tagmap = {
    'id_not_found': TeamFolderGetInfoItem._id_not_found_validator,
    'team_folder_metadata': TeamFolderGetInfoItem._team_folder_metadata_validator,
}

TeamFolderIdListArg._team_folder_ids_validator = bv.List(common.SharedFolderId_validator, min_items=1)
TeamFolderIdListArg._all_field_names_ = set(['team_folder_ids'])
TeamFolderIdListArg._all_fields_ = [('team_folder_ids', TeamFolderIdListArg._team_folder_ids_validator)]

TeamFolderInvalidStatusError._active_validator = bv.Void()
TeamFolderInvalidStatusError._archived_validator = bv.Void()
TeamFolderInvalidStatusError._archive_in_progress_validator = bv.Void()
TeamFolderInvalidStatusError._other_validator = bv.Void()
TeamFolderInvalidStatusError._tagmap = {
    'active': TeamFolderInvalidStatusError._active_validator,
    'archived': TeamFolderInvalidStatusError._archived_validator,
    'archive_in_progress': TeamFolderInvalidStatusError._archive_in_progress_validator,
    'other': TeamFolderInvalidStatusError._other_validator,
}

TeamFolderInvalidStatusError.active = TeamFolderInvalidStatusError('active')
TeamFolderInvalidStatusError.archived = TeamFolderInvalidStatusError('archived')
TeamFolderInvalidStatusError.archive_in_progress = TeamFolderInvalidStatusError('archive_in_progress')
TeamFolderInvalidStatusError.other = TeamFolderInvalidStatusError('other')

TeamFolderListArg._limit_validator = bv.UInt32(min_value=1, max_value=1000)
TeamFolderListArg._all_field_names_ = set(['limit'])
TeamFolderListArg._all_fields_ = [('limit', TeamFolderListArg._limit_validator)]

TeamFolderListError._access_error_validator = TeamFolderAccessError_validator
TeamFolderListError._all_field_names_ = set(['access_error'])
TeamFolderListError._all_fields_ = [('access_error', TeamFolderListError._access_error_validator)]

TeamFolderListResult._team_folders_validator = bv.List(TeamFolderMetadata_validator)
TeamFolderListResult._all_field_names_ = set(['team_folders'])
TeamFolderListResult._all_fields_ = [('team_folders', TeamFolderListResult._team_folders_validator)]

TeamFolderMetadata._team_folder_id_validator = common.SharedFolderId_validator
TeamFolderMetadata._name_validator = bv.String()
TeamFolderMetadata._status_validator = TeamFolderStatus_validator
TeamFolderMetadata._all_field_names_ = set([
    'team_folder_id',
    'name',
    'status',
])
TeamFolderMetadata._all_fields_ = [
    ('team_folder_id', TeamFolderMetadata._team_folder_id_validator),
    ('name', TeamFolderMetadata._name_validator),
    ('status', TeamFolderMetadata._status_validator),
]

TeamFolderPermanentlyDeleteError._tagmap = {
}
TeamFolderPermanentlyDeleteError._tagmap.update(BaseTeamFolderError._tagmap)

TeamFolderRenameArg._name_validator = bv.String()
TeamFolderRenameArg._all_field_names_ = TeamFolderIdArg._all_field_names_.union(set(['name']))
TeamFolderRenameArg._all_fields_ = TeamFolderIdArg._all_fields_ + [('name', TeamFolderRenameArg._name_validator)]

TeamFolderRenameError._invalid_folder_name_validator = bv.Void()
TeamFolderRenameError._folder_name_already_used_validator = bv.Void()
TeamFolderRenameError._folder_name_reserved_validator = bv.Void()
TeamFolderRenameError._tagmap = {
    'invalid_folder_name': TeamFolderRenameError._invalid_folder_name_validator,
    'folder_name_already_used': TeamFolderRenameError._folder_name_already_used_validator,
    'folder_name_reserved': TeamFolderRenameError._folder_name_reserved_validator,
}
TeamFolderRenameError._tagmap.update(BaseTeamFolderError._tagmap)

TeamFolderRenameError.invalid_folder_name = TeamFolderRenameError('invalid_folder_name')
TeamFolderRenameError.folder_name_already_used = TeamFolderRenameError('folder_name_already_used')
TeamFolderRenameError.folder_name_reserved = TeamFolderRenameError('folder_name_reserved')

TeamFolderStatus._active_validator = bv.Void()
TeamFolderStatus._archived_validator = bv.Void()
TeamFolderStatus._archive_in_progress_validator = bv.Void()
TeamFolderStatus._other_validator = bv.Void()
TeamFolderStatus._tagmap = {
    'active': TeamFolderStatus._active_validator,
    'archived': TeamFolderStatus._archived_validator,
    'archive_in_progress': TeamFolderStatus._archive_in_progress_validator,
    'other': TeamFolderStatus._other_validator,
}

TeamFolderStatus.active = TeamFolderStatus('active')
TeamFolderStatus.archived = TeamFolderStatus('archived')
TeamFolderStatus.archive_in_progress = TeamFolderStatus('archive_in_progress')
TeamFolderStatus.other = TeamFolderStatus('other')

TeamGetInfoResult._name_validator = bv.String()
TeamGetInfoResult._team_id_validator = bv.String()
TeamGetInfoResult._num_licensed_users_validator = bv.UInt32()
TeamGetInfoResult._num_provisioned_users_validator = bv.UInt32()
TeamGetInfoResult._policies_validator = team_policies.TeamMemberPolicies_validator
TeamGetInfoResult._all_field_names_ = set([
    'name',
    'team_id',
    'num_licensed_users',
    'num_provisioned_users',
    'policies',
])
TeamGetInfoResult._all_fields_ = [
    ('name', TeamGetInfoResult._name_validator),
    ('team_id', TeamGetInfoResult._team_id_validator),
    ('num_licensed_users', TeamGetInfoResult._num_licensed_users_validator),
    ('num_provisioned_users', TeamGetInfoResult._num_provisioned_users_validator),
    ('policies', TeamGetInfoResult._policies_validator),
]

TeamMemberInfo._profile_validator = TeamMemberProfile_validator
TeamMemberInfo._role_validator = AdminTier_validator
TeamMemberInfo._all_field_names_ = set([
    'profile',
    'role',
])
TeamMemberInfo._all_fields_ = [
    ('profile', TeamMemberInfo._profile_validator),
    ('role', TeamMemberInfo._role_validator),
]

TeamMemberProfile._groups_validator = bv.List(team_common.GroupId_validator)
TeamMemberProfile._all_field_names_ = MemberProfile._all_field_names_.union(set(['groups']))
TeamMemberProfile._all_fields_ = MemberProfile._all_fields_ + [('groups', TeamMemberProfile._groups_validator)]

TeamMemberStatus._active_validator = bv.Void()
TeamMemberStatus._invited_validator = bv.Void()
TeamMemberStatus._suspended_validator = bv.Void()
TeamMemberStatus._removed_validator = RemovedStatus_validator
TeamMemberStatus._tagmap = {
    'active': TeamMemberStatus._active_validator,
    'invited': TeamMemberStatus._invited_validator,
    'suspended': TeamMemberStatus._suspended_validator,
    'removed': TeamMemberStatus._removed_validator,
}

TeamMemberStatus.active = TeamMemberStatus('active')
TeamMemberStatus.invited = TeamMemberStatus('invited')
TeamMemberStatus.suspended = TeamMemberStatus('suspended')

TeamMembershipType._full_validator = bv.Void()
TeamMembershipType._limited_validator = bv.Void()
TeamMembershipType._tagmap = {
    'full': TeamMembershipType._full_validator,
    'limited': TeamMembershipType._limited_validator,
}

TeamMembershipType.full = TeamMembershipType('full')
TeamMembershipType.limited = TeamMembershipType('limited')

UpdatePropertyTemplateArg._template_id_validator = properties.TemplateId_validator
UpdatePropertyTemplateArg._name_validator = bv.Nullable(bv.String())
UpdatePropertyTemplateArg._description_validator = bv.Nullable(bv.String())
UpdatePropertyTemplateArg._add_fields_validator = bv.Nullable(bv.List(properties.PropertyFieldTemplate_validator))
UpdatePropertyTemplateArg._all_field_names_ = set([
    'template_id',
    'name',
    'description',
    'add_fields',
])
UpdatePropertyTemplateArg._all_fields_ = [
    ('template_id', UpdatePropertyTemplateArg._template_id_validator),
    ('name', UpdatePropertyTemplateArg._name_validator),
    ('description', UpdatePropertyTemplateArg._description_validator),
    ('add_fields', UpdatePropertyTemplateArg._add_fields_validator),
]

UpdatePropertyTemplateResult._template_id_validator = properties.TemplateId_validator
UpdatePropertyTemplateResult._all_field_names_ = set(['template_id'])
UpdatePropertyTemplateResult._all_fields_ = [('template_id', UpdatePropertyTemplateResult._template_id_validator)]

UserSelectorArg._team_member_id_validator = team_common.TeamMemberId_validator
UserSelectorArg._external_id_validator = team_common.MemberExternalId_validator
UserSelectorArg._email_validator = common.EmailAddress_validator
UserSelectorArg._tagmap = {
    'team_member_id': UserSelectorArg._team_member_id_validator,
    'external_id': UserSelectorArg._external_id_validator,
    'email': UserSelectorArg._email_validator,
}

UsersSelectorArg._team_member_ids_validator = bv.List(team_common.TeamMemberId_validator)
UsersSelectorArg._external_ids_validator = bv.List(team_common.MemberExternalId_validator)
UsersSelectorArg._emails_validator = bv.List(common.EmailAddress_validator)
UsersSelectorArg._tagmap = {
    'team_member_ids': UsersSelectorArg._team_member_ids_validator,
    'external_ids': UsersSelectorArg._external_ids_validator,
    'emails': UsersSelectorArg._emails_validator,
}

devices_list_member_devices = bb.Route(
    'devices/list_member_devices',
    False,
    ListMemberDevicesArg_validator,
    ListMemberDevicesResult_validator,
    ListMemberDevicesError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
devices_list_members_devices = bb.Route(
    'devices/list_members_devices',
    False,
    ListMembersDevicesArg_validator,
    ListMembersDevicesResult_validator,
    ListMembersDevicesError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
devices_list_team_devices = bb.Route(
    'devices/list_team_devices',
    True,
    ListTeamDevicesArg_validator,
    ListTeamDevicesResult_validator,
    ListTeamDevicesError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
devices_revoke_device_session = bb.Route(
    'devices/revoke_device_session',
    False,
    RevokeDeviceSessionArg_validator,
    bv.Void(),
    RevokeDeviceSessionError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
devices_revoke_device_session_batch = bb.Route(
    'devices/revoke_device_session_batch',
    False,
    RevokeDeviceSessionBatchArg_validator,
    RevokeDeviceSessionBatchResult_validator,
    RevokeDeviceSessionBatchError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
get_info = bb.Route(
    'get_info',
    False,
    bv.Void(),
    TeamGetInfoResult_validator,
    bv.Void(),
    {'host': u'api',
     'style': u'rpc'},
)
groups_create = bb.Route(
    'groups/create',
    False,
    GroupCreateArg_validator,
    GroupFullInfo_validator,
    GroupCreateError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
groups_delete = bb.Route(
    'groups/delete',
    False,
    GroupSelector_validator,
    async.LaunchEmptyResult_validator,
    GroupDeleteError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
groups_get_info = bb.Route(
    'groups/get_info',
    False,
    GroupsSelector_validator,
    GroupsGetInfoResult_validator,
    GroupsGetInfoError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
groups_job_status_get = bb.Route(
    'groups/job_status/get',
    False,
    async.PollArg_validator,
    async.PollEmptyResult_validator,
    GroupsPollError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
groups_list = bb.Route(
    'groups/list',
    False,
    GroupsListArg_validator,
    GroupsListResult_validator,
    bv.Void(),
    {'host': u'api',
     'style': u'rpc'},
)
groups_list_continue = bb.Route(
    'groups/list/continue',
    False,
    GroupsListContinueArg_validator,
    GroupsListResult_validator,
    GroupsListContinueError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
groups_members_add = bb.Route(
    'groups/members/add',
    False,
    GroupMembersAddArg_validator,
    GroupMembersChangeResult_validator,
    GroupMembersAddError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
groups_members_list = bb.Route(
    'groups/members/list',
    False,
    GroupsMembersListArg_validator,
    GroupsMembersListResult_validator,
    GroupSelectorError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
groups_members_list_continue = bb.Route(
    'groups/members/list/continue',
    False,
    GroupsMembersListContinueArg_validator,
    GroupsMembersListResult_validator,
    GroupsMembersListContinueError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
groups_members_remove = bb.Route(
    'groups/members/remove',
    False,
    GroupMembersRemoveArg_validator,
    GroupMembersChangeResult_validator,
    GroupMembersRemoveError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
groups_members_set_access_type = bb.Route(
    'groups/members/set_access_type',
    False,
    GroupMembersSetAccessTypeArg_validator,
    GroupsGetInfoResult_validator,
    GroupMemberSetAccessTypeError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
groups_update = bb.Route(
    'groups/update',
    False,
    GroupUpdateArgs_validator,
    GroupFullInfo_validator,
    GroupUpdateError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
linked_apps_list_member_linked_apps = bb.Route(
    'linked_apps/list_member_linked_apps',
    False,
    ListMemberAppsArg_validator,
    ListMemberAppsResult_validator,
    ListMemberAppsError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
linked_apps_list_members_linked_apps = bb.Route(
    'linked_apps/list_members_linked_apps',
    False,
    ListMembersAppsArg_validator,
    ListMembersAppsResult_validator,
    ListMembersAppsError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
linked_apps_list_team_linked_apps = bb.Route(
    'linked_apps/list_team_linked_apps',
    True,
    ListTeamAppsArg_validator,
    ListTeamAppsResult_validator,
    ListTeamAppsError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
linked_apps_revoke_linked_app = bb.Route(
    'linked_apps/revoke_linked_app',
    False,
    RevokeLinkedApiAppArg_validator,
    bv.Void(),
    RevokeLinkedAppError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
linked_apps_revoke_linked_app_batch = bb.Route(
    'linked_apps/revoke_linked_app_batch',
    False,
    RevokeLinkedApiAppBatchArg_validator,
    RevokeLinkedAppBatchResult_validator,
    RevokeLinkedAppBatchError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_add = bb.Route(
    'members/add',
    False,
    MembersAddArg_validator,
    MembersAddLaunch_validator,
    bv.Void(),
    {'host': u'api',
     'style': u'rpc'},
)
members_add_job_status_get = bb.Route(
    'members/add/job_status/get',
    False,
    async.PollArg_validator,
    MembersAddJobStatus_validator,
    async.PollError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_get_info = bb.Route(
    'members/get_info',
    False,
    MembersGetInfoArgs_validator,
    MembersGetInfoResult_validator,
    MembersGetInfoError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_list = bb.Route(
    'members/list',
    False,
    MembersListArg_validator,
    MembersListResult_validator,
    MembersListError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_list_continue = bb.Route(
    'members/list/continue',
    False,
    MembersListContinueArg_validator,
    MembersListResult_validator,
    MembersListContinueError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_recover = bb.Route(
    'members/recover',
    False,
    MembersRecoverArg_validator,
    bv.Void(),
    MembersRecoverError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_remove = bb.Route(
    'members/remove',
    False,
    MembersRemoveArg_validator,
    async.LaunchEmptyResult_validator,
    MembersRemoveError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_remove_job_status_get = bb.Route(
    'members/remove/job_status/get',
    False,
    async.PollArg_validator,
    async.PollEmptyResult_validator,
    async.PollError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_send_welcome_email = bb.Route(
    'members/send_welcome_email',
    False,
    UserSelectorArg_validator,
    bv.Void(),
    MembersSendWelcomeError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_set_admin_permissions = bb.Route(
    'members/set_admin_permissions',
    False,
    MembersSetPermissionsArg_validator,
    MembersSetPermissionsResult_validator,
    MembersSetPermissionsError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_set_profile = bb.Route(
    'members/set_profile',
    False,
    MembersSetProfileArg_validator,
    TeamMemberInfo_validator,
    MembersSetProfileError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_suspend = bb.Route(
    'members/suspend',
    False,
    MembersDeactivateArg_validator,
    bv.Void(),
    MembersSuspendError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
members_unsuspend = bb.Route(
    'members/unsuspend',
    False,
    MembersUnsuspendArg_validator,
    bv.Void(),
    MembersUnsuspendError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
properties_template_add = bb.Route(
    'properties/template/add',
    False,
    AddPropertyTemplateArg_validator,
    AddPropertyTemplateResult_validator,
    properties.ModifyPropertyTemplateError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
properties_template_get = bb.Route(
    'properties/template/get',
    False,
    properties.GetPropertyTemplateArg_validator,
    properties.GetPropertyTemplateResult_validator,
    properties.PropertyTemplateError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
properties_template_list = bb.Route(
    'properties/template/list',
    False,
    bv.Void(),
    properties.ListPropertyTemplateIds_validator,
    properties.PropertyTemplateError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
properties_template_update = bb.Route(
    'properties/template/update',
    False,
    UpdatePropertyTemplateArg_validator,
    UpdatePropertyTemplateResult_validator,
    properties.ModifyPropertyTemplateError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
reports_get_activity = bb.Route(
    'reports/get_activity',
    False,
    DateRange_validator,
    GetActivityReport_validator,
    DateRangeError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
reports_get_devices = bb.Route(
    'reports/get_devices',
    False,
    DateRange_validator,
    GetDevicesReport_validator,
    DateRangeError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
reports_get_membership = bb.Route(
    'reports/get_membership',
    False,
    DateRange_validator,
    GetMembershipReport_validator,
    DateRangeError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
reports_get_storage = bb.Route(
    'reports/get_storage',
    False,
    DateRange_validator,
    GetStorageReport_validator,
    DateRangeError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
team_folder_activate = bb.Route(
    'team_folder/activate',
    False,
    TeamFolderIdArg_validator,
    TeamFolderMetadata_validator,
    TeamFolderActivateError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
team_folder_archive = bb.Route(
    'team_folder/archive',
    False,
    TeamFolderArchiveArg_validator,
    TeamFolderArchiveLaunch_validator,
    TeamFolderArchiveError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
team_folder_archive_check = bb.Route(
    'team_folder/archive/check',
    False,
    async.PollArg_validator,
    TeamFolderArchiveJobStatus_validator,
    async.PollError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
team_folder_create = bb.Route(
    'team_folder/create',
    False,
    TeamFolderCreateArg_validator,
    TeamFolderMetadata_validator,
    TeamFolderCreateError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
team_folder_get_info = bb.Route(
    'team_folder/get_info',
    False,
    TeamFolderIdListArg_validator,
    bv.List(TeamFolderGetInfoItem_validator),
    bv.Void(),
    {'host': u'api',
     'style': u'rpc'},
)
team_folder_list = bb.Route(
    'team_folder/list',
    False,
    TeamFolderListArg_validator,
    TeamFolderListResult_validator,
    TeamFolderListError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
team_folder_permanently_delete = bb.Route(
    'team_folder/permanently_delete',
    False,
    TeamFolderIdArg_validator,
    bv.Void(),
    TeamFolderPermanentlyDeleteError_validator,
    {'host': u'api',
     'style': u'rpc'},
)
team_folder_rename = bb.Route(
    'team_folder/rename',
    False,
    TeamFolderRenameArg_validator,
    TeamFolderMetadata_validator,
    TeamFolderRenameError_validator,
    {'host': u'api',
     'style': u'rpc'},
)

ROUTES = {
    'devices/list_member_devices': devices_list_member_devices,
    'devices/list_members_devices': devices_list_members_devices,
    'devices/list_team_devices': devices_list_team_devices,
    'devices/revoke_device_session': devices_revoke_device_session,
    'devices/revoke_device_session_batch': devices_revoke_device_session_batch,
    'get_info': get_info,
    'groups/create': groups_create,
    'groups/delete': groups_delete,
    'groups/get_info': groups_get_info,
    'groups/job_status/get': groups_job_status_get,
    'groups/list': groups_list,
    'groups/list/continue': groups_list_continue,
    'groups/members/add': groups_members_add,
    'groups/members/list': groups_members_list,
    'groups/members/list/continue': groups_members_list_continue,
    'groups/members/remove': groups_members_remove,
    'groups/members/set_access_type': groups_members_set_access_type,
    'groups/update': groups_update,
    'linked_apps/list_member_linked_apps': linked_apps_list_member_linked_apps,
    'linked_apps/list_members_linked_apps': linked_apps_list_members_linked_apps,
    'linked_apps/list_team_linked_apps': linked_apps_list_team_linked_apps,
    'linked_apps/revoke_linked_app': linked_apps_revoke_linked_app,
    'linked_apps/revoke_linked_app_batch': linked_apps_revoke_linked_app_batch,
    'members/add': members_add,
    'members/add/job_status/get': members_add_job_status_get,
    'members/get_info': members_get_info,
    'members/list': members_list,
    'members/list/continue': members_list_continue,
    'members/recover': members_recover,
    'members/remove': members_remove,
    'members/remove/job_status/get': members_remove_job_status_get,
    'members/send_welcome_email': members_send_welcome_email,
    'members/set_admin_permissions': members_set_admin_permissions,
    'members/set_profile': members_set_profile,
    'members/suspend': members_suspend,
    'members/unsuspend': members_unsuspend,
    'properties/template/add': properties_template_add,
    'properties/template/get': properties_template_get,
    'properties/template/list': properties_template_list,
    'properties/template/update': properties_template_update,
    'reports/get_activity': reports_get_activity,
    'reports/get_devices': reports_get_devices,
    'reports/get_membership': reports_get_membership,
    'reports/get_storage': reports_get_storage,
    'team_folder/activate': team_folder_activate,
    'team_folder/archive': team_folder_archive,
    'team_folder/archive/check': team_folder_archive_check,
    'team_folder/create': team_folder_create,
    'team_folder/get_info': team_folder_get_info,
    'team_folder/list': team_folder_list,
    'team_folder/permanently_delete': team_folder_permanently_delete,
    'team_folder/rename': team_folder_rename,
}

